# 통신의 종류
```java
HTTP 통신 vs Socket 통신
통신을 하는데 있어서 다음과 같이 크게 두 가지로 나눌 수 있다.
HTTP 통신
Socekt 통신
HTTP와 Socket의 가장 큰 차이점은 접속(Connection)을 유지하는지의 여부이다.
HTTP 통신
HTTP 통신은 웹브라우저에 정보를 표시하는 것과 같이 클라이언트의 요청이 있을 때

서버가 해당 페이지에 대한 자료를 전송하고 곧바로 연결을 끊는 방식이다.

현재 이 글을 보고 있는 상황에 맨 처음 이 페이지를 로드 시에만 서버와 연결이 되고

현재는 서버와 접속이 끊어진 상태이다.

이 상태에서 F5 키를 눌러 새로고침을 하거나 다른 페이지로 이동하면 그때 다시 서버와 연결을 한다.



이렇게 하는 이유는 단 한가지. 서버의 부하를 줄여서 다른 접속을 원활하게 처리하기 위해서이다.

만약 F5 키에 연필을 꽂아서 클라이언트가 서버를 계속해서 물고 늘어지면

서버는 이 클라이언트의 연결을 유지하느라 다른 컴퓨터의 응답이 늦어질 것이다.

이런 방식으로 여러 대의 PC가 서버를 붙잡고 늘어져서 서버가 다른 일을 하지 못하도록 하는 것을 DDOS 공격이라한다.

Socket 통신
Socket 통신은 클라이언트가 서버와 접속이 되면 서버나 클라이언트에서 강제로 접속을 해제할 때까지는 계속해서 접속이 유지된다.

따라서 서버의 능력이 무한대가 아닌 이상 동시에 접속할 수 있는 클라이언트의 수가 제한이 될 수 밖에 없다.


 
Socket 통신은 실시간으로 정보 교환이 필요하는 채팅이나 온라인 게임, 실시간 동영상 강좌 등에 사용된다.

따라서 이와 같은 경우가 아니라면 서버와의 통신은 HTTP를 사용하는 것이 시스템의 자원을 보다 효과적으로 사용할 수 있다.



```

## Java-C
* C 서버에서 java client 로 데이터를 전송 할 때에는 반드시 데이터 끝에 "\r\n" 문자를 추가해줘야지 자바에서 데이터 끝임을 인식한다. 

## Socket
* port는 구멍, 통로
* 소켓 -> 바인드 -> 어셉트(블록); 클라이언트의 접속을 기다리다가  클라이언트에서 connect되면 socket의 IP, 포트 번호 전달해줌(socket 객체) 전달 ->
클라이언트에서 receive(블록)상태로 기다리고 있음
Socket server: socket() > bind > listen > accept > send > recv
  - Socket client: socket() >                connect > recv > send > close
* Rdp, Spice, UXP protocol
* 세션이 동작하면 서로 인증서를 교환함  
    ^when session is running, they communicate authentication to each other
* http도 소켓의 종류 중 하나이다.
  ^http is kind of socket  
  - https도 암호화 하는데 시간이 걸리지만 현재는 거의 차이가 없는걸로 결론이 남. 

### Socket_Chatting
* DB 테이블의 charset이 latin1으로 되어 있을 경우, 한글로 된 정보를 테이블에 그대로 저장할 수 없다. 그대로 저장할 경우 정보가 손실된다. -> getBytes
* 배열, List<list>, Hashmap
  - List<list>는 시스템이 허락해 주는 만큼 할당 해 줄 수 있는데 만약 10000<2>로 방이 10000개면 10000번 돌아야함
  - Hashmap(key, socket); key는 random으로 값을 전달해 주는


# 소켓
```java
전구에서 소켓의 역할은 전선과 접속되게 하는 일을 하지요.
프로그래밍에서의 소켓은 네트워크와 접속하게 해주는 역할을 해요.

그래서 결론적으로는 데이터를 주고받을수 있게하지요.

그럼 TCP/IP 소켓 프로그래밍이라는것은
TCP/IP 모델을 이용하고, 데이터를 주고받을때 소켓을
사용하는 프로그래밍을 한다고 볼수 있겠네요.
```

```java
소켓은 이렇게 어플리케이션에게 네트워크 접속을 위한 연결장치, 
인터페이스 역할을 하는것입니다. 네트워크 어플리케이션이 보낸 데이터를 소켓을 거쳐 
운영체제상에 존재하는 TCP/IP 소프웨어에게 전달하게 됩니다. 다시 하드웨어 상인 랜카드를 거쳐 
네트워크에 전달하게 됩니다. 서버의 경우는 클라이언트와 정 반대되는 개념입니다.
네트워크는 서버에게 보낸데이터를 서버의 랜카드에게 보내지게 됩니다. 
다시 운영체제의 TCP/IP소프트웨어를 거쳐 어플리케이션과 연결개념인 소켓을 통해 최종적으로 
서버 어플리케이션에게 전달되는것입니다.소켓은 이렇게 어플리케이션과 TCP/IP 사이에 존재 하고 있습니다.
```

## 클라이언트 소켓
```java
클라이언트 소켓(Client Socket)은 처음 소켓(Socket)을
[1]생성(create)한 다음, 서버 측에 [2]연결(connect)을 요청합니다. 
그리고 서버 소켓에서 연결이 받아들여지면 데이터를 
[3]송수신(send/recv)하고, 모든 처리가 완료되면 소켓(Socket)을 [4]닫습니다(close).
```

# 서버 소켓
* [소켓]('https://recipes4dev.tistory.com/153')
```java
서버 소켓(Server Socket)은 처리 과정이 조금 복잡합니다. 
일단 클라이언트와 마찬가지로, 
첫 번째 단계는 소켓(Socket)을 [1]생성(create)하는 것입니다. 
그리고 서버 소켓이 해야 할 두 번째 작업은, 
서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 [2]결합(bind)시키는 것입니다. 
그런 다음 클라이언트로부터 연결 요청이 수신되는지 [3]주시(listen)하고,
요청이 수신되면 요청을 [4]받아들여(accept) 데이터 통신을 위한 소켓을 생성합니다. 
일단 새로운 소켓을 통해 연결이 수립(ESTABLISHED)되면, 클라이언트와 마찬가지로 데이터를 
[5]송수신(send/recv)할 수 있습니다. 마지막으로 데이터 송수신이 완료되면, 소켓(Socket)을 [6]닫습니다(close).
```
## TCP/IP
* TCP/IP 계층은 OSI 7계층을 더 단순화 시켜서 4개의 계층(Layer)로 만들어서 사용한다.
```java
Application Layer
이 계층은 네트웍을 사용하는 응용프로그램(FTP, Telnet, SMTP) 등으로 이루어지며, 
OSI 계층의 Aplication Layer 와 Presentation Layer 를 모두 포함한다.

Transport Layer
계층의 이름에서 알수 있듯이, 도착을 원하는 시스템까지 데이타를 전송하기 위한 일을 하는 게층이다.
OSI 모델의 Session Layer 과 Transport Layer 를 포함하고 있으며, 
각각의 시스템을 연결하고, TCP 프로토콜을 이용하여 데이타를 전송한다.

Internet Layer
데이타를 정의하고 데이타의 경로를 배정하는일(라우팅)을 담당한다. 
데이타를 정확히 라우팅 하기 위해서 IP프로토콜을 사용한다. 
OSI 의 Network Layer 과 Data Link Layer 를 포함한다.

Physical Layer
물리적 계층 즉 이더넷 카드와 같은 하드웨어를 말한다.
```

```java
WWW (World Wide Web)은 더이상 설멍이 필요없는 유명한 서비스로써,
HTTP (HyperText Transfor Protocol)이라는 프로토콜을 이용한다.
위의 그림을 설명해 보자면, 일단 사용자는 Mozilla 나 IE 같은 브라우저를 사용하여서
www.joinc.co.kr 같은 URL 입력을 통해서 웹페이지를 요쳥한다.

사용자의 요청(문자 메시지가 될것이다)은 인터넷상에서 전달되기 용이한 패킷으로
만들기 위해서 TCP 패킷으로 만들어지게 된다.
이것은 다시 인터넷 상에서 원하는 주소로 이동할수 있도록 하기 위해서 
IP 패킷으로 다시 만들어 지고(IP 패킷에는 자신의 주소와, 도착해야될 상대방의
주소정보가 들어있을것이다) 이것은 이더넷 카드로 보내어져서 Internet 으로 나가게 된다.

Internet 상에서는 원하는 주소로 TCP/IP 패킷을 보내기 위한 여러가지 장치들이 
존재하는데(라우터, 토큰링 같은), 이들 장치를 통해서, www.joinc.co.kr 의 이더넷카드로
TCP/IP 패킷이 전달되게 된다. 그럼 이더넷 카드는 TCP/IP 패킷을 바로 윗 계층(Internet Layer)으로 보내는데,
여기에서는 IP 패킷을 분석해서, 이 패킷이 어디에서 왔으며, 그 도착지가 어디인지를 판단하게 된다.
(물론 이는 IP주소 기반으로 판단한다)

그리하여 목적지가 자신이면 이것을 다시 Transport Layer 로 보내고, TCP 프로토콜을 사용하여, 
메시지가 누락된게 있으면 다시 요청하고, 순서를 재조합하는등 통신 메시지를 검사해서 
이것을 다시 Application Layer 에게 보낸다
Application Layer 에서는 웹서버(IIS, Apache 같은)가 통신메시지를 HTTP 프로토콜에 준하여,
검사를 하여서 사용자가 요청한 웹페이지를 읽어들여서, Transport 계층으로 보내게 된다.

웹페이지를 브라우저까지 전송하는 과정은 위의 정반대의 과정을 순차적으로 거치게 된다.
최종적으로 웹브라우저는 웹페이지를 받아서(text) 역시 HTTP 프로토콜에 준하여, 
렌더링 작업을 거친후 화면에 뿌려주게 된다.
위의 그림에서 보면 알겠지만 각각의 계층은 각각의 계층만을 상관하고 있음을 알수 있다. 
즉 Application Layer 에 위치하는 브라우저와 webserver 는 HTTP 프로토콜에 의해서 
자신의 계층끼리만 통신을 하고, Transport Layer 은 역시 TCP 프로토콜에 의해서 
Transport Layer 끼리 통시을 함을 알수 있을것이다. 말그대로 계층적 구조를 가지며, 
각 계층은 대응되는 상대편의 계층에 대해서만 상관한다.
```
