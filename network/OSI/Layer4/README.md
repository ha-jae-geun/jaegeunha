# 전송 계층
- 데이터의 전송을 위한 논리적인 연결을 하는 대문같은 역할을 합니다. 신뢰성 있는 전송을 보장하기 위해 오류 검출 및 복구와 흐름 제어를 제공합니다.
* 송신자의 프로세스와 수신자의 프로세스를 연결하는 통신 서비스
* 전송계층은 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어, 다중화와 같은 편리한 서비스 제공
* 포트번호, 프로그램의 연결 정보

```java
정보를 분할하고, 상대편에 도달하기 전에 다시 합치는 과정을 담당하는 계층이다.

4계층의 단위 : Segment

목적지 컴퓨터에서 발신지 컴퓨터 간의 통신에 있어 흐름제어, 혼잡 제어, 오류제어를 담당한다.

전송 방식을 결정한다.
EX) 포트번호나 TCP/UDP 등

4계층 프로토콜 : TCP, UDP

TCP - 신뢰성, 비 연결지향성 프로토콜, Connection-ful(연결을 유지하며 전송하는 방식)
UDP - 비 신뢰성, 비 연결지향성 프로토콜, Connection-less(연결을 유지하지 않고 전송하는 방식, Data 손실을 신경쓰지 않음)
```

# 포트 번호
* 특정 프로세스와 특정 프로세스가 통신을 하기 위해 사용한다.
* 하나의 포트는 하나의 프로세스만 사용 가능하다.
* 하나의 프로세스가 여러 개의 포트를 사용하는 것은 가능하다.
* 포트 번호는 일반적으로 정해져 있지만 무조건 지켜야 하는 것은 아니다.
* 예를 들어 웹서비스는 80번 포트를 사용하지만 웹 서비스가 항상 80번 포트를 사용해야만 하는 것은 아니다.

## Well-known 포트
* 전 세계적으로 유명한 포트(0~1024)
* 잘 알려진 것이지 절대적인 것은 아니다.
* FTP: 20, 21
* SSH: 22
* TELNET: 23
* DNS: 53
* DHCP: 67, 69
* TFTP: 69
* HTTP: 80; 웹 서버 프로토콜
* HTTPS: 443

## Registered 포트
* 조금은 유명한 포트(1024 ~ 49152)
* 오라클 DB서버: 1521번
* MYSQL: 3306번
* MS 원격 데스크탑: 3389번


## Dynamic 포트
* 일반 사용자들이 사용하는 포트
* 시작 포트 번호: 49152,  마지막 포트 번호: 65535

## 나와 현재 연결되어있는 컴퓨터들
* 현재 포트 활성 여부를 나타내는 활성 연결 테이블
* nentstat -ano




# UDP 프로토콜(User/Universal Datagram Protocol)
* 사용자 데이터그램 프로토콜은 유니버셜 데이터그램 프로토콜이라고 일컫기도 한다.
* UDP의 전송 방식은 너무 단순해서 서비스의 신뢰성이 낮고, 데이터그램 도착 순서가 바뀌거나, 중복되거나 심지어는 통보 없이 누락시키기도 한다.
* UDP는 일반적으로 오류의 검사와 수정이 필요 없는 프로그램에서 수행할 것으로 가정한다.
* 용량이 큰 파일은 UDP로 전송하지 않는다.

## UDP 프로토콜 구조
* 소스 포트(2) + Destination Port(2) + Length(2) + CheckSUm(2)

## DNS 서버
* UDP 프로토콜을 사용하는 대표적인 프로그램
* 도메인을 물으면 IP를 알려주는 서버

## tftp 서버
* UDP로 파일을 공유하는 서버

## RIP 프로토콜
* 라우팅 정보를 공유하는 프로토콜

## HTTP3
* [Http3.0](https://github.com/ha-jae-geun/jaegeunha/blob/master/network/HTTP/README.md)

# TCP 프로토콜
* 안전한 연결을 지향하는 프로토콜


# 3-way handshaking
- 클라이언트와 서버가 통신을 하기전 정확한 전송을 보장하기 위해 컴퓨터간 세션을 수립하는 과정으로서 TCP 프로토콜에서 신뢰성을 보장하기 위해 사용됩니다.

## 3-way handshaking이 어떻게 신뢰성을 제공하는가

## 3-wau handshaking 과정
- 초기 클라이언트 상태는 CLOSED 상태이고 서버의 열려있는 포트의 상태는 LISTEN 상태입니다. 먼저 클라이언트가 서버에게 SYN 신호를 보내면 서버에서는 SYN_RCV 상태로 변경됩니다. 다시 서버는 클라이언트에게 SYN 에 대한 응답으로 ACK 를 보내는데 이때 클라이언트의 포트도 열어달라는 요청으로 SYN 를 같이 보냅니다. ACK 와 SYN 를 받은 클라이언트는 ESTABLISHED 로 변경되고 응답신호로서 ACK 를 서버에게 보낸다. 마지막으로 서버가 ACK 신호를 받으면 ESTABLISHED 상태가 되면서 클라이언트와 서버간 연결이 성공합니다.

## 4-way handshaking
- 클라이언트와 서버가 연결하기 위해 3-way handshaking 과정이 필요하듯이 연결을 종료할때에도 데이터 손실없는 전송을 보장하기 위해 handshaking 과정이 필요한데 이것이 4-way handshaking 입니다.

## 4-way handshaking 과정
- 클라이언트가 종료하겠다는 신호인 FIN 을 서버에 보내고 자신은 FIN_WAIT_1 상태로 변경됩니다. FIN 을 받은 서버는 ClOSE_WAIT 상태로 변경되고 응답으로 ACK 를 보냅니다. ACK 를 받은 클라언트는 다시 FIN_WAIT_2 상태로 변경됩니다. 이때 서버는 남은 데이터를 모두 전송하고 전송을 다하면 연결을 종료한다는 신호로 FIN 을 클라이언트에 보며 LAST_ACK 상태로 변경됩니다. FIN 을 받은 클라이언트는 TIME_WAIT 상태로 변경되면서 응답으로 ACK 를 서버에 보내고, 자신은 일정시간이 지난 후 CLOSED 상태로 변경됩니다. 마지막으로 응답신호를 받은 서버는 CLOSED 상태로 변경되면서 포트를 닫게 됩니다.

## 서버가 마지막에 FIN 을 보내는 이유
- 서버가 아직 클라이언트에 보낼 데이터가 남아있을 경우 데이터를 다 전송하지도 못한채 클라이언트에서 포트를 닫아버리게 되므로 서버 또한 종료될 준비가 되었다는 의미로 FIN 을 보내게 됩니다.

## 클라이언트가 마지막에 ACK 를 굳이 보내는 이유
- 서버가 보낸 FIN 신호를 클라언트가 받지 못 할 경우 클라이언트는 FIN_WAIT_2 상태로 종료가 되지 못한채 계속 기다리게 될 것입니다. 허나 서버는 이미 포트를 닫고 더이상 응답을 안하는 상태이기에 클라이언트는 불필요한 자원을 소모하게 됩니다.

