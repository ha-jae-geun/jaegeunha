# 문제
```java
4. 해싱함수 중 주어진 키를 여러 부분으로 나누고, 각 부분의
값을 더하거나 배타적 논리합(XOR : Exclusive OR) 연산을 통하여 나온 결과로 주소를 취하는 방법은? 3번
① 중간 제곱 방법(Mid-square method)
② 제산 방법(Division method)
③ 폴딩 방법(Folding method)
④ 기수 변환법(Radix conversion method)


8. 해싱에서 동일한 홈 주소로 인하여 충돌이 일어난 레코드들 의 집합을 의미하는 것은? 3번
① Overflow ② Bucket
③ Synonym ④ Collision
```

# [해시 function](https://www.youtube.com/watch?v=Rpbj6jMYKag&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=38)

# 배열
* 원소 하나를 저장하고 검색하는데 O(n)의 시간 소요
* 트리는 원소 하나를 저장하고 검색하는데 평균 O(log n)의 시간 소요
  * 저장된 자료가 많아지면 오래걸림
* 저장된 자료의 양과 상관없이 원소 하나를 저장하고 검색하는 것을 상수 시간에 할 수는 없을까?
  * 해시 테이블의 등장

# [해시 테이블](http://mm.sookmyung.ac.kr/~bigrain/class/2011/algorithm/ch06.pdf)
* 임의의 원소를 해시 테이블에 저장하려면
  1. 해당 원소의 해시값을 해시 함수를 이용하여 계산한다
  2. 이 해시값을 주소로 하는 위치에 원소를 저장한다
  3. 저장 후에 검색을 할 때도 원소의 해시값을 계산해 바로 해당 위치로 이동한다
* 이렇게 해시 테이블은 원소를 저장할 위치를 상수 시간에 계산할 수 있다.
* 해시 테이블은 저장된 자료와 비교할 필요 없이 해당 값에 저장하는 형식

# 해시 함수
* 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
  * f(x0 = x mod 13; 최대 12의 값을 가짐

## 좋은 해시 함수의 조건
1. 계산이 간단해야 한다.
2. 입력 원소가 해시 테이블 전체에 고루 저장되어야 한다
  * 해시 충돌을 피하기 위해

# 해시 충돌
* 해시 함수가 서로 다른 두 개의 입력값에 대해 같은 출력값을 내는 상황

## 체이닝
* 같은 주소로 해싱되는 원소를 모두 하나의 연결리스트에 매달아서 관리한다
* 원소를 검색할 때는 해당 연결 리스트의 원소들을 차례로 지나가면서 탐색한다.
* 하지만 체이닝이 길어지면 원소를 검색하는데 짧은 시간이 걸리는 기존의 해싱의 장점이 사라짐

## 개방 주소 방법(Open addressing)
* 체이닝과 달리 어떻게든 주어진 테이블 공간에서 해결한다
* 따라서 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다
* 선형조사(Linear probing), 이차원 조사(quardratic probing), 더블 해싱(double hashing)

### 선형 조사
* 가장 간단한 충돌 해결 방법
* 충돌이 일어난 자리에 관한 일차 함수의 보폭으로 점프한다
* hi(x)는 h(x)에서 i만큼 떨어진 자리이다
* 테이블의 경계를 넘어갈 경우에는 맨 앞으로 돌아간다


### 이차원 조사
* 바로 뒷자리를 보는 대신 보폭을 이차 함수로 넓혀가면서 본다
* 예를 들어 i번째 해시 함수롤 h(x)에서 i^2만큼 떨어진 자리로 삼는다
* 특정 영역에 원소가 몰려도 그 영역을 빨리 벗어날 수 있다.

### 더블 해싱
* 두 개의 함수를 이용한다
* 하나의 함수는 최초의 해시값을 얻을 때, 다른 하나의 함수는 해시 충돌이 일어났을 때 이동할 폭을 얻을 때 사용한다
* 두 원소의 첫 번째 해시값이 같더라도 두 번쨰  해시값까지 같은 화률은 매우 작으므로 서도 다른 보폭으로 점프하게 한다.

# 해시 함수의 특징
* 같은 입력값에 대해서 같은 출력값이 보장된다
* 서로 다른 입력값으로부터 동일한 출력값이 나올 가능성이 희박하므로 입력값에 대한 무결성이 보장된다
* 일방향성을 갖는다.


# 해시의 응용
* 무결성 검사
* 클라우드 스토리지에서 동일한 파일 식별 및 수정된 파일 검출
* 데이터베이스에 비밀번호를 저장할 때 사용
* 블록체인
* 깃

# 해싱
* [mattlee](https://mattlee.tistory.com/62)
```java
Hash Table
hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 
특정한 값을 Search 하는데 데이터 고유의 인덱스로 접근하게 되므로 average case 에 대하여 Time Complexity 가
O(1)이 되는 것이다.(항상 O(1)이 아니고 average case 에 대해서 O(1)인 것은 collision 때문이다.) 
하지만 문제는 이 인덱스로 저장되는 key값이 불규칙하다는 것이다.

그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다.
특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나,
삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.


Hash Function
'특별한 알고리즘'이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보인다. 위에서 언급한 '특별한 알고리즘'을
hash method 또는 해시 함수(hash function)라고 하고 이 메소드에 의해 반환된 데이터의 고유 숫자 값을 hashcode라고 한다.
저장되는 값들의 key 값을 hash function을 통해서 작은 범위의 값들로 바꿔준다.

하지만 어설픈 hash function을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 key 값에
복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 Collision 이라고 한다. Collision : 
서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.

그렇다면 좋은 hash function는 어떠한 조건들을 갖추고 있어야 하는가?
일반적으로 좋은 hash function는 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다. 
하지만 좋은 해쉬 함수는 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.

hash function를 무조건 1:1 로 만드는 것보다 Collision 을 최소화하는 방향으로 설계하고 발생하는 Collision 에
대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런
hash function를 만들어봤자 그건 array 와 다를바 없고 메모리를 너무 차지하게 된다.

Collision 이 많아질 수록 Search 에 필요한 Time Complexity 가 O(1)에서 O(n)에 가까워진다. 어설픈 hash function는
hash 를 hash 답게 사용하지 못하도록 한다. 좋은 hash function를 선택하는 것은 hash table 의 성능 향상에 필수적인 것이다.

따라서 hashing 된 인덱스에 이미 다른 값이 들어 있다면 세 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 
것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.


Resolve Conflict
기본적인 두 가지 방법부터 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 응용한
방법들이기 때문이다.

1. Open Address 방식 (개방주소법)
해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용 중인 경우) 다른 해시 버킷에 해당 자료를 삽입하는 방식 
이다. 버킷이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다. 다른 해시 버킷이란 
어떤 해시 버킷을 말하는 것인가?

공개 주소 방식이라고도 불리는 이 알고리즘은 Collision 이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. Worst Case
의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 여러 방법들이
존재하는데, 다음 세 가지에 대해 알아보자.

Linear Probing 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
Quadratic probing 2 차 함수를 이용해 탐색할 위치를 찾는다.
Double hashing probing 하나의 해쉬 함수에서 충돌이 발생하면 2 차 해쉬 함수를 이용해 새로운 주소를 할당한다.
위 두 가지 방법에 비해 많은 연산량을 요구하게 된다.

2. Separate Chaining 방식 (분리 연결법)
일반적으로 Open Addressing 은 Separate Chaining 보다 느리다. Open Addressing 의 경우 해시 버킷을 채운 밀도가
높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이
잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case 에 가까워 지는 빈도를 줄일 수 있다.
Java 7 에서는 Separate Chaining 방식을 사용하여 HashMap 을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.

연결 리스트를 사용하는 방식(Linked List) 각각의 버킷(bucket)들을 연결리스트(Linked List)로 만들어
Collision 이 발생하면 해당 bucket 의 list 에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 
삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 
오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 비해 테이블의 확장을 늦출 수 있다.

Tree 를 사용하는 방식 (Red-Black Tree) 기본적인 알고리즘은 Separate Chaining 방식과 동일하며 연결 리스트
대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시
버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 링크드 리스트를 사용하는 것이 맞다. 
트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case 를 살펴보면 트리와 
링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.

데이터가 적다는 것은 얼마나 적다는 것을 의미하는가? 앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된
key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6 개, 8 개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게
느껴질 수 있다. 7 은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6 과 8 로 잡은 것은 변경하는데
소요되는 비용을 줄이기 위함이다.

한 가지 상황을 가정해보자. 해시 버킷에 6 개 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다.
만약 기준이 6 과 7 이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 
삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1 이라면
Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2 라는 여유를 남겨두고 기준을 잡아준 것이다. 
따라서 데이터의 개수가 6 개에서 7 개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 
8 개에서 7 개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.

Open Address vs Separate Chaining
일단 두 방식 모두 Worst Case 에서 O(M)이다. 하지만 Open Address방식은 연속된 공간에 데이터를 저장하기 
때문에 Separate Chaining에 비해 캐시 효율이 높다. 따라서 데이터의 개수가 충분히 적다면 Open Address방식이
Separate Chaining보다 더 성능이 좋다. 한 가지 차이점이 더 존재한다. Separate Chaining방식에 비해 
Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있다.

보조 해시 함수
보조 해시 함수(supplement hash function)의 목적은 key의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 
것이다. Separate Chaining 방식을 사용할 때 함께 사용되며 보조 해시 함수로 Worst Case 에 가까워지는 경우를 줄일 수 있다.


해시 버킷 동적 확장(Resize)
해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 
그래서 HashMap 은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다.
이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 또 애매모호한 '일정 개수 이상
'이라는 표현이 등장했다. 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의
75%가 될 때이다. 0.75라는 숫자는 load factor 라고 불린다.
```
```java
 대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로 비교하면서 탐색을 원하는 항목에 접근한다. 
 반면 해싱은 키 값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다. 
 이렇게 키 값의 연산에 의해 직접 접근이 가능한 구조를 해시 테이블(hash table)이라 부르고,
 해시 테이블을 이용한 탐색을 해싱(hashing)이라 한다.



 키들의 비교에 의한 탐색 방법은 정렬이 안 되어 있다면 $O(n)$이고 정렬이 되어 있다면 $O(log_2n)$이다. 
 정렬되어 있는 경우의 시간 복잡도가 $O(log_2n)$인 건 이진 탐색 알고리즘 혹은 이진 탐색 트리의 탐색 
 알고리즘의 시간복잡도를 생각하면 된다. 잘 모르겠다면 이진 탐색 또는 이진 탐색 트리 알고리즘 게시물을 참고하도록 하자.



 해싱이 나오게 된 배경은 위에서 설명한 시간복잡도 보다 더욱 빠른 탐색을 필요로 할 때다. 해싱은 
 이론적으로 $O(1)$의 시간 안에 탐색을 끝마칠 수도 있다. 해싱은 보통 사전(dictionary)과 같은 자료 
 구조를 구현할 때에 최상의 선택이 된다.



출처: https://mattlee.tistory.com/62 [waca's field]
```

# 해시
* 가변적인 길이의 데이터를 고정적인 길이의 데이터로 만들어 주는 알고리즘
* 단방향이다; 출력값을 넣는다 해서 입력값이 나오지 않는다.
* 해시 함수 구현 -> 원본 데이터 넣음 -> 해시 데이터

## 해시 값 특징
* 해시 값은 원본으로 되돌릴수 없다. (계산을 통해 원본으로 되돌릴 수 없다.)
  * 원본의 값을 알지 못하게 하는 단방향 암호화에 많이 사용된다.
 * 원본 데이터가 같으면 해쉬값도 일정하다.
  * 정해진 알고리즘에 따라 원본 데이터를 해시값으로 바꿔주기 떄문이다.
 * 충돌 가능성이 존재한다.
   * 정해진 길이의 값이기 때문에 원본이 달라도 다른 값이 나올 수 있다. 확률은 낮다

## 용도
1. 무결성의 확인; 데이터가 변했는지 안변했는지의 여부
  * 원본이 같으면 같은 해시값이 나오기 때문에 해ㅐ시값이 같으면 원본과 입력받은 데이터가 같다고 간주할 수 있다.
2. 아무리 큰 데이터도 고정된 길이의 값으로 나오기 때문에 비교속도가 빠르다.
  * 이런 이유로 무선통신, 전자서명, 파일의 ㅂ교, 블럭체인, 서비스 인증에 자주 사용
3. 검색 속도를 높이기 위해 사용
  * 버킷(고정된 해시 값) 을 통해 DB에 접근하여 빠르게 값을 가져옴; 버킷을 만드는 공간은 사용되지만 속도는 빨라짐

## 사용시 주의점
* 해커들은 레인보우 테이블을 보고 입력값을 예측할 수 있다. 그럴 때 필요한게 Salt 이다.
1. Salt의 사용; 원본에 첨가해서 해시값을 다르게 만드는 값
  * Brute-Force Attack(무작위로 문자열을 대입하는 해킹 기법)에 대처하기 위해
  * Salt의 길이를 최대한 길게, 안전하게 보관한다.
2. Key-Stretching: 해시값을 여러번 해시값에 넣기를 반복하여 해킹을 방지
3. 데이터 충돌을 방지해야 한다.
  * 리스트를 데이터로 관리하는 Chaining 기법을 사용
  * 위치를 조정하는 Open Addressing 기법 사용
  
## SHA
* NSA에의해 1993년 처음 개발된 해시 알고리즘
* 현재 주로 사용되는 것은 SHA-2 함수군으로, 다이제스트의 깅리에 따라 SHA-256 SHA-512 등으로 나뉜다
* SHA-0, SHA-1까지는 해시 충돌성이 존재하지만 256, 512는 해시 충돌성이 사실상 0에 수렴한다
* 2256의 의미: 해싱을 하면 2^256개의 해시값 중 하나가 나타난다
  
## SHA-2 계열
* 보안을 위한 암호화 할 때 사용
* MD5나 SHA-1의 경우 충돌 및 보안 결함이 발견되어 보안용도로는 더이상 사용하지 않는다.
