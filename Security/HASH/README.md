# 해싱
* [mattlee](https://mattlee.tistory.com/62)
```java
 대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로 비교하면서 탐색을 원하는 항목에 접근한다. 
 반면 해싱은 키 값에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다. 
 이렇게 키 값의 연산에 의해 직접 접근이 가능한 구조를 해시 테이블(hash table)이라 부르고,
 해시 테이블을 이용한 탐색을 해싱(hashing)이라 한다.



 키들의 비교에 의한 탐색 방법은 정렬이 안 되어 있다면 $O(n)$이고 정렬이 되어 있다면 $O(log_2n)$이다. 
 정렬되어 있는 경우의 시간 복잡도가 $O(log_2n)$인 건 이진 탐색 알고리즘 혹은 이진 탐색 트리의 탐색 
 알고리즘의 시간복잡도를 생각하면 된다. 잘 모르겠다면 이진 탐색 또는 이진 탐색 트리 알고리즘 게시물을 참고하도록 하자.



 해싱이 나오게 된 배경은 위에서 설명한 시간복잡도 보다 더욱 빠른 탐색을 필요로 할 때다. 해싱은 
 이론적으로 $O(1)$의 시간 안에 탐색을 끝마칠 수도 있다. 해싱은 보통 사전(dictionary)과 같은 자료 
 구조를 구현할 때에 최상의 선택이 된다.



출처: https://mattlee.tistory.com/62 [waca's field]
```

# 해시
* 가변적인 길이의 데이터를 고정적인 길이의 데이터로 만들어 주는 알고리즘
* 단방향이다; 출력값을 넣는다 해서 입력값이 나오지 않는다.
* 해시 함수 구현 -> 원본 데이터 넣음 -> 해시 데이터

## 해시 값 특징
* 해시 값은 원본으로 되돌릴수 없다. (계산을 통해 원본으로 되돌릴 수 없다.)
  * 원본의 값을 알지 못하게 하는 단방향 암호화에 많이 사용된다.
 * 원본 데이터가 같으면 해쉬값도 일정하다.
  * 정해진 알고리즘에 따라 원본 데이터를 해시값으로 바꿔주기 떄문이다.
 * 충돌 가능성이 존재한다.
   * 정해진 길이의 값이기 때문에 원본이 달라도 다른 값이 나올 수 있다. 확률은 낮다

## 용도
1. 무결성의 확인; 데이터가 변했는지 안변했는지의 여부
  * 원본이 같으면 같은 해시값이 나오기 때문에 해ㅐ시값이 같으면 원본과 입력받은 데이터가 같다고 간주할 수 있다.
2. 아무리 큰 데이터도 고정된 길이의 값으로 나오기 때문에 비교속도가 빠르다.
  * 이런 이유로 무선통신, 전자서명, 파일의 ㅂ교, 블럭체인, 서비스 인증에 자주 사용
3. 검색 속도를 높이기 위해 사용
  * 버킷(고정된 해시 값) 을 통해 DB에 접근하여 빠르게 값을 가져옴; 버킷을 만드는 공간은 사용되지만 속도는 빨라짐

## 사용시 주의점
* 해커들은 레인보우 테이블을 보고 입력값을 예측할 수 있다. 그럴 때 필요한게 Salt 이다.
1. Salt의 사용; 원본에 첨가해서 해시값을 다르게 만드는 값
  * Brute-Force Attack(무작위로 문자열을 대입하는 해킹 기법)에 대처하기 위해
  * Salt의 길이를 최대한 길게, 안전하게 보관한다.
2. Key-Stretching: 해시값을 여러번 해시값에 넣기를 반복하여 해킹을 방지
3. 데이터 충돌을 방지해야 한다.
  * 리스트를 데이터로 관리하는 Chaining 기법을 사용
  * 위치를 조정하는 Open Addressing 기법 사용
  
## SHA-2 계열
* 보안을 위한 암호화 할 때 사용
* MD5나 SHA-1의 경우 충돌 및 보안 결함이 발견되어 보안용도로는 더이상 사용하지 않는다.
