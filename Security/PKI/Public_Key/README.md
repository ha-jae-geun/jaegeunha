# set
```java
8. SET(Secure Electronic Transaction)의 설명으로 옳은
것은?
1 SET 참여자들이 신원을 확인하지 않고 인증서를 발
급한다.
2 오프라인상에서 금융거래 안전성을 보장하기 위한
시스템이다.
3 신용카드 사용을 위해 상점에서 소프트웨어를 요구
하지 않는다.
4 SET는 신용카드 트랜젝션을 보호하기 위해 인증, 기
밀성 및 메시지 무결성 등의 서비스를 제공한다.

답 4
▷ SET는 비자와 마스터가 함께 개발한 전자 상거래 거래 프
로토콜이다.
RSA 암호화 방식과 인증을 지원. 선 압축 후 전자서명
4 기밀성, 무결성, 인증, 부인 방지 등의 서비스를 제공한다.
<오답 체크> 1 인증서를 발급할 땐 당연히 신원을 확인한다.
2 SET는 온라인 전자 상거래를 위한 시스템이다.
3 소프트웨어를 필요로 한다.
```

# 공개키 종류
```java
소인수분해 문제의 어려움에 기초하여 큰 안전성
을 가지는 전자 서명 알고리즘은?
1 RSA 2 ElGamal
3 KCDSA 4 ECDSA

답 1
• 비대칭키 암호(공개키 암호)
RSA : 소인수분해
Rabin : 소인수분해
ElGamal : 이산대수
ECC : 타원곡선 상의 이산대수
Schnorr : 이산대수, ElGamal 에 기반, 짧은 키 길이
DSA : 이산대수, Schnorr 의 응용
DSS : 이산대수, 전자서명 전용
ECDSA : 내부적으로 타원곡선
Knapsack(배낭 문제) : 부분집합의 합을 구하는 문제
(NP-complete 문제)
KCDSA : 국산, 국내표준, 이산대수
ECKDSA : 국산, 내부적으로 타원곡선, 소규모, 무선
```

# [디프 헬만](https://m.blog.naver.com/PostView.nhn?blogId=pgh7092&logNo=221146735104&proxyReferer=https:%2F%2Fwww.google.com%2F
```java
10. 20.국가.9급
소수 p = 13, 원시근 g = 2, 사용자 A와 B의 개인키가 각각
3, 2일 때, Diffie-Hellman 키 교환 알고리즘을 사용하여 계
산한 공유 비밀키는?
1 6
2 8
3 12
4 16
∘ Diffie-Hellman 알고리즘에 의해 비밀키를 구하면 수식은 다음과 같다. 3 Diffie-Hellman 알고리즘에 의해 비밀키를 구하면 다음과
같다. 
 ×  mod   

 mod    mod   



사용자 A와 B가 Diffie-Hellman 키 교환 알고리
즘을 이용하여 비밀키를 공유하고자 한다. A는 3을, B
는 2를 각각의 개인키로 선택하고, A는 B에게 21(=
7
3 mod 23)을, B는 A에게 3(= 7

2 mod 23)을 전송
한다면, A와 B가 공유하게 되는 비밀키 값은? (단, 소
수 23과 그 소수의 원시근 7을 사용한다)

A가 계산한 값 3

3^3 mod 23 = 4
B가 계산한 값 212 mod 23 = 4
공통의 비밀키 4를 갖게 된다.
◈ 디피 헬만 키 교환 순서
1. 앨리스가 충분히 큰 소수 p와 g를 선택하여 밥에게 전송한다.
g는 1부터 p-1 사이의 수이다.
2. 앨리스가 정수 a를 선택한다. 이 정수는 외부에 공개되지 않으며,
밥 또한 알 수 없다.
3. 앨리스가 A = g

a mod p, 즉 g

a 를 p로 나눈 나머지를 계산

한다.
4. 밥이 마찬가지로 정수 b를 선택하여 B = g

b mod p 를 계산

한다.
5. 앨리스와 밥이 서로에게A와 B를 전송한다.
6. 앨리스가 B

a mod p를, 밥이 A

b mod p를 계산한다.

B
a mod p = (g
b mod p)
a
mod p = g
ab mod p

A
b mod p = (g
a mod p)
b mod p = g

ab mod p 으로
같으므로, 앨리스와 밥은 공통의 비밀키를 갖게 된다.


문 12. Diffie-Hellman 키 교환 알고리즘에 대한 설명으
로 옳은 것은?
1 두 사용자가 메시지 암호화에 사용할 공개키를 안전
하게 교환하기 위한 것이다.
2 중간자(MITM) 공격에 안전하다.
3 키를 교환하는 두 사용자 간의 상호 인증 기능을 제
공한다.
4 이산대수 문제를 푸는 것이 어렵다는 점을 활용한
것이다.

답 4
4 디피 헬만 키 교환(Diffie–Hellman key exchange) 알고리즘은
두 송수신자 간 공통의 비밀키(대칭키)를 생성하기 위한 방법으
로, 이산대수의 어려움에 기반한 알고리즘이다.
<오답 체크> 1 공개키가 아니라 비밀키(대칭키)를 안전하게 교환
하기 위한 것이다.
23 통신 상대방을 인증하지 않기 때문에 중간자(MITM) 공격에
취약하다.


Diffie-Hellman 알고리즘은 (Ga mod P)b mod P와
(Gb mod P)a mod P를 계산한 값이 같다는 대수적인 성
질을 활용한다. 다음 설명 중 옳지 않은 것은?
1 a와 b는 비밀값이다.
2 P는 소수이다.
3 두 개의 키를 합성하면 새로운 키가 생성된다.
4 중간자 공격을 방지한다.
5 암호화와 복호화에 필요한 키를 분배하거나 교환하
기 위한 것이다.

답 4
4 디피-헬만 키 교환방식은 통신 상대방을 인증하지 않기 때문에
중간자 공격에 취약하다.
<오답 체크> 1 송·수신자 사이에 전송되는 값은 p, g, Ga mod P,
Gb mod P 값이다. a와 b는 상대방에게 전송하지 않고 본인만 알
고 있는 비밀값이다.
```

# [RSA 암호 키 계산](https://www.google.com/search?q=%EC%86%8C%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4%EC%9D%98+%EC%96%B4%EB%A0%A4%EC%9B%80%EC%9D%84+%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C+%ED%95%9C+RSA+%EC%95%94%ED%98%B8+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90+%EC%84%9C+%EA%B0%9C%EC%9D%B8%ED%82%A4+d%EB%8A%94+7%2C+%ED%95%A9%EC%84%B1%EC%88%98+n%EC%9D%80+33%2C+%ED%8F%89%EB%AC%B8+%EA%B0%92%EC%9D%B4+5%EC%9D%BC+%EB%95%8C%2C+%EC%9D%B4%EB%A5%BC+%EC%95%94%ED%98%B8%ED%99%94%ED%95%9C+%EC%95%94%ED%98%B8%EB%AC%B8%EC%9D%98+%EA%B0%92%EC%9C%BC%EB%A1%9C+%EA%B0%80%EC%9E%A5+%EC%A0%81%EC%A0%88%ED%95%9C+%EA%B2%83%EC%9D%80%3F&rlz=1C1OKWM_koKR924KR924&oq=%EC%86%8C%EC%9D%B8%EC%88%98%EB%B6%84%ED%95%B4%EC%9D%98+%EC%96%B4%EB%A0%A4%EC%9B%80%EC%9D%84+%EA%B8%B0%EB%B0%98%EC%9C%BC%EB%A1%9C+%ED%95%9C+RSA+%EC%95%94%ED%98%B8+%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90+%EC%84%9C+%EA%B0%9C%EC%9D%B8%ED%82%A4+d%EB%8A%94+7%2C+%ED%95%A9%EC%84%B1%EC%88%98+n%EC%9D%80+33%2C+%ED%8F%89%EB%AC%B8+%EA%B0%92%EC%9D%B4+5%EC%9D%BC+%EB%95%8C%2C+%EC%9D%B4%EB%A5%BC+%EC%95%94%ED%98%B8%ED%99%94%ED%95%9C+%EC%95%94%ED%98%B8%EB%AC%B8%EC%9D%98+%EA%B0%92%EC%9C%BC%EB%A1%9C+%EA%B0%80%EC%9E%A5+%EC%A0%81%EC%A0%88%ED%95%9C+%EA%B2%83%EC%9D%80%3F&aqs=chrome..69i57.395j0j7&sourceid=chrome&ie=UTF-8)
```java
13. 다음의 지문은 RSA 알고리즘의 키생성 적용 순서를
설명한 것이다. ( )를 바르게 채운 것은?
ᄀ. 두 개의 큰 소수, p와 q를 생성한다. (p ≠ q)
ᄂ. 두 소수를 곱하여, n = p · q를 계산한다.
ᄃ. ( 가 )을 계산한다.
ᄅ. 1 < A < ∅(n)이면서 A, ∅(n)이 서로소가 되는 A
를 선택한다. A · B 를 ∅(n)으로 나눈 나머지가 1
임을 만족하는 B를 계산한다.
ᄆ. 공개키로 ( 나 ), 개인키로 ( 다 )를 각각 이용한
다.
가 나 다
1 ∅(n) = (p − 1)(q − 1) (n, A) (n, B)
2 ∅(n) = (p + 1)(q + 1) (n, B) (n,A)
3 ∅(n) = (p − 1)(q − 1) (n, B) (n,A)
4 ∅(n) = (p + 1)(q + 1) (n, A) (n, B)

답 1
1 먼저 구한 A 를 암호화키로 이용하고, 나중에 구한 B 를 복
호화키로 이용한다.


문 4. RSA 암호 알고리즘에서 두 소수, p =17, q =23과 키 값 e =3을
선택한 경우, 평문 m = 8에 대한 암호문 c로 옳은 것은? 1
1 121 2 160
3 391 4 512

[해설]
m^e mod n = c
n = p * q = 17 * 23 = 391
8^3 mod 391 = 121


15. 오일러 함수 Φ( )를 이용해 정수 n = 15에 대한 Φ(n)
을 구한 값으로 옳은 것은? (단, 여기서 오일러 함수 Φ( )
는 RSA 암호 알고리즘에 사용되는 함수이다.)
1 1
2 5
3 8
4 14

답 3
RSA 암호 알고리즘 키 생성 과정에서 n은 두 소수인 p와 q의
곱이며, Φ(n)는 p-1과 q-1의 곱이다.
n = p × q // Φ(n) = ( p – 1 ) × ( q – 1 )
n을 두 소수로 인수분해하면, 3 × 5 가 되며,
따라서 Φ(n) = ( 3 – 1 ) × ( 5 – 1 ) = 2 × 4 = 8 이 된다.

◈ RSA 알고리즘 공개키와 개인키 생성 순서
○ 단계 1: 두 소수 p, q를 선정한다.
○ 단계 2: n = p × q를 계산한다.
○ 단계 3: Φ(n) = ( p – 1 ) × ( q – 1 )을 계산한다.
(단, Φ(n)은 오일러의 Totient 함수이다.)
○ 단계 4: Φ(n)보다 작고, Φ(n)과 서로소의 관계를 갖는 임의의 e
값을 선택한다.
○ 단계 5: e × d mod Φ(n) = 1의 관계를 갖는 d를 계산한다.
(단, mod는 나머지를 구하는 연산자이다.)
○ 단계 6: (e, n)을 공개키로 하고, (d, n)을 개인키로 한다.
암호문 = 평문
e
mod n
평문 = 암호문
d
mod n



문 10. 정보보호 시스템에서 사용된 보안 알고리즘 구
현 과정에서 곱셈에 대한 역원이 사용된다. 잉여류
Z26에서 법(modular) 26 에 대한 7 의 곱셈의 역원으
로 옳은 것은?
1 11 2 13
3 15 4 17

답 3
곱셈에 대한 역원 구하는 법은
7xa mod 26 ≡ 1 이 되는 a를 찾으면 된다.
26 x 1 + 1 = 26 + 1 = 27
26 x 2 + 1 = 52 + 1 = 53
26 x 3 + 1 = 78 + 1 = 79
26 x 4 + 1 = 104 + 1 = 105(7 의 15 배수)
7 x 15 mod 26 ≡ 1
∴ 26 에 대한 7 의 곱셈의 역원은 15 이다.


n = p × q 일 때,
오일러의 Totient 함수는 Φ(n) = ( p – 1 ) × ( q – 1 ) 가 된다.
따라서 Φ(n)은 ( 11 – 1 ) × ( 13 – 1 ) = 120 이다.
e는 Φ(n)보다 작고, Φ(n)과 서로소의 관계를 갖는 정수이므로,
17과 19가 가능하다.
9는 120과 공약수 1, 3을 가지므로 서로소 관계가 아니고, 127
은 120보다 크므로 안 된다.


문 19. RSA 암호 알고리즘에 대한 설명으로 옳지 않은 것
은?
1 대표적인 비대칭 암호 알고리즘으로, 널리 사용되고
있다.
2 공개키 {e,n}이 주어지면 지수 및 모듈러 연산을 통
해 n과 무관한 임의 크기의 평문 블록을 하나의 암
호문 블록으로 암호화할 수 있다.
3 공개키 {e,n}의 n을 소인수분해할 수 있으면 개인키
{d,n}의 d를 알아낼 수 있다.
4 일반적으로 키의 길이가 길수록 안전성은 높아지지
만 알고리즘 수행시간은 길어진다.

답 2
2 RSA 암호화시 입력 데이터의 길이가 키의 길이(n)보다 크다면
예외가 발생한다. 따라서 키의 길이와 같거나 작도록 데이터를
나누어 암호화를 수행해야 한다.


단계 1: p = 5, q = 11
단계 2: n = 5 × 11 = 55
단계 3: Φ(n) = ( 5 – 1 ) × ( 11 – 1 ) = 40
(또한, 오일러의 Totient 함수 Φ(n)는 1 부터 n 까지의 양의
정수 중 n 과 서로소인 수의 개수를 나타내는 함수이다.
1 부터 55 까지 55 와 서로소인 수의 개수는 40 개이다.)
단계 4: 40 과 서로소의 수 선택(서로소는 공약수가 1 밖에 없
는 두 정수를 의미. 또는 최대공약수가 1 인 두 정수)
1 40 과 12 는 공약수가 1, 2 이다.
2 40 과 13 은 공약수가 1 밖에 없어 e 값으로 적절하다.
3 40 과 15 는 공약수가 1, 5 로 2 개이다.
4 40 과 18 은 공약수가 1, 2 로 2 개이다.
단계 5: 13 × d mod 40 = 1 의 관계를 갖는 d 를 계산
d 가 37 이라면 13 × 37 = 481 로, 481 mod 40 = 1 이 된다.
단계 6: 공개키 (e, n) = (13, 40)
개인키 (d, n) = (37, 40)
```

# 문제
```java
공개키 암호에 대한 설명으로 옳지 않은 것은?
1 공개키 인증서를 공개키 디렉토리에 저장하여 공개한다.
2 사용자가 증가할수록 필요한 비밀키의 개수가 증가하는
암호방식의 단점을 해결할 수 있다.
3 일반적으로 대칭키 암호방식보다 암호화 속도가 느리다.
4 n명의 사용자로 구성된 시스템에서는 
  개의

키가 요구된다.

- 5 - 5

∘ 공개키 인증서는 누구나 접근 가능한 공개키 디렉토리에 저장하여 공
개한다.
∘ 공개키 암호는 대칭키 암호시스템의 키배송문제를 해결하기 위하여
등장 했다.
∘ 공개키 암호는 대칭키 암호에 비해 키의 길이는 길고, 속도는 느리다.
4 n명의 사용자로 구성된 시스템에서는 2n개의 키가 요
구된다.
4


19. 다음 설명을 모두 만족하는 암호화 알고리즘은?
◦ 공개키 암호 알고리즘이다.
◦ 이산대수 문제의 어려움에 기반을 둔다.
◦ Diffie-Hellman 키 교환 프로토콜의 확장이다.
1 SEED 암호
2 Rabin 암호
3 ElGamal 암호
4 Blowfish 암호

답 3
3 ElGamal 암호 알고리즘은 이산대수의 어려움에 기반한 공
개키 암호 알고리즘이다.
<오답 체크> 1 SEED 암호는 한국정보보호진흥원에서 만든
대칭키 블록 암호 알고리즘. 128 비트 블록 암호 알고리즘
으로, 페이스텔 구조이며, 국내 전자상거래에 이용된다.
2 Rabin 암호는 소인수분해의 어려움에 기반한 공개키 암호
알고리즘이다.
4 Blowfish(블로피시) 암호는 페이스텔 구조로, 64 비트 블록
크기, 32 비트에서 최대 448 비트에 이르는 가변 키 길이를
갖는다.


13. 다음에서 설명하는 암호 알고리즘은?
○ Koblitz와 Miller가 제안한 것이다.
○ RSA보다 키의 길이를 작게 하면서도 대등한 보안
성을 제공한다.
○ 전자서명이나 키 교환에 활용될 수 있다.
○ 메모리와 처리능력이 제한된 분야에 효율적이다.
1 ElGamal
2 ECC(Elliptic Curve Cryptography)
3 Rabin
4 WHIRLPOOL

답 2
2 ECC 알고리즘
타원곡선 상의 이산대수(이산로그) 계산의 어려움을 이용한 공개
키 암호 알고리즘. RSA 알고리즘에 비해 키 길이가 매우 짧은
것이 특징이며, 그 덕에 메모리가 처리능력이 제한된 무선통신
환경에서는 ECC가 매우 효과적이다.
RSA 512비트와 비슷한 안전성을 제공하는 ECC 키 길이는 106
비트면 충분하다. 이러한 차이는 키 길이가 길수록 더 두드러지
게 나타나며, ECC 512비트는 RSA 15,000비트와 동일한 안전성
을 가진다.
<오답 체크> 1 ElGamal 알고리즘
이산대수의 어려움에 기반한 공개키 암호 알고리즘.
RSA는 같은 메시지, 같은 키 값을 이용할 경우 그 암호문이 항
상 일정한 반면, ElGamal은 난수 k를 이용하기 때문에, 매 암호
화 시 암호문이 바뀌어 RSA에 비해 더 안전하다.
다만, 암호화시 메시지의 길이가 두 배가 되는 단점이 있다.
3 Rabin 알고리즘
소인수분해의 어려움에 기반한 공개키 암호 알고리즘이다.
RSA 알고리즘의 변형이며 RSA에 비해 효율적이다.
4 WHIRLPOOL 알고리즘은 해시 함수 알고리즘으로, 블록 크기를
512비트로 나누어 계산하며, 512비트의 해시값을 출력한다.


16. 공개키 기반 구조(PKI: Public Key Infrastructure)에
대한 설명으로 옳지 않은 것은?
1 공개키 인증서는 특정 사용자의 신원과 그 사용자의
공개키를 바인딩시키는 기술이다.
2 공개키 인증서를 생성할 때는 인증기관(CA:
Certificate Authority)의 공개키를 사용하여 서명할
수 있다.
3 CA간에는 인증 체인을 형성할 수 있기 때문에 특정
CA에 의해 서명된 인증서는 인증 체인상의 다른
CA에 의해서도 보장될 수 있다.
4 공개키 인증서 서명에는 RSA나 ECDSA를 사용할
수 있다.
5 PKI에서 RA(Registration Authority)는 인증서 발급
을 요청한 사용자의 신원을 검증하는 역할을 한다.

답 2
2 공개키 인증서는 인증기관의 개인키를 사용하여 서명을 하여 생
성을 하고, 사용자가 인증기관의 공개키를 사용하여 서명을 검증
하여 올바른 공개키 인증서임을 확인한다.
<오답 체크>
4 RSA와 ECDSA는 모두 공개키 암호화 알고리즘므로 전자서명에
이용될 수 있다.




공개키 기반 구조(PKI: Public Key Infrastructure)에 대한
설명으로 가장 적절하지 않은 것은?
1 공개키 기반 구조의 구성요소로는 사용자(user), 등록기
관(Registration Authority), 인증기관(Certification
Authority), 저장소(repository) 등이 있다. 
2 공개키 인증서를 발행하여 무결성, 인증, 부인방지를 보
장한다. 
3 등록기관은 인증서와 인증서 취소 목록(Certificate Revocation
List)을 발행하고, 공개키 등록 시 본인을 인증한다.
4 저장소는 인증서를 보관해 두고, PKI의 이용자가 인증서
를 입수할 수 있도록 구성된 데이터베이스이다.

지안에듀 - 3 - 조현준 선생
3 인증서와 인증서 취소 목록(Certificate Revocation List)을
발행하고, 공개키 등록 시 본인을 인증하는 것은 인증기관의 역할이다. 그
러나 인증기관이 하는 일 가운데는 「공개키의 등록과 본인에 대한 인증」


다음 공개키 기반 구조(Public Key Infrastructure)에 대한
설명 중 가장 옳은 것은 무엇인가?
1 공개키 기반 구조는 대칭키 암호시스템에 기초하여 디지털
인증서를 생성하고 관리하는데 필요한 정책 및 절차이다. 2 정책 인증 기관(Policy Certification Authority)은 공개
키 기반 구조 전반에 사용되는 정책과 절차를 수립하는
기관이다. 3 등록 기관(Registration Authority)은 공개키 기반 구조
의 필수 구성요소로서 사용자의 신분과 소속을 확인하고
사용자에게 공개키 인증서를 발행하는 기능을 수행한다. 4 인증서에는 버전, 일련번호, 유효기간 등의 정보가 담겨
있다. 1 공개키 기반 구조는 공개키 암호시스템에 기초하여 디지
털 인증서를 생성하고 관리하는데 필요한 정책 및 절차이다. 2 정책 승인
기관(PAA, Policy Approving Authority)에 대한 설명이다. 3 RA는 선택
적인(optional) 요소이다. RA가 없을 때에 인증기관은 RA의 기능을 수행할
수 있다고 가정한다. 4



문 1. 전자 서명(digital signature) 보안 메커니즘이 제공하는 보안
서비스가 아닌 것은? 2
1 근원 인증
2 메시지 기밀성
3 메시지 무결성
4 부인 방지

[해설]
전자 서명의 특징
- 위조불가: 서명자만이 서명문을 생성할 수 있다. - 부인방지: 서명자는 서명 후에 사실을 부인할 수 없다. - 재사용 불가: 한번 서명한 서명문은 또 다른 문서에 사용할 수 없다. - 변경 불가: 내용 변경시 서명문 자체가 변경되어 변조 사실을 확인이
가능하다. - 서명자 인증: 서명자의 서명문은 서명자의 식별이 가능하다.

```

# 공개키 암호의 원리
* 소인수분해 문제 이용 : 큰 두 소수의 곱을 계산하는 것은 쉽지만 역으로 큰 두 소수의 곱인 합성수가 주어졌을 때, 이것을 소인수분해하기는 어렵다. RSA, Rabin 등
* 이산대수 문제 이용 : 모듈러 연산으로 나머지만을 취하는 잉여계(residue) 시스템에서 위수를 구하는 것이 어렵다. DSA, KCDSA, ECC 등


## 공개키 장점
* 키 관리가 용이
* 안전성이 뛰어남
* 전자서명, 인증 등에 적용 할 수 있다.


## 공개키 단점
* 암/복호화 속도가 느리다.
* 키 사이즈가 크다.


# 공개키 알고리즘 종류
## RSA
* 1977년 론 리베스트(Ron Rivest)와 아디 셰미르(Adi Shamir), 레오나르드 아델만(Leonard Adleman) 등 3명의 수학자에 의해 개발된 알고리즘. 

## DSA ( 전자 서명 알고리즘 )
* Digital Signature Algorithm. 1990년 NIST에 의해 제안됨. 전자서명에 주로 사용. 암호화는 가능하나 복잡해서 잘 안 씀. 

## KCDSA ( 한국 인증서 기반 전자서명 알고리즘 )
* Korea Certification-based Digital Signature Algorithm. 한국통신정보보호학회의 주관하에 우리나라 암호학자들이 1996년11월에 개발함. 1998년 10월에 한국정보통신기술협회(TTA)에서 표준으로 제정

## ECC ( 타원곡선 암호 )
* Elliptic Curve Cryptosystem. 1985년 워싱턴대학교의 수학교수인 닐 코블리츠(Neal Koblitz)와 IBM연구소의 빅터 밀러(Victor Miller)가 거의 동시에, 독립적으로 고안하였는데, 해독 방법은 아직 발견되지 않았다. 짧은 키 사이즈로 높은 안전성이 확보되고, 또한 서명할 때의 계산을 고속으로 할 수 있는 것이 특징.


# 전자서명
