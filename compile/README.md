# 기본
* [블로그](https://dailyheumsi.tistory.com/137?category=855210)
* 먼저, 하나의 코드가 프로그램이 되고, 프로그램이 프로세스가 되는 과정은 다음과 같다.
* 코드 작성 -- (컴파일) --> 오브젝트 파일 -- (링킹) --> 실행 파일(=프로그램) -- (로드) --> 메모리 적재 및 수행(=프로세스)

```java
컴파일러
​ 사용자가 작성한 원시코드를 컴퓨터가 읽을 수 있는 형태의 오브젝트 파일로 만드는 프로그램

어셈블러
​ 어셈블리어 코드를 기계어 코드로 변환시켜주는 프로그램.
​ 명확히 말하면, 어셈블러는 큰 의미 컴파일러 내부에 속한다.
​ 큰 의미의 컴파일러는 사실 다음과 같이 구성된다.
​ (원시 코드) -> (컴파일러) -> (어셈블리어 코드) -> (어셈블러) -> (기계어 코드 = 오브젝트 코드)

링커
​ 프로그램이 되기 위해 여러 개의 오브젝트 파일과 라이브러리를 엮는 과정(링킹)을 수행하는 프로그램

로더
​ 사용자가 프로그램을 실행하면, 메모리에 적재하는 일(로드)을 수행하는 프로그램

```

# 종류
1. 정적 컴파일러
* 빌드타임: 모든 코드를 기계어로 변경하여 실행파일로 만들어줌
* 런타임: 단순히 실행파일을 메모리에 올려 실행
* 장점: 특정한 시스템에 맞춰 기계어를 내보내므로 시스템에 최적화된 성능을 낼 수 있음
* 단점: 시스템마다 각각 컴파일해야하며 모든 환경에서 같은 동작을 보장하지 않음

2. 인터프리터
* 빌드타임: 프로그래머가 작성한 코드는 건드리지 않음
* 런타임: 번역기를 실행하여 실시간으로 기계어로 해석하여 실행함
* 장점: 인터프리터만 시스템마다 있다면 코드의 호환성은 보장됨
* 단점: 실시간 해석이  필요하므로 컴파일러보다 느린 성능

3. JIT컴파일러
* 빌드타임: 최적화된 중간언어로 변환
* 런타임: 중간언어를 실행하는 전용 프로그램인 미들웨어로 해석하여 실행
* 실시간 번역에 따른 시스템 부하를 줄여 실행성능을 높이면서도 시스템간의 호환성이 높은 장점
  * 실행환경에 더욱 최적화된 추가적인 장점도 존재한다.
* 장점: 한 번 컴파일한 코드의 캐싱, 자주 사용되는 코드만 검출하여 컴파일(adaptvie compilation)
* 단점: 실행시에 중간언어를 컴파일하느라 실행시간이 다소 지연된다는 점
