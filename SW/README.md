# 프로젝트
패키지
- 1-1. 모델 > 인스턴스 변수 == 데이터 베이스 컬럼과 일치시킴
- 1-2 컨트롤러 > 인터페이스 작성
- 1-3. 서비스 > 메소드 (입력, 수정, 삭제, 검색 4개)
- 직접 DB 접속
- 매개변수
- 1-4. 입력뷰 (입력, 수정, 삭제, 검색 4개)
- 출력뷰 (입력, 수정, 삭제, 검색 4개)







# 실무용어
```java
SB
WBS
as-is, to-be
needs
CMS
PG
PM 
PL
과업지시서
RFP
FrontEnd
BackEnd
TFT
구축, 리뉴얼, 고도화, 유지보수
실무용어를 사용하여 말해보기
```








# UML 
* Grady Booch, James Rumbaugh,  Ivar Jacobson
* Grady Booch, James Rumbaugh 모두 자신들만의 방법이 있다.
  Grady Booch and Ivar Jacobson have their own ways




# 프록시 패턴
* 프록시는 다른 객체에 대한 접근을 제어하는 객체이다
* 다른 객체를 대상(subject)라고 한다.
* 프록시와 대상은 동일한 인터페이스를 가지고 있으며 이를 통해 다른 인터페이스와 완전히 호환되도록 바꿀 수 있다.
* 프록시는 대상에서 실행될 작업의 전부 또는 일부를 가로채서 해당 동작을 행상시키거나 보완한다.
* 프록시는 각 작업을 대상으로 전달하여 추가적인 전처리 또는 후처리로 동작을 향상 시킨다.


## 프록시 사용
```java
프록시(Proxy)
프록시는 아래와 같은 형태로 실전에서 사용이 가능하다.

데이터 유효성 검사
프록시가 입력을 대상으로 전달하고 유효성을 검사한다.

보안
프록시는 클라이언트가 작업을 수행할 수 있는 권한이 있는지 확인하고 검사 결과가 긍정적인 경우에만 요청을 대상으로 전달

캐싱
프록시가 내부 캐시를 유지하여 데이터가 캐시에 아직 존재하지 않는 경우에만 대상에서 작업이 실행되도록 한다,

지연 초기화
대상의 생성 비용이 비싸다면 프록시는 그것을 필요로할 때까지 연기

로깅
프록시는 메소드 호출과 상대 매개 변수를 인터셉트하고 이를 기록한다.

원격객체
프록시는 원격 위치에 있는 객체를 가져와서 로컬처럼 보이게할 수 있다.
```

## 예제
```javascript
function StudentList() {
  this.students = {
    'park': 'a company',
    'kim': 'b company',
    'su': 'c company'
  };
}

StudentList.prototype.get = function(name) {
  const self = this;
  setTimeout(function() {
    console.log(self.students[name]);
  }, 3000);
}
StudentList라는 객체에 Proxy를 생성한 형태를 알아보자. studentListProxy라는 객체를 생성하고, 객체 내부에서는 studentList를 참조하고 있다.
proxy를 통해서 get 메서드를 실행해서 수강생을 조회하면 log를 남기도록 했다.

프록시는 대상에서 실행될 작업의 전부 또는 일부를 가로채서 해당 동작을 행상시키거나 보완한다.

StudentListPorxy라는 프록시를 통해서 대상(subject)를 참조해서 학생을 읽어오고, 동시에 로그도 남기도록 했다.
```

```javascript
function StudentListProxy() {
  const studentList = new StudentList();

  return {
    get: function(name) {
      this.getLog()
      studentList.get(name);
    },

    getLog: function() {
      console.log("get student");
    }
  };
}
```

# MVC 패턴 웹
- - 웹 브라우저; http 프로토콜 <->   서블릿(경로 통해서 매개변수 전달)<->   자바 -   모델(DAO, VO, DTO) <-> 오라클
- 뷰(웹브라우저의 입력창, 출력창),  컨트롤러(서블릿(경로 통해서 매개변수 전달); 프론트 컨트롤러
- 웹 브라우저의 뷰에서 모델 쪽을 안건든다.
- - 객체를 통한 재생산성을 사용할 때 함수(복제기능) 보다는 클래스(재생산성)를 사용한다.
- 도메인 모델 -> 퍼시스턴스 -> 서비스 -> 컨트롤러 -> 뷰 순으로 작업을 진행한다.

## 프리젠테이션 계층(Presentation Layer) -  표현과 이벤트 처리, 데이터 포맷 책임
 
 *  사용자와의 최종 접점으로 사용자로부터 데이터를 입력받거나 데이터를 출력해 보이는 계층이다. 프리젠테이션 계층은 외부로부터의 어플리케이션에 대한 요구를 받아들이는 부분인 동시에 처리 결과를 사용자에게 보여주는 부분이며, event-driven 방식의 GUI에 기반한 프리젠테이션을 포함하고 있으며, 이벤트 처리 및 데이터 포맷팅을 책임진다.
 *  프리젠테이션 계층은 컨트롤러의 구성 요소와 상호 작용한다.
 
 
## ● 제어 계층(Control Layer) -  구성 요소간의 처리흐름의 제어, 데어터 조작 의뢰, 데이터 변환 및 연산, Exception, Error 처리
 * 사용자로부터 요청을 받고 응답을 처리하는 계층이다. 뷰 층으로부터 이벤트를 메시지로 전환하여 Model에게 전달하는 사용자 입력에 대한 응답 메카니즘을 포함한다.
 *  
 *  하위 계층에서 발생하는 Exception이나 Error에 대한 처리를 맡으며, 최종 프리젠테이션 계층에 표현해야 할 도메인 모델을 엮는 기능, 사용자로부터 받은 데이터의 유효성 검증(Validation)을 처리 한다. 비즈니스 로직과 프레젠테이션 계층을 분리하기 위한 컨트롤러의 역할도 하며, 전체 시스템의 설정 상태를 유지하고, 요청에 해당하는 비즈니스 로직을 결정하는 역할을 한다.
 *  
 *  즉, 사용자의 요청을 검증하고 로직에 요청을 전달하는 일과 로직에서 전달된 응답을 적절한 뷰에 연결짓는 것이 제어 계층의 몫이다. 즉 "what to do" 를 담당하는 계층이다.
 

## ● 비즈니스 계층(Business Layer) - 컨트롤러와 뷰를 연결하는 역할, 다른 계층과 통신하기 위한 인터페이스 제공, 트랜잭션 처리 등
 
 *  애플리케이션의 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성을 검증한다. 또한, 트랜잭션 처리와 제어 계층과 퍼시스턴스 계층 사이를 연결하는 역할로서 두 계층이 직접적으로 통신하지 않게 하여 애플리케이션의 유연성을 증가시킨다.
 *  즉, 다른 계층들과 통신하기 위한 인터페이스를 제공한다. 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증 이외도 다양한 부가적인 구현이 추가된다. 즉, "how it's done" 를 담당하는 계층이다.
 *  

## ※ 모델계층
 * 비즈니스 계층와 퍼시스턴스 계층을 합치면 모델 계층이 된다. 모델 계층은 어플리케이션에 필요한 지속성 있는 데이터를 조작하며, 데이터베이스/파일의 데이터를 조작하는 기능을 수행한다. 또한, 인터페이스를 통해 데이터의 직접적 조작(입력, 수정, 삭제, 조회)을 담당한다.
 
 
## 퍼시스턴스 계층(Persistence Layer)
 
 *  영구 데이터를 빼내어 객체화 시키며, 영구 저장소에 데이터를 저장, 수정, 삭제하는 계층이다. 즉, 데이터베이스나 파일에 접근하여 데이터를 CRUD 하는 계층이다. 이 계층에서 사용할 수 있는 프레임워크로는 JDO, Hibernate, ibetis, EJB가 있다.
  
 
## ● 도메인 모델 계층(Domain Model Layer)
 
 *  관계형 데이터베이스의 엔티티와 비슷한 개념을 가지는 것으로 데이터 객체를 말한다.
 *  
 *  이렇게 계층을 분리하는 이유는 비즈니스 계층과 퍼시스턴스 계층이 해야 할 모든 작업을 JSP가 담당하게 된다면 JSP내에서 구현해야 할 작업이 너무 많아짐으로써 코드가 복잡해 짐으로 유지보수가 어려워짐을 막는 것이다. 이와 같이 명확하게 계층화하여 구현해야 재사용성이 높아지게 된다. 하나의 계층에서 모든 작업을 전담하는 경우 같은 작업을 반복해서 구현해야 하는 경우가 발생하게 되며, 이로 인해 많은 중복 코드가 발생하게 된다. 이는 향후 중복 코드의 변경이 필요한 경우 모든 소스 코드를 수정해야 하는 번거로움이 발생하게 된다.
 *  
 *  작은 애플리케이션은 계층을 분리하지 않고 로직과 표현을 하나에 처리해도 문제가 발생하지 않는다. 또한, 개발 생산성에서도 유용하다. 하지만 애플리케이션이 커지고 복잡해지는 대규모의 프로그램을 작성할 경우 로직과 표현이 섞여 있는 프로그램 코드는 유지보수나 확장성에 문제가 많다. 이렇게 계층을 구분하여 프로그램을 작성하면 각 계층간의 역할에 집중할 수 있으며 프로그램의 유연성과 확장성 및 재사용성을 높일 수 있다.
