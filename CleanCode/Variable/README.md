# 언어별 변수명 표기법
* 언어별로 스네이크/카멜 표기법 등 권장하는 변수 표기법이 정해져있다.

# [변수명](https://www.youtube.com/watch?v=rbSnkiqPnJI)
1. 변수 이름에는 동사를 넣지 않는다
2. 변수의 단수형에는 관사를 넣지 않는다.
3. 전치사는 최대한 생략한다
 * num을 앞에 쓰고싶으면 numUsers, 아니면 userCount
5. 단수/복수 구분(보편적: users, 배열일 경우 list)

## 예제
```javascript
행성 변수 이름 짓기
첫 번째 문제에 대한 답은 아주 간단합니다.

let ourPlanetName = "Earth";
planet이라는 간단한 이름을 지어줘도 되지만, 이렇게 하면 어떤 행성(planet)을 언급하는 것인지 모호합니다.
변수명이 아주 길어지지 않는 이상, 설명을 좀 더 곁들어주는 것이 좋습니다.

현재 방문자를 나타내는 변수 이름 짓기
현재 접속 중인 방문자 이름은 아래와 같이 변수를 만들어 저장해 볼 수 있습니다.

let currentUserName = "John";
여기서도 마찬가지로 userName같이 이름을 짧게 지어주기보다는, 
현재 접속 중인 사용자라는 정보를 담고 있는 이름으로 지어주는 것이 좋습니다.

모던 에디터와 자동 완성 기능을 이용하면 상대적으로 쉽게 여러 단어를 조합해서 변수명을 지을 수 있습니다.

지금 사용하는 에디터가 이런 기능을 제공하지 않는다면 코드 에디터 챕터를 참고해 새로운 에디터를 사용해 보시길 권유 드립니다.
```


# 클래스 변수, 인스턴스 변수
* 클래스 변수와 인스턴스 변수 사이에 공백 라인을 하나 넣어주면 가독성을 향상할 수 있음

# 인스턴스 변수
```java
2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

 새로운 인스턴스 변수를 가진 클래스는 응집도가 떨어진다. 
 많은 인스턴스 변수를 가진 클래스로 응집력있는 단일 작업을 설명할 수 있는 경우는 거의 없다. 
 (추측) 여기서 말하는 인스턴스 변수는 기본형 또는 자료구조형 객체들인 것으로,
 일급 컬렉션이나 wrapper객체는 해당되지 않는 것 같다.
 

 인스턴스 변수의 분해는 여러 개의 관련 인스턴스 변수의 공통성을 이해하게 하여 
 자료구조형으로 묶어 일급 컬렉션으로 생성할 수 있게 해준다.


 인스턴스 변수들의 집합을 갖고 있는 것에서, 협력 객체(일급 컬렉션/Wrapper 객체)의
 계층 구조로 분해하면 더 효율적인 객체 모델이 될 수 있다. 복잡하고 
 덩치 큰 객체를 이해하는 것은 어렵지만, 분해하면 간단해진다.
 

 분해하는 것이 어렵거나 막막하다면, 객체를 상관 관계가 있는 반(half)씩 나누거나, 
 인스턴스 변수를 둘 골라서 그로부터 하나의 객체를 만드는 등을 하는 것을 추천한다.
 

public class Jamie {
    
    private final String name;
    private final String job;
    private final int age;

    public Jamie(String name, String job, int age) {
        this.name = name;
        this.job = job;
        this.age = age;
    }
}
public class Jamie {

    private final Name name;
    private final Job job;
    private final Age age;

    public Jamie(Name name, Job job, Age age) {
        this.name = name;
        this.job = job;
        this.age = age;
    }
}
```

# 이름짓기
* [사이트](https://www.curioustore.com/#!/)

## 자료구조 타입
```java
리팩터링을 하다보면 자료구조를 변경할 일이 생기는데 (예 List > Set), 
변수명에 자료구조를 넣어두다보면 자료구조를 변경할 때마다 변수명을 변경해줘야 하거나, 
변수명으로 해당 변수를 오해할 수 있게 되기 때문에, 자료구조 타입 넣지 않기
```

```java
클래스 이름
1. 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
2. 동사는 사용하지 않는다.



변수 이름
1. 변수 이름에는 동사를 넣지 않는다
2. 변수의 단수형에는 관사를 넣지 않는다.
   user/users 정도
3. 전치사는 최대한 생략한다

ex) 개수(of 쓰지 않음)
    userCount / numUsers
    num이 들어가면 count라고 생각하면 됨



좋은 예

ex) Customer, WikiPage, Account, AddressParser

나쁜 예

ex) Manager, Processor, Data, Info

메소드 이름
메소드 이름은

동사나 동사구가 적합하다.



좋은 예

ex) postPayment, deletePage, save



접근자, 변경자, 조건자는 javabean 표준에 따라

값 앞에 get, set, is를 붙힌다.

string name = employee.getName();
customer.setName("goodGid");
if (paycheck.isPosted) 
```

# 의미있는 이름
```java
의도를 분명히 밝혀라
주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();

    for (int[] x : theList) {
        if (x == 4) {
            list1.add(x);
        }
    }
    return list1;
}
위 코드를 보면

코드의 목적을 짐작하기 어렵다.



Why?

각 변수의 역할이

명시적으로 드러나지 않기 때문에

(= 함축성을 갖고 있기 때문에)

코드 맥락을 이해하는게 어렵다.



만약 다음과 같은 정보를 아는 상황이였다면

위 코드가 쉽게 이해됐을 것이다.

theList가 갖고있는 값의 의미

값 4의 의미

함수가 반환하는 리스트 list1의 사용 용도



위의 코드는 지뢰찾기 게임을 만들기 위한 코드였다고 가정해보자.

그리고 다음과 같은 정보들이 제공되었다.

1xN의 게임판이 있다.

게임판의 각 칸은 단순 배열로 표현한다.

해당 위치에 값이 4일 경우엔 깃발(= Flag)이 꽂혀있다.

해당 위치에 값이 4가 아닐 경우엔 지뢰가 있다.



위 정보를 토대로

다시 코드를 보면

처음보다 이해가 잘 될 것이다.

public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();

    for (int[] x : theList) {
        if (x == 4) {
            list1.add(x);
        }
    }
    return list1;
}


조금만 더 Refactoring을 해보자.

변수명을 명시적으로 수정해주면

코드를 보다 명확하게 이해할 수 있다.


 
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();

    for (int[] cell : gameBoard) {
        if (cell == FLAGGED) {
            flaggedCells.add(cell);
        }
    }
    return flaggedCells;
}

 


또한 int 배열을 사용하는 대신

칸을 간단한 클래스로 만들어서 (= Cell)

FLAGGED라는 상수를 사용하지 않고

isFlagged라는 명시적인 함수를 사용하면

코드가 더 명확해진다.

public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<Cell>();

    for (Cell cell : gameBoard) {
        if (cell.isFlagged()) {
            flaggedCells.add(cell);
        }
    }
    return flaggedCells;
}
```

# 접두어 추가하기
```java
의미 있는 맥락 추가
대다수의 이름은 분명하지 못하다.

그럴 경우엔 접두어를 붙혀보자.

Example
예를 들어보자.
firstName, lastName, street, houseNumber, city, state, zipcode
위와 같은 변수가 선언이 되어 있다면

위 변수들의 사용처는

주소와 관계 되어 있음을 쉽게 파악할 수 있다.

But

state 변수 1개만 본다면

해당 변수가

주소를 의미하는 변수들 중 하나라는 것을

파악하는건 쉽지 않다.

Refactoring
주소를 나타내는 addr라는 접두어를 추가해보자.

state -> addrState로 변경하면

맥락이 좀 더 분명해진다.



One More Step

접두어를 사용하는 방법도 좋지만

가능하다면 Address라는 클래스를 생성하면

보다 맥락이 분명해진다.
```

# 동사와 키워드
```java
동사와 키워드
함수의 의도나

인수의 순서와 의도를 제대로 표현하려면

함수 이름을 좋게 Naming할 필요가 있다.

단항 함수
단항 함수는 함수와 인수가

동사/명사 쌍을 이뤄야 한다.



예를 들어

write(name)은 누구나 바로 이해한다.

==> name을 write한다.



좀 더 명확하게 수정도 가능하다.

write(name) -> writeField(name)

==> Field에 name을 write한다.

이항 함수
함수 이름에 키워드를 추가한다.


예를 들어

함수에서 인수의 순서가 중요하다면

함수 이름에 인수 이름을 넣는다.



assertEquals(expected, actual) 보다

assertExpectedEqualsActual(expected, actual)이 더 좋다.



함수명으로 인해

인수의 순서를 기억할 필요는가 없어진다.
```

# 주의해야할 점
```java
1. 지역 변수 범위를 최소화 하기

- 지역 변수 범위를 최소화하면 유지보수성이 높아지고 오류를 낼 가능성은 낮아진다.

지역 변수 범위를 최소화하기 위한 기법 3 가지

1) 가장 처음 쓰일 때 선언하기

  이제는 C언어에서도 코드 상단이 아닌 사용해야할 위치에서 변수를 선언한다. 가독성도 좋아진다.

2) 선언과 동시에 초기화하기 

  초기화에 필요한 정보다 부족하면 선언은 미뤄야 한다.

  try-catch는 try안에서 선언하는 것이 예외를 멀리 퍼지지 않게해서 좋다. 부득이하게 try-catch문 외부에서도 지역 변수를 사용해야한다면 
  try문 앞에서 선언해야한다.

3) 메서드를 최대한 작게 유지하고 그 메서드는 1개의 기능에만 집중하기

  만약 메서드에서 여러 기능을 수행하는데 지역 변수가 살아있다면 괜히 다른 기능에서 접근이 가능해져서 문제를 일으킬 수도 있다.



2. for문 보다는 for-each 문을 사용하기

- 배열이냐 컬렉이냐에 따라 문법 형태가 바뀌지 않고 변수가 조잡하지 않아 실수할 일이 적다.

for(int i=0;i<a.length;i++), Iterator, ... 뭐 이런게 안나와서 가독성도 좋고 성능도 떨어지지 않는다.

* for-each문을 사용할 수 없는 경우 (이럴 때만 기존 for문을 사용하자.)

1) 컬렉션을 순회하면서 선택된 원소를 제거하는 경우

  이럴 때는 반복자의 remove() 메서드를 사용해야한다. 물론 컬렉션은 removeIf()를 사용하면 for-each도 사용할 수 있다.

2) 배열을 순회하면서 원소의 값을 변경하는 경우

  일부나 전체 값을 변경하는 경우에는 배열의 인덱스를 사용해야한다.

3) 병렬 순회를 사용해야하는 경우

컬렉션을 스트림으로 병렬 순회하는 경우 인덱스를 사용하여 엄격하게 처리해야하므로 일반 for문을 사용해야한다.

참고로 for-each문을 사용하려면 Iterable<E> 인터페이스를 구현해야한다.

4. 정확한 값이 필요할 때는 Float, Double을 쓰지말자

- 금융과 관련된 계산처럼 정밀한 값을 표현할 때는 Float, Double을 쓰면 안된다.

Float, Double은 0.1, 0.01등을 표현할 수 없기 때문이다.

대신 BigDecimal, int, long을 사용하도록 하자.



5. 박싱된 기본 타입(Integer, Double, Boolean)보다 기본 타입(int, double, boolean)을 사용하자.

- 엄연히 박싱된 기본 타입은 클래스고 내부적으로 식별성 속성을 갖는다.

기본 타입은 언제나 유효하지만 박싱된 기본 타입은 객체기 때문에 null을 가질 수 있다.

박싱된 타입은 '==' 연산을 할 때 문제를 일으킬 수 있다. 고유 식별성 속성이 같은지를 검사해버리기 때문이다.

naturalOrder.compare(new Integer(42), new Integer(42)); 의 값은 1을 출력한다. (같으면 0)

연산 같은 곳에 잘못하면 오토 언박싱/박싱이 일어나면서 오버헤드가 엄청나게 발생할 수도 있다.



6. 다른 타입이 더 적절하다면 문자열 타입을 피하자

- 문자열이 여러 메서드도 제공해주고 사용하기 편리하다고 느껴 자주 사용되지만 더 적합한 타입이 있으면 boolean, enum, float등을 쓰는게 더 좋다.



7. 문자열 연결은 느리니 주의해서 사용하라

- 문자열은 불변클래스라 두 문자열을 연결할 때 복사본을 만들어서 연결하고 새 문자열을 만든다.

성능이 떨어질 수 밖에 없다. 다른 포스트에서 언급했듯이 stringbuilder, stringbuffer를 사용하도록 한다.



8. 객체는 인터페이스를 사용해 참조하라

- 예를들면 Map<String, Object> map = new HashMap<>(); 이런식으로 앞에 선언에서 인터페이스를 사용해 참조하라는 얘기다.

이렇게 하면 HashMap서 다른 더 효율적인 Map을 사용하려고 할 때 변경에서 자유롭다.



9. 리플렉션보다는 인터페이스를 사용하라

- 리플렉션은 컴파일타임에 타입검사를 할 수 없기때문에 없는 메서드를 호출하려한다든지 하면 에러가 발생할 수 있는 단점이 있다.

또한 리플렉션을 이용하면 코드가 지저분해지고 성능이 떨어진다.

상식적으로 생각해도 그냥 메서드를 호출하는 것보다 클래스를 찾아서 메서드 리스트를 받아서 찾아서 호출하는 식이 느리다.

리플렉션은 딱 인스턴스 생성에만 쓰고, 그렇게 생성된 인스턴스는 인터페이스나 상위클래스로 참조해 사용하면 좋다.

막상 예제를 테스트해보니 잘 안된다.

느낌만 이해하고 그것을 설명하면, 리플렉션으로 런타임중에 사용되는 어떤 클래스를 Class.forName("java.lang.String"); 
처럼 클래스 이름으로 찾고, Class 객체의 getDeclaredConstructor()로 생성자를 찾아 .newInstance()로 인스턴스까지 생성을 한 후,
그 인스턴스를 가리킬 수있는 super 클래스 혹은 인터페이스로 참조하고 해당 기능을 직접사용하는 것이다.



10. 네이티브 메서드는 신중히 사용하라(아니 사용하지 말라)

- 네이티브 메서드는 잘 사용하기 아주 어렵다. 사용하지 말자.

GC가 자동으로 메모리 수거도 못하고 자바코드랑 네이티브메서드랑 접착 코드를 작성해야하는데 엄청 어렵고 자바의 
장점인 플랫폼을 타지 않는다는 것이 사라지고 이식성이 떨어지는 단점들이 존재하니 일반적인 개발자는 사용하지 말자.



11. 최적화는 신중히 하라

- 최적화, 성능, 효율성을 강조하기 위해 설계를 바꾸지 말자

병목현상이 일어나는 부분은 분명히 해결해야할 숙제고 이런것들을 하지 말라는 게 아니다.

여기서 하지말라는 것은 성능때문에 기존의 좋은 프로그램 설계를 깨는 것이 오히려 위험하고, 성능이 좋지 않을 수 있다는 것이다.

또한 각각의 성능 최적화 시도를 했으면 전후로 성능을 측정해서 확실히 하는 버릇을 들이라는 내용이다.



12. 일반적으로 통용되는 명명규칙을 따르라

- 개발하면서 이게 제일 어려운것 같다.

1) min, max처럼 통용되는 약어는 약어로 쓰되 단어를 임의의로 줄이지 않는다.

2) 클래스나 인터페이스 첫 글자는 대문자로 쓴다. ex) String

3) 메서드와 필드는 첫 글자를 소문자로 쓴다. ex) getName()

4) 상수는 전체 대문자와 띄어쓰기는 언더바로 한다. ex) NEGATIVE_INFINITY

5) 타입매개변수는 한 문자로 표현하고 임의의 타입은 T, 컬렉션의 원소는 E, Map의 키와 값은 K, V, 예외는 X, 메서드의 리턴 타입은 R을 사용한다.

6) 멤버 속성을 반환하는 메서드는 get으로 시작하는 동사구로 짓는다. ex) getSize()

7) boolean 값을 반환하면 has나 is로 시작하는 메서드를 짓는다.

9) 다른 타입으로 변환할 때는 toArray등의 형태로 짓는다. ex) toJson()

10) 의미가 잘 드러날 수 있는 단어를 조합해 사용한다.

참고로 여기 변수명을 지어주는 사이트가 있다. 아주 유용하다.()
```
