# [오라클 구조](https://jeong-pro.tistory.com/147?category=816292)
* 내부적을 메모리 영역(System Global Area)이랑 데이터베이스 영역이 있다.

# SGA 구조
* SGA > Shared Pool > Library Cache

# Library Cache
* 우리가 날리는 SQL이랑 최적화된 실행 계획이 Library Cache 영역에 저장이 되어있다.
* 오라클이 Library Cache에 정보를 저장할 때 SQL을 Hash 함수를 써서 저장을 하게 된다
  * SQL 문장 그 자체가 키값이 된다; 그래서 같은 SQL이라도 공백, 줄바꿈이 들어갔거나 대소문자가 다르거나 하면 다른 SQL로 간주해서 Cache를 탈 수 없다
  
# 오라클 내부 과정
1. SQL을 날린다.
2. 오라클이 내부적으로 SQL 파싱을 먼저 한다 
    * Syntax 에러 체크
    * Semantic(권한, 존재 여부) 체크
    * Library Cache 영역에서 저장되어 있는 정보가 있는지 확인
            * 예전에 같은 SQL을 실행한 적 있고 거기에 최적화된 실행 계획이 Library Cache에 저장이 되어 있다면 Cache 영역에서 바로 꺼내서 실행하고 끝낸다
            * 만약 저장되어있는 정보가 없다면 옵티마이저가 수많은 실행계획들을 도출해 낸 다음에 어떤 실행계획이 가장 비용이 적게 드는지 최적화를 거치게 된다. 최적화 이후 SQL 엔진이 해석할 수 있는 언어로 변환을 하는 Row-source generation 과정을 거친다음에이 실행이 되게 된다.

# Hard Parsing
* 옵티마이저에 의해서 최적화하고 Raw-source generation까지 하고 그 다음 실행되는게 Hard Parsing

# Soft Parsing
* Library Cache에서 바로 꺼내서 쓰는 것 
* 동적인 커리에서 Soft Parsing을 사용하려면 바인드 변수를 사용하면 된다
  * 바인드 변수를 제외한 나머지 쿼리를 파싱한 다음에 마지막에 방니드 변수 적용하는 방식

# PGA
* SMJ의 Sort Area나 Hash 영역은 PGA에 위치한다, 그래서 처리 속도가 매우 빠르다
```java
데이터베이스에 접속하기 위해서는 많은 프로그램을 사용하게 된다. 데이터베이스에 접속하기 위해 해당 프로그램을 실행하게 되면 

내부적으로 유저 프로세스가 생성되며 해당 유저 프로세스는 데이터베이스에 접속하는 순간 모든 정보를 서버 프로세스에게 전달하게 된다.

해당 유저 프로세스에서 특정 SQL을 수행했다고 하면 유저 프로세스는 해당 SQL과 기타 정보를 서버 프로세스에게 전달해 주고 답변을 

대기하는 역할을 하게 된다. 유저 프로세스로부터 요청받은 내용을 수행하기 위해서 서버 프로세스가 필요한 모든 작업을  수행하게 된다. 

이때 요청받은 내용 및 기타 정보를 저장하기 위해 서버 프로세스는 자신만의 메모리 공간인 PGA를 이용하게 된다. 결국 PGA란 다음과 같이 정의할 수 있다.


* PGA - 데이터베이스에 접속하는 모든 유저에게 할당되는 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역 



    

[그림 3.3]은 PGA의 구체적인 구조이다.



Sort Area(정렬 공간) - Order By 또는 Group By 등의 정렬을 수행하기 위한 공간이며 해당 공간에서만 정렬이 완료된다면 이를 

메모리 정렬이라 한다. 해당 정렬 메모리 공간이 부족하다면 디스크를 이용하게 된다.

Session Information(세션 정보) - 서버 프로세스에 의해 추출된 결과 값을 전달하기 위해 필요한 유저 프로세스의 세션 정보를 저장한다.

Cursor State(커서 상태 정보) - 해당 SQL의 Parsing(파싱) 정보가 저장되어 있는 주소를 저장한다.

Stack Space(변수 저장 공간) - SQL 문장에 Bind Variable(바인드 변수)를 사용했을경우 해당 Bind Variable를 저장하는 공간이다.





이와 같이 PGA는 유저 프로세스가 요청한 작업을 수행하기 위해서 필요한 영역으로 구성된다. [그림 3.4]와 같이 하나의 유저 프로세스에 

하나의 서버 프로세스가 할당되며, 또한 하나의 서버 프로세스는 하나의 PGA를 생성하게 된다.



PGA(Program Global Area)의 관리

오라클에서는 다음과 같은 파라메터에 의해 PGA 크기를 관리할 수 있다.

WORKAREA_SIZE_POLICY - MANUAL과 AUTO로 설정할 수 있으며 AUTO로 설정했을 경우에는 PGA_AGGREGATE_TARGET 파라메터를 이용하여 

PGA의 크기를 설정하겠다는 뜻이다. MANUAL로 설정할 경우는 SORT_AREA_SIZE 파라메터를 이용하여 정렬 공간을 설정하게 된다. 오라클 

10g부터는 기본 값이 AUTO로 설정된다.

SORT_AREA_SIZE - 정렬 공간에 대한 크기를  설정하는 파라메터이다.

PGA_AGGREGATE_TARGET - 모든 세션의 PGA 크기의 합을 설정하는 파라메터이며, PGA_AGGREGATE_TARGET 파라메터에서 지정한 크기까지 

오라클이 PGA를 자동으로 관리한다.

이전 오라클 버전에서는 SORT_AREA_SIZE를 설정하여 세션별로 정해진 크기의 PGA를 할당하여 작업을 수행하였다. 그러나 오라클 9i 및 

오라클 10g에서는 세션별로 정해진 PGA 크기가 아닌 PGA_AGGREGATE_TARGET 파라메터에 정해진 크기 범위에서 세션별로 자동으로 할당하여

메모리를 사용할 수 있게 되었다.


정렬 작업의 양이 많아 더 큰 PGA를 요구한다며 PGA_AGGREGATE_TARGET 파라메터에 정해진 크기 내에서 원하는 만큼 할당 가능


예를 들어, 데이터베이스에 하나의 유저만 접속해 있으며 SORT_AREA_SIZE가 5MB로 설정되어 있다고 가정하자. 해당 유저가 40MB의 

데이터 정렬이 필요한 작업을 실행하였을 경우 5MB가 초과하면 임시 테이블스페이스에 정렬할 데이터를 저장하게 되어 8번의 디스크

I/0가 발생하게 된다. 그러나 WORKAREA_SIZE_POLICY 파라메터를 AUTO로 설정하고 PGA_AGGREGATE_TARGET 파라메터를 50MB로 

지정한 경우에는 전체 PGA 크기의 합이 50MB 이하가 될 때까지는 PGA를 확장할 수 있으므로 디스크 I/O 없이 정렬 작업을 완료할 

수 있게 된다. 이를 자동 PGA 조정이라 한다.


자동 PGA 조정 파라메터를 사용할 경우 주의해야 할 점은 다음과 같다.



PGA_AGGREGATE_TARGET 파라메터의 값을 충분히 크게 설정


만약 앞의 예에서 첫 번째 프로세스가 50MB의 PGA 공간을 사용하고 있다고 가정하자. 이 경우에 다른 유저가 접속해 두 번째 

서버 프로세스를 생성하려 한다면 이 세션은 PGA로 사용할 메모리를 할당받지 못하므로 에러가 발생하며 접속할 수 없게 된다. 

그러므로 자동 PGA 조정 기능을 사용할 경우에는 유저가 접속하지 못하는 경우를 방지하기 위해 평소 접속하는 세션 수와 각 

세션이 사용하는 PGA의 크기를 정확히 파악하여 PGA_AGGREGATE_TARGET 파라메터를 설정해야 한다.

평소 사용되는 PGA의 크기는 V$PROCESS 데이터 딕셔너리 뷰에서 다음을 조회하여 확인할 수 있다.


PGA_USED_MEM - 프로세스가 현재 사용하는 PGA의 크기

PGA_ALLOC_MEM - 프로세스에 할당된 PGA의 크기(사용 완료 후 시스템 메모리에 반환하지 않는 메모리 포함)

PGA_MAX_MEM - 프로세스가 사용한 최대 PGA의 크기


```

# SGA
```java

SGA의 개념

오라클 메모리 구조 중 가장 중요한 SGA의 개념을 그림을 통해 확인해 보자.



[그림 3.5]를 통해 오라클이 사용하는 메모리 공간인 SGA(System Global Area)에 대해 확인해 보자.


오라클은 필요한 데이터를 디스크에서 읽어 메모리에 저장한 후 메모리에 저장된 데이터를 읽거나 변경을 수행한다. 이러한 일련의 

작업에서 사용되는 공용 메모리 영역을 SGA(System Global Area)라고 하며 그 구조는 [그림 3.5]와 같다.

Shared Pool(공유 풀)

Data Buffer Cache(데이터 버퍼 캐쉬)

Redo Log Buffer(리두 로그 버퍼)

Large Pool(대형 풀)

위와 같이 SGA(System Global Area)는 Shared Pool(공유 풀), Data Buffer Cache(데이터 버퍼 캐쉬), Redo Log Buffer(리두 로그 버퍼),

Large Pool(대형 풀) 및 Java Pool(자바 풀)로 구분 할 수 있다.

SGA는 공용 메모리 영역이므로 동일 데이터베이스에 접속하는 모든 사용자는 동일 SGA를 사용하게 된다. 예를 들어, ORCL 

데이터베이스에 접속하는 유저1, 유저2 및 유저n은 [그림 3.6]과 같이 동일 SGA를 사용하게 된다.



결국 SGA는 다음과 같이 정의할 수 있을 것이다.


SGA - 오라클이 데이터를 읽거나 변경하기 위해 사용하는 공용 메모리 영역


SGA는 인스턴스가 시작될 때 시스템 메모리에서 할당받으며 종료될 때 다시 시스템 메모리 영역으로 반환된다.



SGA의 관리

SGA를 관리하기 위해 필요한 변경과 확인 절차를 알아보자.

 
     SGA 변경

     SQL> ALTER SYSTEM SET parameter_name = 변경 값;



SGA 확인

SQL> SHOW SGA

SQL> SELECT * FROM V$SGA;

SQL> SELECT * FROM V$SGASTAT;

SQL> SELECT * FROM V$SGA_DYNAMIC-COMPONENTS;


위와 같이 SGA 관리는 변경 및 확인으로 구성된다.

첫 번째로 SGA 변경을 확인해 보자.

SGA의 설정 값을 변경하고자 할 경우 전체 SGA를 합한 것이 SGA_MAX_SIZE 파라메터에서 정한 값 이하까지 ALTER SYSTEM SET 

명령을 이용하여 동적으로 할당받을 수 있다. 예를 들어 확인해 보자.

SGA_MAX_SIZE - 64MB
DATA BUFFER CACHE - 24MB
SHARED POOL - 24MB
이와 같은 경우에 다음과 같은 명령으로 SGA의 크기를 변경할 수 있다.


예제)

    SQL> ALTER SYSTEM SET DB_cache_size = 20M;
    SQL> ALTER SYSTEM SET shared_pool_size - 28M;


예제에서는 데이터 버퍼 캐쉬에서 축소한 4M 만큼을 공유 풀에 할당하였다. 만약 이 경우에 공유 풀을 64MB로 변경하려 한다면 SGA의 

전체 합이 SGA_MAX_SIZE 파라메터의 값을 초과하므로 'ORA-00384 Insufficient memory to grow cache' 에러가 발생한다. 위와 같이 

SGA 구조를 변경하는 작업은 사용하는 파라메터 파일의 종류에 따라 차이점이 존재한다.

정적 파라메터 파일 - 데이터베이스가 재시작하게 되면 파라메터 파일(PFILE, initSID.ora)에 설정된 값을 재적용하게 된다. 따라서 

변경된 값을 유지하기 위해서는 파라메터파일(initSID.ora)에 해당 변경 내용을 수정해야 한다.

동적 파라메터 파일 - 동적 환경 파일(SPFILE, spfileSID.ora)을 사용하는 경우 ALTER SYSTEM SET 명령어 뒤에 scope=BOTH 옵션을 

추가하게 되면 변경된 값이 메모리와 동적 파라메터 파일에 동시에 적용되므로 데이터베이스 재시작 후에도 변경된 값이 적용된다. 


SGA와 Granule(그래뉼)

SGA는 Granule(그래뉼) 단위에 따라 증가된다. Granule은 SGA_MAX_SIZE 파라메터가 128MB를 넘지 않을 경우 4MB로 설정된다. 

그 이상일 경우에는 16MB로 그래뉼이 설정된다. 예를 들어, SGA_MAX_SIZE 파라메터가 120MB인 경우 DATA BUFFER CACHE의 크기를 
증가시키기 위해 DATA BUFFER CACHE 크기를 32MB에서 34MB로 변경하여도 DATA BUFFER CACHE는 36MB로 변경된다. 그 이유는 Granule
단위가 4MB이므로 4MB의 
배수인 36MB로 설정되는 것이다.



두 번째로 SGA를 확인하는 방법

설정된 SGA의 크기 확인은 다음과 같은 데이터 딕셔너리 뷰 조회 또는 SQLPLUS 명령어로 확인할 수 있다.

V$SGA
V$PARAMETER
V$SPPARAMETER
V$SGA_DYNAMIC_COMPONENTS
show parapmeter 명령어
SQLPLUS에 접속하여 show sga라는 명령을 수행한 경우 다음과 같은 결과 값을 확인할 수 있으며 V$SGA를 검색했을 

경우에도 동일한 결과를 추출할 수 있다. 

예제)

      SQL> show sga

Total System Global Area    127889704 bytes
Fixed Size                        737576 bytes
Variable Size                    92274688 bytes
Database Buffers               33554432 bytes
Redo Buffers                    1323008 bytes


앞의 예제에서 SHARED POOL의 일부, LARGE POOL 및 JAVA POOL은 Variable Size로 통합되어 보여진다. 

V$SPPARRAMETER 또는 V$PARAMETER를 검색하면 SGA의 구성요소에 설정된 정확한 값을 확인할 수 있다. 

V$SGA_DYNAMIC_COMPONENTS 동적 성능 뷰에 대한 설명은 공유 메모리 자동 관리에서 언급하기로 하겠다.



출처: https://1duffy.tistory.com/18 [밀림속의 동물원]
```

```java
데이터베이스 아키텍쳐(Database Architecture)


<출처> http://www.dbguide.net/dbqna/oracle.db?cmd=view3

데이터 베이스 아키텍쳐 = 프로세스 + 공유메모리 영역 + 디스크(물리적 파일)영역

Oracle이나 MSSQL 같은 DBMS의 구조를 살펴보면 위와 같이 구성되어 있다. (위 사진은 오라클 구조)



프로세스(Process)

* oracle이 리눅스(linux)에서는 프로세스 단위로 생성되고 운영된다. SQL server(mssql)는 쓰레드 기반 아키텍처고 oracle이 
윈도우에서는 해당 프로세스를 쓰레드로 대체한다. 어차피 같은 역할을 수행하므로 프로세스로 통칭한다.

프로세스는 크게 서버 프로세스(Server process)와 백그라운드 프로세스(Background process)로 나뉜다.



- 서버 프로세스

서버 프로세스는 사용자 프로세스(클라이언트)와 통신하면서 사용자의 각종 명령어를 처리하는 프로세스다.

자세히 설명하면, SQL을 파싱하고 필요하면 최적화를 수행하며, SQL을 실행하면서 블록을 읽고, 읽은 데이터를 정렬해서 클라이언트가 
요청한 결과를 만들어 네트워크에 전송하는 일련의 작업을 처리하고, 백그라운드 프로세스가 할일을 백그라운드 프로세스에게 위임시키기 위한 시스템 
콜 요청을 하는 프로세스다.



-- 서버프로세스와 클라이언트를 연결하는 방식에는 아래 2가지가 있다.


<출처> http://ndatabase.blogspot.kr/2013/07/oracle-vs.html



1) 전용 서버(Dedicated Server) 방식

요청이 올때 마다 서버프로세스를 새로 생성해서 연결하고 요청/응답하고 제거하는 방식 (그림에서 아래 있는 방법)

 - 과정

1. Listener가 데이터베이스 연결 요청을 받음

2. Listener가 서버 프로세스 생성 및 연결 요청

3. 서버 프로세스가 resend 패킷을 클라이언트에게 전송

4. 클라이언트에서 오는 요청에 대한 응답

* SQL을 수행할 때마다 연결 요청을 반복하면 서버 프로세스의 생성과 해제도 반복하게 되므로 DBMS에 큰 부담이 된다. 
따라서 전용 서버 방식을 사용하는 OLTP성 애플리케이션에서는 Connection Pooling 기법을 사용해야 한다.



2) 공유 서버(Shared Server) 방식

하나의 서버 프로세스를 여러 사용자 세션이 공유하는 방식, 미리 여러 개의 프로세스를 띄워놓고 이를 공유해서 재사용한다. 
(그림에서 위에 있는 방법)

1. Listener가 데이터베이스 연결 요청을 받음

2. Listener가 가용한 Dispatcher 포트번호를 클라이언트에게 전송

3. Dispatcher로 온 요청을 요청큐(Request queue)에 넣음

4. 공유서버가 요청큐에서 요청을 가져와서 해결한 후 응답을 응답큐(Response queue)에 넣음

5. Dispatcher가 응답큐로 부터 결과를 가져옴

6. 결과를 클라이언트에 리턴



- 백그라운드 프로세스

서버 프로세스가 하는일 외에 데이터 파일을 읽어서 DB 버퍼 캐시에 적재하는 일, Dirty 블록(파일에 기록된 데이터와 메모리에 기록된 데이터가
다른 데이터가 존재하는 블록)을 캐시에서 제거해 free 블록을 확보하는 일, Redo 로그 버퍼를 비우는 일등 내부적으로 DB시스템이 잘 돌아가게 해주는

역할하는 하는 프로세스다.

* 백그라운드 프로세스 요약

 Oracle

 SQL Server

설명 

System Monitor(SMON)

Database clean up/ shrinking thread 

 장애가 발생한 시스템을 재기동할 때 복구 수행, 임시 세그먼트와 익스텐트 모니터링하는 프로세스 (* 세그먼트, 익스텐트는 아래 설명)

 Process Monitor(PMON)

Open Data Services(OPS) 

 이상이 생긴 프로세스가 사용하던 리소스 복구하기 위한 프로세스

 Database Writer(DBWR)

Lazywriter thread 

 버퍼 캐시에 있는 Dirty 버퍼(블록)를 데이터 파일에 기록하는 프로세스

 Log Writer(LGWR)

Log writer thread 

 로그 버퍼 엔트리를 Redo 로그 파일에 기록하는 프로세스

 Archiver(ARCn)

. 

 꽉찬 Redo 로그가 덮어 쓰여지기 전 Archive 로그 디렉토리에 반영

 Checkpoint(CKPT)

Database Checkpoint thread 

 Write ahead logging 방식(데이터 변경전 로그부터 쓰는 메커니즘)을 사용하는 DBMS는 Redo 로그에 기록해 둔 버퍼 블록에 대한 변경 사항 
 
 중 현재 어디까지 데이터 파일에 기록했는지(데이터 동기화)를 checkpoint로 관리하는데, 이 마지막 checkpoint 이후 로그 데이터만 디스크에 
 
 기록함으로써 인스턴스를 복구할 수 있게하는 용도로 사용되는 프로세스

 Recverer(RECO)

Distributed Transaction Coordinator(DTC) 

 분산 트랜잭션 과정에 발생한 문제를 해결하는 프로세스

SMON, PMON, DBWR(DBWs), LGWR, CKPT 는 5개 필수 백그라운드 프로세스다. 



디스크(물리적) 영역 - 파일 구조

디스크 영역은 크게 데이터파일 + 임시 데이터파일 + 로그 파일로 구성된다.

- 데이터 파일



위 그림은 데이터베이스 파일 구조를 논리적 영역과 물리적 영역으로 나눠서 요약한 것이다.

물리적으로 디스크에는 데이터베이스가 여러 데이터 파일(Data File)들로 구성되어있다.

각각 데이터파일은 여러 개의 Block(단위)으로 구성되어있다.

tablespace (땅) - segment (건물) - extent (건물의 어느 한 층) - block (건물 어느 한 층의 사무실)



1. 블록(block)


<블록 구조>

블록에는 다양한 데이터들이 있고 블록 헤더에는 블록을 관리하기 위한 데이터가 들어있다.

하나의 블록은 2KB, 4KB, 8KB, 16KB, 32KB, 64KB의 다양한 크기를 사용할 수 있다. (SQL server는 8KB만)

하나의 블록안에는 여러 레코드(데이터)들이 들어 있다.

데이터베이스에서는 I/O를 블록단위로 한다.

그렇기 때문에 원하는 레코드가 하나여도 블록 째로 읽어들이기 때문에 성능을 좌우하는것은 읽어올 블록의 개수를 최소로 하는 것이다.

이런 특징을 갖는 블록들을 논리적으로 블록이라는 것으로 똑같이 만들었다.



2. 익스텐트(Extent)

익스텐트는 여러 개의 연속된 블록 집합이다. (블록의 묶음)

I/O의 단위는 블록이지만 테이블 스페이스로부터 공간을 할당하는 단위는 익스텐트다.



3. 세그먼트(Segment)

세그먼트는 여러 개의 익스텐트를 가지고 있는 오브젝트다.

세그먼트는 데이터베이스의 테이블, 인덱스, Undo 처럼 저장공간이 필요로 하는 오브젝트를 말한다.



4. 테이블 스페이스(Tablespace)

테이블 스페이스는 세그먼트를 담는 콘테이너로 여러 데이터 파일로 구성된다.

보통 MySQL같은 DBMS에서 워크벤치를 사용했을 때보면 테이블스페이스 안에다가 테이블을 만드는 것을 알 수 있다.

여러 테이블이 있는 공간을 나타낸다.



위와 같은 구조로 데이터파일들이 생성되고 관리된다.



- 임시 데이터 파일 

임시 데이터 파일은 대량의 정렬이나 해시 작업을 수행하다가 메모리 공간이 부족해지면 중간에 결과 집합을 잠시 저장하는 용도로 사용되는

파일이다. (잠시 저장되었다가 삭제됨)



- 로그 파일

 -- online Redo 로그

캐시에 저장된 변경사항이 아직 데이터파일로 기록되지 않은 상태에서 장애가 생겨서 데이터파일로 기록하지 못한게 날아간 경우에 이것을

복구하기 위해서 online Redo 로그를 사용한다.

online Redo로그는 최소 2개 이상의 파일로 구성되고 하나의 파일이 꽉차면 다음 파일로 로그를 스위칭하고 계속 로그를 쓰다가 모든 파일이 

꽉차면 다시 첫번 째 파일부터 재사용하는 형식으로 사용한다.



-- Archived Redo 로그

Online Redo 로그가 재사용되기전에 다른 위치로 백업해 둔 파일이다.



- 컨트롤 파일

데이터베이스를 시작할 때 항상 참조되는 파일.

데이터베이스에서 사용할 모든 파일들의 절대경로와 파일크기등의 정보를 저장하고 있고 파일들의 이상유무를 확인하기 위해서 참조된다.



- 파라미터 파일

공유메모리 영역을 얼마만큼 할당 받을지, 컨트롤 파일의 경로와 데이터베이스의 환경설정 등 관련 모든 정보를 포함하고 있다.



공유메모리 영역 - 메모리 구조

메모리영역은 크게 시스템 공유 메모리 영역 + 프로세스 전용 메모리 영역으로 나뉜다.

1. 공유 메모리 영역은 운영체제가 제공해준 것으로 여러 프로세스가 동시에 엑세스할 수 있는 메모리 영역이다

SGA(System Global Area)라고 부르며 DB버퍼캐시, 공유 풀, 로그버퍼, Large풀, 자바풀등이 여기에 속해 있다.



2. 프로세스 메모리 영역은 서버프로세스가 가진 자신만의 메모리 영역으로 PGA(Process Global Area)라고 부르며, 데이터를 정렬하고 

세션과 커서에 대한 상태 정보를 저장하는 용도로 쓰인다.



공유 메모리 영역의 프로세스들

1) DB 버퍼 캐시

디스크 파일의 데이터 파일로 부터 읽은 데이터 블록을 담는 캐시 영역이다.

모든 읽기는 DB 버퍼 캐시를 통해 이루어지고 읽고자하는 데이터가 DB 버퍼캐시에 없으면 디스크에서 읽는다.

디스크에서 읽을 때도 버퍼 캐시에 적재한 후 버퍼 캐시에서 읽어온다.

데이터 변경이 되어서 Dirty블록이 생기면 주기적으로 DBWR 프로세스가 디스크에 기록을 한다.



* 버퍼 블록의 상태

Free 블록 : 비어있는 상태거나 데이터가 담겼지만 파일과 동기화되어 일치하는 상태로 덮어써도 상관없는 상태인 것을 말한다.

dirty 블록 : 버퍼에 캐시된 이후 변경이 발생했지만 아직 파일에 쓰지 않아(동기화 안됨) 덮어 쓸 수 없는 상태인 것을 말한다.

pinned 블록 : 읽기 또는 쓰기 작업이 진행 중인 상태를 말한다.



2) 공유 풀(Shared Pool)

 공유 풀은 딕셔너리 캐시와 라이브러리 캐시로 구성된다. LRU알고리즘사용

-- 딕셔너리 캐시

테이블, 인덱스 같은 오브젝트 + 테이블 스페이스, 데이터 파일, 세그먼트, 익스텐트, 사용자, 제약에 관한 메타 데이터를 저장하는 곳이다. 

(테이블 메타데이터 정보같은 것들)

-- 라이브러리 캐시

사용자가 수행한 SQL문과 실행계획, 저장 프로시저를 저장해두는 캐시다.

사용자가 SQL 명령어를 통해 결과를 요청하면 이를 최적으로 수행하기 위한 루틴을 생성해야하는데 이것이 실행계획(Execution plan)이라고 한다.

쿼리 구문을 분석해서 Syntax check(문법 맞는지), semantic check(테이블 존재등 의미가 맞는지), 권한 검사(권한 있는지)를 하고 최적화 

과정을 거쳐 실행계획을 생성하고 SQL실행 엔진이 이해할 수 있는 형태로 포맷팅하는 전과정을 하드 파싱이라고 한다.

최적화 과정이 가장 성능에 주요한 영향을 미치는데 이런 최적화 과정을 없애기 위해 전에 사용한 SQL문과 실행계획을 저장해두고 바로 사용할 

수 있게 하기 위해서 라이브러리 캐시라는 곳에 저장해둔다.



3) 로그 버퍼

DB버퍼 캐시에 가해지는 모든 변경사항을 로그 파일에 기록한다.

로그를 건마다 기록하는 것보다 모아서 기록하는 것이 성능에 유리하기 때문에 두는 버퍼다.

버퍼 캐시 블록을 갱신하기 전에 변경사항을 먼저 로그버퍼에 기록해야 하며, dirty 블록을 디스크에 기록하기 전에 해당 로그 엔트리를 먼저 로그 파일에 기록해야한다. (Write Ahead Logging)



PGA (공유되지 않는 독립 메모리 공간)

- UGA(User Global Area)

PGA에 할당되는 메모리 공간으로 하나의 프로세스가 여러 개의 세션을 위한 독립적인 메모리 공간이 필요해지는데 이때 쓰는 것이 UGA다.

- CGA(Call Global Area)

PGA에 할당되는 메모리 공간으로 하나의 데이터베이스 Call을 넘어 다음 Call까지 계속 참조되어야 하는 정보는 UGA에 담고 Call이

진행되는 동안에만 필요한 데이터를 CGA에 담는다.

CGA는 parse call(분석), execute call(실행), fetch call(가져오기) 마다 매번 할당 받는다.

- Sort Area

데이터 정렬을 위해 사용되는 공간



끝으로 다시 위 그림을 보면서 복습하면 좋을 것 같다.



출처: https://jeong-pro.tistory.com/147?category=816292 [기본기를 쌓는 정아마추어 코딩블로그]
```
