# [정아마추어](https://jeong-pro.tistory.com/114?category=793347)
# [테코톡 인덱스](https://www.youtube.com/watch?v=9ZXIoh9PtwY&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=2)

# Index
```java
Index 자료구조
그렇다면 DBMS 는 인덱스를 어떻게 관리하고 있는가

B+-Tree 인덱스 알고리즘
일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 
변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.

Hash 인덱스 알고리즘
칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 
인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 
해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

왜 index 를 생성하는데 b-tree 를 사용하는가?
데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>)
연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.
동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.


Primary Index vs Secondary Index
클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 
인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는
경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.

클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 
묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장
위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 
프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.

클러스터드 인덱스는 테이블 당 한 개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다, 이에 반해 non
클러스터드 인덱스는 테이블 당 여러 개를 생성할 수 있다.


Composite Index
인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우,
index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다. 
따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.


Index 의 성능과 고려해야할 사항
SELECT 쿼리의 성능을 월등히 향상시키는 INDEX 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에
INDEX 를 생성해두면 빨라지지 않을까? 결론부터 말하자면 그렇지 않다. 우선, 첫번째 이유는 INDEX 를 생성하게 되면 
INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT 의 경우 INDEX 에 대한 데이터도 
추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로
남게 된다. 즉 row 의 수는 그대로인 것이다. 이 작업이 반복되면 어떻게 될까?

실제 데이터는 10 만건인데 데이터가 100 만건 있는 결과를 낳을 수도 있는 것이다. 이렇게 되면 인덱스는 더 이상 제 역할을
못하게 되는 것이다. UPDATE 의 경우는 INSERT 의 경우, DELETE 의 경우의 문제점을 동시에 수반한다. 이전 데이터가 
삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 insert 로 인한 split 도 발생하게 된다.

하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다.
즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적은 데이터의 형식이 존재한다는 것이다. 어떤 경우에 그럴까?

이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는
INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다. 
이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다.

왜 성별이나 나이는 인덱스를 생성하면 비효율적일까? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에
인덱스를 생성했다고 가정하자. 값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 
그 만큼 비효율적인 것이다.
```

# index
* 테이블과 매핑된 또 다른 테이블이 하나 생성된다고 생각하면 된다.
	* 인덱스는 인덱스 컬럼 기준으로 소팅되어있끼 때문에 물리적으로 흩어져있어 테이블을 풀스캔해야 되는 것 과는 달리 더 빨리 데이터를 찾을 수 있다.
	* 인덱스에서 먼저 데이터를  찾고 그 테이블로 매핑된 곳을 가서 나머지 데이터들을 꺼내오는 방식(인덱스가 해당 테이블의 블럭에 주소글 가지고 있다라고 생각하면 됨)
* 성별 같은 컬럼 보다 ID 같이 분별력이 높은 컬럼이 앞으로 오는 것이 좋다.
* 종류: B 트리 인덱스, Clusterd Index, 비트맵 인덱스, IOT
* 단일 컬럼도 되지만 여러 컬럼을 조합하여 결합 인덱스로 구성 가능

## 블럭
* 블럭: 데이터가 저장되는 최소 단위; 테이블의 데이터들이 로우 단위로 저장되어 있음
* 테이블의 컬럼수가 많다면 하나의 블럭에 저장되는 로우수가 적어지겠고, 컬럼 수가 적다면 하나의 블럭에 저장되는 로우수가 많아진다.

## 인덱스 선별 기준
1.  where전에 자주 등장하는 컬럼
2. order by절에 자주 등장하는 컬럼

## Index 개념, 쓰는 이유와 장단점
- 테이블의 읽기속도를 높이기 위해 사용되는 자료구조로서 테이블의 컬럼 인덱스를 설정하여 검색시 full scan이 아닌 index 파일 검색으로 검색속도를 빠르게 합니다.
* 인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 목차를 생성하는 것
* insert,update,delete의 성능을 떨어뜨리고, select의 성능을 향상 시킨다.
* 이때, insert,update,delete의 성능이 떨어지는 것이지, insert,update,delete하기 위해 데이터를 조회하는 것은 인덱싱에 의해서 빠르게 조회가 된다.
* 인덱스가 없는 컬럼을 조건으로 UPDATE,DELETE하게 되면 굉장히 느려지므로, 많은 양의 데이터를 삭제 해야하는 상황에서는 인덱스로 지정된 컬럼을 기준으로 삭제하길 권고
B* +트리, 해시등의 알고리즘을 사용한다.

```JAVA
데이터베이스 인덱스(Database Index)

데이터베이스의 인덱스, 개발을 하면서 상당히 많이 들었다.

RDBMS에서 대용량의 데이터(레코드)가 있을 때, 특정 데이터를 검색하기 위해서 테이블의 레코드를 
full scan하는 것이 아니라, 인덱스가 적용된 컬럼의 테이블(컬럼, 인덱스주소)을 따로 파일로 저장해놓고 
그것을 검색해서 검색 효율을 높이는 방법이다.


SELECT /*+INDEX(EMP EMPNO_INDEX) */
EMPNO, ENAME
FROM EMP
WHERE DEPTNO=10


 /*+HINT~~~~ */   이런식으로 사용하는 것까지는 누구나 안다. (HINT의 종류는 검색해보면 많음)

그러나 '왜 이렇게 일어나지?', '어떻게 동작하지?' 이런 고민을 해보지 않고 + 직접 '체득'하지 않은 사람들이 많을 것이다. 
(필자 포함)

인덱스는 면접에서 자주 물어보는 것중에 하나다.

추측으로는 면접+실무에서 포인트는 인덱스에 대해서 정확하게 알고 있어야만 적재적소에 적용할 수 있기 
때문에 꼼꼼하게 정리하고 이해했는지를 물어보는 것 같다.

인덱스는 범위 스캔(Range Scan)을 한다

인덱스는 키 컬럼순으로 정렬되어 있기때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다. (=Range Scan)

인덱스에 가장 많이 사용되는 구조 = B-tree

인덱스를 저장하는 블럭들이 트리구조를 이루고 있다.

root block과 branch block, leaf block이 있고 B-tree는 기본적으로 leaf block의 깊이가 모두 동일하게 균형(Balanced)이 잡혀있다.

또한 각 노드에 값도 가지고 있다. (B+tree는 값은 없고 탐색을 위한 인덱스 정보만 있음)
```

## 장점
- 테이블 검색과 정렬 속도를 향상시킵니다. 또한 index를 기본키로 자동설정하여 관리가 편합니다.

## 단점
- 인덱스 파일을 별도로 만들어야함으로 파일의 크기가 늘어나고 인덱스를 처음에 생성하는데 시간이 많이 소요될 수 있습니다. 또한 인덱스된 컬럼값이 변경되거나 인덱스를 업데이트해야하기에 성능이 떨어지게 됩니다.
* select절을 제외하고 인덱스는 원래 테이블에 매핑된 테이블을 하나 더 만드는 것이기 때문에 update, insert 경우는 소팅된 이 테이블에 넣어야 하기 때문에 시간이 더 오래걸린다. 

## 결합 인덱스
* 단일 컬럼도 되지만 여러 컬럼을 조합하여 결합 인덱스로 구성 가능
* equal 조건으로 많이 스는 조건이 앞으로 오는 것이 좋다
* 분별력이 높은 컬럼이 앞으로 오는 것이 좋다. 성별 보다는 id 같은 것들

## 인덱스를 사용해야 될 때
- 위와 같은 단점에 따라 변경이 잦은 컬럼에는 인덱싱을 피하고, true/false 값을 같는 컬럼처럼 중복도가 높은 컬럼은 인덱스로 만들어도 고유성이 없기에 효용이 없습니다. where절과 join, order by 등에 자주 사용되는 컬럼의 경우 인덱스로 선정하면 검색 속도를 효과적으로 높일 수 있습니다.

### 인덱스 손익 분기점
* 테이블이 가지고 있는 전체 데이터양의 10에서 15프로 이내의 데이터가 출력이 될때만 인덱스를 타는게 효율적이다. 그 이상일 땐 풀스캔이 더 효율적이다.

## 인덱스 구조
- 검색의 효율을 높이기 위해 B-tree 또는 B+tree 구조를 사용합니다.

## 인덱스 원리
* 인덱스를 컬럼에 부여하면 초기 TABLE생성시 만들어진 myd,myi,frm 3개의 파일 중에서 myi에 해당 컬럼을 색인화 하여 저장한다.
* 사용자가 SELECT쿼리로 index가 사용하는 쿼리를 사용시 해당 table을 검색하는 것이 아니라 빠른 tree로 정리해둔 myi파일의 내용을 검색한다.
* 만약, index를 사용하지 않은 select쿼리라면 해당 table을 full scan하여 속도가 느리다.

## Unique index
* UNIQUE INDEX는 중복 값을 허용하지 않는 인덱스입니다.
* MySQL에서 UNIQUE INDEX를 생성하는 문법은 다음과 같습니다.
```java
문법
CREATE UNIQUE INDEX 인덱스이름

ON 테이블이름 (필드이름1, 필드이름2, ...)
```
* 또한, 쉼표(,)를 사용하여 여러 필드에 UNIQUE INDEX를 설정해 줄 수도 있습니다.

 


## 인덱스 스캔
1. 풀 스캔
2. index range scan(특정 부분)
3. index skip scan
4. index fast full scan

## B-Tree
- B-Tree는 검색성능을 높이기 위한 Balanced-Tree 자료구조의 종류 중 하나로서 이진트리와 다르게 하나의 노드에 여러자료가 배치되고 2개이상의 자식노드를 가질 수 있는 Tree 구조입니다. 루트를 제외한 모든 노드의 자료수는 LIMIT/2개여야하며, 자식노드의 수는 (부모노드의 자료수 + 1)개여야하는 특징이 있습니다. 이것의 이유는 B-Tree의 구조 때문에 생긴 특징입니다. 따라서 삽입, 삭제시에도 트리 균형을 유지할 수 있는 특징과, 언제나 균등한 탐색속도를 보장하는 특징이 있지만, 트리의 균형을 유지하기 위해 복잡한 연산을 해야하며, 무엇보다 중위순회방식을 사용하기에 순회탐색이 비효율적이라는 단점이 있습니

## B+Tree
- B+Tree는 B-Tree에서 순회탐색의 비효율을 보완한 구조로서, 노드의 데이터들이 연결리스트로 연결되어 있어 순차적 처리가 가능하여 순회탐색이 빠릅니다. 트리의 최하단 노드에만 데이터들이 연결리스트로 정렬되어 있으며 나머지 노드들은 키값만 가지고 있는 구조입니다.

## Balanced-Tree
- Tree 자료형의 기본적인 구조인 이진트리는 좌우 균형이 안 맞아 비효율적이라는 단점을 가지는데 이것은 해결한 자료구조가 Balanced-Tree 구조입니다. Balanced-Tree는 한쪽으로 몰린 depth를 균일하게 재배치함으로서 모든 자식 노드들의 depth를 균일하게 합니다. 따라서 어떠한 상횡에서도 검색성능을 O(logN)까지 일관된 속도를 보장하는 구조입니다.


## Replication
- 리플리케이션이란 데이터베이스를 접근하는 DB서버와 데이터를 저장하는 저장소를 구성하는 하나의 세트를 복제하여 여러 세트로 구성함으로써 위험을 분산하는 구조를 말합니다. 이러한 구조를 저장소를 공유한다 하여 shared disk라고 부릅니다. 분산처리를 통해 성능 향상을 기대할 수 있는 장점이 있는 반면, 여러 데이터가 복제되어 있는 만큼 데이터의 정합성을 유지하기 어렵습니다. 따라서 갱신 주기를 어떻게 하느냐가 중요한데 이것은 성능과 데이터의 정합성에 트레이드오프 관계가 발생하는 단점이 있습니다.

## Sharding
- 데이터의 정합성 문제와 갱신에 의한 성능 저하가 발생하는 shared disk의 문제를 해결하기 위해 고안된 아키텍쳐가 shared nothing이며 이 개념에 기반하여 구글에서 만든 구조가 sharding 입니다. sharding은 데이터를 여러 저장소에 분할 저장함으로써 동기화에 대한 이슈를 제거했기에 속도 또한 빠릅니다. 분할된 구조를 통해 병합 문제를 해결하였습니다. 하지만 특정 저장소에 정해진 데이터가 저장되어있기에 데이터를 찾으려면 특정 저장소를 찾아가야한다는 문제점이 있으며, 하나의 DB 서버가 다운이 되면 복구할 수가 없다는 문제가 있습니다. 이러한 문제는 커버링이라는 구성을 통해 하나의 DB 서버가 다운되었을 때 그것을 이어받아 처리하는 조치가 필요합니다.


# 시퀀스
- ⎼시퀀스는 값이 일정한 규칙에 의해서 연속적으로 자동 증가하거나 감소해야 하는 경우에 적용 시킬 수 있는 오라클 객체이며 테이블내의 정수값을 가지는 기본키 에 사용될 수 있다
- 중간에 인덱스가 삭제되면 삭제된 인덱스는 점프해서 생성된다.


# 조인
- 컬럼대 컬럼(기본키와 외래키); 부모
1. (1) 크로스 조인 Cross Join( ) ⎼특별한 키워드 없이 테이블을 콤마로 연결해서 사용한다. 
2. (2) 이퀴 조인 Equi Join( ) ⎼동일 컬럼을 기준으로 조인한다. ⎼조인 조건이 정확히 일치하는 경우 사용하며 일반적으로 와 를 사용한다 PK FK . 
3. (3) 논 이퀴 조인 Non-Equi Join( ) ⎼동일 컬럼이 없이 다른 조건을 사용하여 조인한다. ⎼조인 조건이 정확히 일치하지 않은 경우 사용한다 등급 학점 등 .( , ) … 
4. (4) 셀프 조인 Self Join( ) ⎼한 테이블 내에서 조인한다. ⎼하나의 테이블에서 행들을 조인하고자 할 경우에 사용한다. 
5. (5) 아우터 조인 Outer Join( ) ⎼조인 조건에 만족하지 않는 행도 나타낸다. ⎼조인 조건이 정확히 일치하지 않는 경우에도 모든 행들을 출력한다.

## 조인과 서브쿼리 차이
- 조인은 컬럼대 컬럼 대상, 서브쿼리는 값대 값; 값을 통한 조인
