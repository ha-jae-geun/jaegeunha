# [정아마추어](https://jeong-pro.tistory.com/114?category=793347)

# index
* 테이블과 매핑된 또 다른 테이블이 하나 생성된다고 생각하면 된다.
	* 인덱스는 인덱스 컬럼 기준으로 소팅되어있끼 때문에 물리적으로 흩어져있어 테이블을 풀스캔해야 되는 것 과는 달리 더 빨리 데이터를 찾을 수 있다.
	* 인덱스에서 먼저 데이터를  찾고 그 테이블로 매핑된 곳을 가서 나머지 데이터들을 꺼내오는 방식(인덱스가 해당 테이블의 블럭에 주소글 가지고 있다라고 생각하면 됨)
* 성별 같은 컬럼 보다 ID 같이 분별력이 높은 컬럼이 앞으로 오는 것이 좋다.
* 종류: B 트리 인덱스, Clusterd Index, 비트맵 인덱스, IOT
* 단일 컬럼도 되지만 여러 컬럼을 조합하여 결합 인덱스로 구성 가능

## 블럭
* 블럭: 데이터가 저장되는 최소 단위; 테이블의 데이터들이 로우 단위로 저장되어 있음
* 테이블의 컬럼수가 많다면 하나의 블럭에 저장되는 로우수가 적어지겠고, 컬럼 수가 적다면 하나의 블럭에 저장되는 로우수가 많아진다.

## 인덱스 선별 기준
1.  where전에 자주 등장하는 컬럼
2. order by절에 자주 등장하는 컬럼

## Index 개념, 쓰는 이유와 장단점
- 테이블의 읽기속도를 높이기 위해 사용되는 자료구조로서 테이블의 컬럼 인덱스를 설정하여 검색시 full scan이 아닌 index 파일 검색으로 검색속도를 빠르게 합니다.
* 인덱스는 지정한 컬럼들을 기준으로 메모리 영역에 목차를 생성하는 것
* insert,update,delete의 성능을 떨어뜨리고, select의 성능을 향상 시킨다.
* 이때, insert,update,delete의 성능이 떨어지는 것이지, insert,update,delete하기 위해 데이터를 조회하는 것은 인덱싱에 의해서 빠르게 조회가 된다.
* 인덱스가 없는 컬럼을 조건으로 UPDATE,DELETE하게 되면 굉장히 느려지므로, 많은 양의 데이터를 삭제 해야하는 상황에서는 인덱스로 지정된 컬럼을 기준으로 삭제하길 권고
B* +트리, 해시등의 알고리즘을 사용한다.

```JAVA
데이터베이스 인덱스(Database Index)

데이터베이스의 인덱스, 개발을 하면서 상당히 많이 들었다.

RDBMS에서 대용량의 데이터(레코드)가 있을 때, 특정 데이터를 검색하기 위해서 테이블의 레코드를 
full scan하는 것이 아니라, 인덱스가 적용된 컬럼의 테이블(컬럼, 인덱스주소)을 따로 파일로 저장해놓고 
그것을 검색해서 검색 효율을 높이는 방법이다.


SELECT /*+INDEX(EMP EMPNO_INDEX) */
EMPNO, ENAME
FROM EMP
WHERE DEPTNO=10


 /*+HINT~~~~ */   이런식으로 사용하는 것까지는 누구나 안다. (HINT의 종류는 검색해보면 많음)

그러나 '왜 이렇게 일어나지?', '어떻게 동작하지?' 이런 고민을 해보지 않고 + 직접 '체득'하지 않은 사람들이 많을 것이다. 
(필자 포함)

인덱스는 면접에서 자주 물어보는 것중에 하나다.

추측으로는 면접+실무에서 포인트는 인덱스에 대해서 정확하게 알고 있어야만 적재적소에 적용할 수 있기 
때문에 꼼꼼하게 정리하고 이해했는지를 물어보는 것 같다.

인덱스는 범위 스캔(Range Scan)을 한다

인덱스는 키 컬럼순으로 정렬되어 있기때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다. (=Range Scan)

인덱스에 가장 많이 사용되는 구조 = B-tree

인덱스를 저장하는 블럭들이 트리구조를 이루고 있다.

root block과 branch block, leaf block이 있고 B-tree는 기본적으로 leaf block의 깊이가 모두 동일하게 균형(Balanced)이 잡혀있다.

또한 각 노드에 값도 가지고 있다. (B+tree는 값은 없고 탐색을 위한 인덱스 정보만 있음)
```

## 장점
- 테이블 검색과 정렬 속도를 향상시킵니다. 또한 index를 기본키로 자동설정하여 관리가 편합니다.

## 단점
- 인덱스 파일을 별도로 만들어야함으로 파일의 크기가 늘어나고 인덱스를 처음에 생성하는데 시간이 많이 소요될 수 있습니다. 또한 인덱스된 컬럼값이 변경되거나 인덱스를 업데이트해야하기에 성능이 떨어지게 됩니다.
* select절을 제외하고 인덱스는 원래 테이블에 매핑된 테이블을 하나 더 만드는 것이기 때문에 update, insert 경우는 소팅된 이 테이블에 넣어야 하기 때문에 시간이 더 오래걸린다. 

## 결합 인덱스
* 단일 컬럼도 되지만 여러 컬럼을 조합하여 결합 인덱스로 구성 가능
* equal 조건으로 많이 스는 조건이 앞으로 오는 것이 좋다
* 분별력이 높은 컬럼이 앞으로 오는 것이 좋다. 성별 보다는 id 같은 것들

## 인덱스를 사용해야 될 때
- 위와 같은 단점에 따라 변경이 잦은 컬럼에는 인덱싱을 피하고, true/false 값을 같는 컬럼처럼 중복도가 높은 컬럼은 인덱스로 만들어도 고유성이 없기에 효용이 없습니다. where절과 join, order by 등에 자주 사용되는 컬럼의 경우 인덱스로 선정하면 검색 속도를 효과적으로 높일 수 있습니다.

### 인덱스 손익 분기점
* 테이블이 가지고 있는 전체 데이터양의 10에서 15프로 이내의 데이터가 출력이 될때만 인덱스를 타는게 효율적이다. 그 이상일 땐 풀스캔이 더 효율적이다.

## 인덱스 구조
- 검색의 효율을 높이기 위해 B-tree 또는 B+tree 구조를 사용합니다.

## 인덱스 원리
* 인덱스를 컬럼에 부여하면 초기 TABLE생성시 만들어진 myd,myi,frm 3개의 파일 중에서 myi에 해당 컬럼을 색인화 하여 저장한다.
* 사용자가 SELECT쿼리로 index가 사용하는 쿼리를 사용시 해당 table을 검색하는 것이 아니라 빠른 tree로 정리해둔 myi파일의 내용을 검색한다.
* 만약, index를 사용하지 않은 select쿼리라면 해당 table을 full scan하여 속도가 느리다.

## Unique index
* UNIQUE INDEX는 중복 값을 허용하지 않는 인덱스입니다.
* MySQL에서 UNIQUE INDEX를 생성하는 문법은 다음과 같습니다.
```java
문법
CREATE UNIQUE INDEX 인덱스이름

ON 테이블이름 (필드이름1, 필드이름2, ...)
```
* 또한, 쉼표(,)를 사용하여 여러 필드에 UNIQUE INDEX를 설정해 줄 수도 있습니다.

 


## 인덱스 스캔
1. 풀 스캔
2. index range scan(특정 부분)
3. index skip scan
4. index fast full scan

## B-Tree
- B-Tree는 검색성능을 높이기 위한 Balanced-Tree 자료구조의 종류 중 하나로서 이진트리와 다르게 하나의 노드에 여러자료가 배치되고 2개이상의 자식노드를 가질 수 있는 Tree 구조입니다. 루트를 제외한 모든 노드의 자료수는 LIMIT/2개여야하며, 자식노드의 수는 (부모노드의 자료수 + 1)개여야하는 특징이 있습니다. 이것의 이유는 B-Tree의 구조 때문에 생긴 특징입니다. 따라서 삽입, 삭제시에도 트리 균형을 유지할 수 있는 특징과, 언제나 균등한 탐색속도를 보장하는 특징이 있지만, 트리의 균형을 유지하기 위해 복잡한 연산을 해야하며, 무엇보다 중위순회방식을 사용하기에 순회탐색이 비효율적이라는 단점이 있습니

## B+Tree
- B+Tree는 B-Tree에서 순회탐색의 비효율을 보완한 구조로서, 노드의 데이터들이 연결리스트로 연결되어 있어 순차적 처리가 가능하여 순회탐색이 빠릅니다. 트리의 최하단 노드에만 데이터들이 연결리스트로 정렬되어 있으며 나머지 노드들은 키값만 가지고 있는 구조입니다.

## Balanced-Tree
- Tree 자료형의 기본적인 구조인 이진트리는 좌우 균형이 안 맞아 비효율적이라는 단점을 가지는데 이것은 해결한 자료구조가 Balanced-Tree 구조입니다. Balanced-Tree는 한쪽으로 몰린 depth를 균일하게 재배치함으로서 모든 자식 노드들의 depth를 균일하게 합니다. 따라서 어떠한 상횡에서도 검색성능을 O(logN)까지 일관된 속도를 보장하는 구조입니다.


## Replication
- 리플리케이션이란 데이터베이스를 접근하는 DB서버와 데이터를 저장하는 저장소를 구성하는 하나의 세트를 복제하여 여러 세트로 구성함으로써 위험을 분산하는 구조를 말합니다. 이러한 구조를 저장소를 공유한다 하여 shared disk라고 부릅니다. 분산처리를 통해 성능 향상을 기대할 수 있는 장점이 있는 반면, 여러 데이터가 복제되어 있는 만큼 데이터의 정합성을 유지하기 어렵습니다. 따라서 갱신 주기를 어떻게 하느냐가 중요한데 이것은 성능과 데이터의 정합성에 트레이드오프 관계가 발생하는 단점이 있습니다.

## Sharding
- 데이터의 정합성 문제와 갱신에 의한 성능 저하가 발생하는 shared disk의 문제를 해결하기 위해 고안된 아키텍쳐가 shared nothing이며 이 개념에 기반하여 구글에서 만든 구조가 sharding 입니다. sharding은 데이터를 여러 저장소에 분할 저장함으로써 동기화에 대한 이슈를 제거했기에 속도 또한 빠릅니다. 분할된 구조를 통해 병합 문제를 해결하였습니다. 하지만 특정 저장소에 정해진 데이터가 저장되어있기에 데이터를 찾으려면 특정 저장소를 찾아가야한다는 문제점이 있으며, 하나의 DB 서버가 다운이 되면 복구할 수가 없다는 문제가 있습니다. 이러한 문제는 커버링이라는 구성을 통해 하나의 DB 서버가 다운되었을 때 그것을 이어받아 처리하는 조치가 필요합니다.


# 시퀀스
- ⎼시퀀스는 값이 일정한 규칙에 의해서 연속적으로 자동 증가하거나 감소해야 하는 경우에 적용 시킬 수 있는 오라클 객체이며 테이블내의 정수값을 가지는 기본키 에 사용될 수 있다
- 중간에 인덱스가 삭제되면 삭제된 인덱스는 점프해서 생성된다.


# 조인
- 컬럼대 컬럼(기본키와 외래키); 부모
1. (1) 크로스 조인 Cross Join( ) ⎼특별한 키워드 없이 테이블을 콤마로 연결해서 사용한다. 
2. (2) 이퀴 조인 Equi Join( ) ⎼동일 컬럼을 기준으로 조인한다. ⎼조인 조건이 정확히 일치하는 경우 사용하며 일반적으로 와 를 사용한다 PK FK . 
3. (3) 논 이퀴 조인 Non-Equi Join( ) ⎼동일 컬럼이 없이 다른 조건을 사용하여 조인한다. ⎼조인 조건이 정확히 일치하지 않은 경우 사용한다 등급 학점 등 .( , ) … 
4. (4) 셀프 조인 Self Join( ) ⎼한 테이블 내에서 조인한다. ⎼하나의 테이블에서 행들을 조인하고자 할 경우에 사용한다. 
5. (5) 아우터 조인 Outer Join( ) ⎼조인 조건에 만족하지 않는 행도 나타낸다. ⎼조인 조건이 정확히 일치하지 않는 경우에도 모든 행들을 출력한다.

## 조인과 서브쿼리 차이
- 조인은 컬럼대 컬럼 대상, 서브쿼리는 값대 값; 값을 통한 조인
