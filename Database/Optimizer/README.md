# [옵티마이저](https://www.youtube.com/watch?v=dP0MIgyrqlo&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=22)
* 우리가 짜놓은 쿼리르 성능에 가장 유리한 방향으로 이끌어주는 역할을 하게 되는 것
* DB에서 데이터를 조회하고 찾아가는 작업이 거의 대다수! 서버의 70% 이상이 SQL 처리시간
* 옵티마이저란 인덱스의 유무, 데이터 분산 또는 편향 정도 등의 통계정보를 참고하여 여러 실행계획을 작성하고
  이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택하는 DBMS 핵심 엔진
* 옵티마이저는 한정된 통계로 인해 최적화를 못할 수도 있음 -> 이때 실행계획을 우리가 바꿔야 한다.
    * 힌트를 사용하여 올바른 실행계획으로 쿼리를 실행할 수 있도록 도움을 줄 수 있다.

## 옵티마이저 구성
* 로지컬 옵티마이저
    * Query Trnansformation을 수행하면서 우리가 짜놓은 쿼리를 여러가지 형태로 변환시키는 역할
    * 이 결과들은 원래 쿼리의 결과값가 반드시 같아야 한다
* 피지컬 옵티마이저
    * 로지컬 옵티마이저가 생성해놓은 여러가지 쿼리들의 비용을 계산해서 가장 저렴한 쿼리를 골라낸다
    * Cost Estimator: 비용을 계산하는 것
    * Plan Generator: 비용을 계산하기 위해 실행계획을 도출해내는 것
* 옵티마이저는 Query Transformer, Cost Estimator, Plan Generator로 구성 되어 있어서 우리의 쿼리가 빠르게 동작할 수 있도록 이끌어 주는 것


# 쿼리 처리흐름
* 사용자가 작성한 쿼리 -> 파서 -> 파싱된 커리 -> 옵티파이저(플랜 생성, 비용 평가) -> (실행계획) -> 플랜 평가 -> 결과 반환

## 실행계획
* SQL에서 요구한 사항을 처리하기 위한 '절차와 방법'
* 동일한 sQL에 대해 결과를 내는 방법은 여러가지지만 각 비용은 서로 다르다
* 실행계획을 보기 위해선 mySQL에선 <explain> + SQL문을 사용

## Table Full Scan
* 테이블의 row를 모두 접근 -> 가장 비효율적인 방법

### Full Table Scan이 유리한 경우
* 테이블의 크기가 작을 때
* 조건절이 없을 때(Where, on)
* 조건에 일치하는 레코드 수가 굉장히 많을 때

## Using file sort(Using tempoaray)
* Using temporary: 쿼리를 처리하는 동안 중간결과를 담아두기 위한 임시 테이블
* Using file sort: 결과를 정렬 -> 정렬을 할 필요가 없을땐 없애는게 좋은가?
