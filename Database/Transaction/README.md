# 문제
```java
15. 데이터베이스 로그(log)를 필요로 하는 회복 기법은?  1
① 즉각 갱신 기법
② 대수적 코딩 방법
③ 타임스탬프 기법
④ 폴딩 기법

```


# 트랜잭션
1. read_commited/read_uncommited 체크하기
2. table lock / row lock 체크하기

# 트랜잭션 메카니즘
* [매카니즘](https://www.youtube.com/watch?v=ImvYNlF_saE)
* 쿼리 처리기 -> 데이터 캐시, 로그 캐시
    * 로그 캐시 ->  데이터 캐시 < 데이터 파일
    * 로그 캐시 < 로그 파일

#  데이터베이스
```java
Active
트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.

Failed
트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.

Partially Committed
트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.

Committed
트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.

Aborted
트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

Partially Committed 와 Committed 의 차이점
Commit 요청이 들어오면 상태는 Partial Commited 상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 
Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Commited는 Commit 요청이 
들어왔을때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.

트랜잭션을 사용할 때 주의할 점
트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 
일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 
사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 
기다려야 하는 상황이 발생할 수도 있는 것이다.

```

# [트랜잭션 메카니즘](https://www.youtube.com/watch?v=ImvYNlF_saE&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=18)

## Transaction
* 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 일련의 연산 집합으로서 작업의 단위이다.
* 트랜잭션(Transaction)은 데이터베이스의 완전성을 보장하기 위한 것입니다.
* 상태를 변화시키기 해서 수행하는 하나의 작업의 단위를 뜻합니다.
- ⎼오라클에서 발생하는 여러 개의 SQL . 문들을 하나의 논리적인 작업단위로 처리하는데 이를 트랜잭션이라고 한다 
- 트랜잭션의 결과는 반드시 모두 성공하거나 모두 실패 하거나 둘 중 하나이므로 반드시 명시적으로 종료를 시켜주어야 된다

### 원자성 (Atomicity)
* all or nothing
 * 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 것을 의미한다.
 * 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

### 일관성 (Consistency)
 * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
 * 일관성 있는 데이터베이스 상태라는 것은 다양한 제약 조건(constraints, cascades, triggers)등에 만족한다는 것이다. - Software Level

### 독립성 (Isolation)
 * 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
 * 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.

### 지속성 (Durability)
 * 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. - Hardware Level
 * 전력문제, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
 * 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
 * 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.


## Rollback
* 트랜잭션 처리가 비정상으로 종료되어 데이터베이스의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산

### 트랜잭션(Transaction)을 사용하며 주의해야 할점?
* 언제나 얻는 것이 있으면 잃는 것도 있다.
* 트랜잭션은 데이터를 완전성을 보장하기 위해 많은 자원들을 사용하게 된다. 자원을 사용하며 Lock을 걸게 되면 다른 사용자들은 Lock이 해제될 때까지 기다려야한다. 기다린다는 것은 성능에 좋지 않다는 의미이다. 따라서 Transaction의 범위를 최소화하여 적용하는 것이 좋다.

## [병행 제어(Concurrency Control)의 개념](https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a)
- 동시에 여러개의 트랜잭션을 병행 수행할 때, 트랜잭션들이 DB의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것.
- 병행성 : 트랜잭션을 동시에 인터리빙(Interleaving)하게 실행되는 것.
- 인터리빙 : 트랜잭션이 번갈아가며 조금씩 처리를 수행하는 것.

### 병행 제어의 목적
- DB의 공유도 최대화.
- 시스템 활용도 최대화.
- 응답 시간 최소화.
- 단위 시간당 트랜잭션 처리 건수 최대화.
- DB의 일관성 유지

### 병행제어의 필요성
- 갱신 분실 (Lost Update): ・같은 데이터를 공유하여 갱신할 때 갱신 결과의 일부가 사라지는 현상.
- 모순성 (Inconsistency) ・동시에 같은 데이터를 갱신할 때, 데이터의 상호 불일치가 발생하는 현상. ・불일치 분석(Inconsistent Analysis)이라고도 한다.
- 연쇄 복귀 (Cascading Rollback) ・트랜잭션 중 하나에 문제가 생겨 Rollback 되는 경우, 다른 트랜잭션들도 함께 Rollback 되는 현상.

## 병행 제어 기법의 종류

### 2-단계 잠금 규약(Two-Phase Lock Protocol) 기법
- 트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법
- 2단계는 다음과 같다.
- 확장(Growing) 단계 : 잠금만 수행할 수 있음. (해제 불가)
- 축소(Shrinking) 단계 : 해제만 수행할 수 있음. (잠금 불가)
- 장점 : 직렬성 보장 / 단점 : 교착 상태 예방 불가능

### 타임 스탬프(Time Stamp Ordering) 기법
- 시스템에 도착한 순서대로 타임 스탬프를 부여하여, 순서대로 실행하도록 한다.
- 교착 상태가 발생하지 않는다.
- 출처: https://cbts.tistory.com/250 [IT일기장]


# Lock
* 트랜잭션이 시작되면 이용하고 있는(Row, Table)은 트랜잭션이 끝날 때 까지 점유한다.

## 로킹
* 상호배제와 접근제어 기능
* Lock을 걸어 그 Lock을 건 트랜잭션만이 Lock을 해제 할 수 있다.
* 하나의 Transaction이 사용하는 DB내의 data를 다른 Transaction이 접근하지 못하게 Lock을 설정하여  다른 Transaction이 접근하지 못하도록 한다. 실행 완료 후엔 Lock을 해제한다.

### 로킹의 특징
* 로킹 단위가 크면 로크 수가 적어 관리하기 쉽지만 병행성 수준이 낮아진다.
* 로킹 단위가 작으면 로크 수가 많아 관리하기는 복잡하지만 병행성 수준이 높아집니다.

### 2단계 로킹 규약(Two-Phase Locking Protocol)
 * 트랜잭션은 lock만 수행할 수 있고, unlock은 수행할 수 없는 확장 단계가 있다.
 * 
 * 확장단계(Growing Phase)
 * Lock을 설정하는 단계
 * 새로운 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계
 * 축소단계(Shirinking Phase)
 * Lock을 해제하는 단계
 * unlock 연산만 실행할 수 있고 일단 unlock 연산을 실행하면 lock 연산은 실행할 수 없는 단계
 * 교착상태(Deadlock)이 발생할 수있다.
 * 
 * 2단계 로킹 규약 준수 o –> 직렬가능 
 * 2단계 로킹 규약 준수 x –> 직렬가능성을 보장 할 수없다. 직렬이 가능할수도, 가능하지 않을수도…


# 사용자 관리
- 사용자가 접속 한 후에 테이블을 생성하고 데이터를 조회, , , 입력 수정 삭제 등을 하기 위해서는 특별한 권한이 필요하다. 
- ⎼권한의 종류도 시스템 권한과 객체 권한으로 나누어지며 여러 개의 권한을 묶어서 롤(role) 이라는 개념으로 사용한다. 
- ⎼개별적인 권한보다 롤을 사용하는 것이 더 효율적이며 새로운 계정 및 권한 부여는 DBA .

## 롤
- 권한들의 묶음

## grant
- RESOURCE : 개체를 생성, 변경, 제거 할 수 있는 권한 ( DDL, DML사용이가능함)
- CONNECT : 데이터베이스에 연결할 수 있는 권한
- DBA : 데이터베이스 관리자 권한
- GRANT CREATE TABLE TO 유저명             // 테이블을 생성할 수 있는 권한
- GRANT DROP ANY TABLE TO 유저명         // 테이블을 제거할 수 있는 권한
- grant connect, resource to test1;  resource: 테이블 삭제 수정
- grant create sequence to test1;
-  test 계정에게 권한을 부여하며 sequence 키워드는 시 퀀스를 생성할 수 있도록 시퀀스에 대한 권한을 부여한다. 
- grant create view to test1;

## revoke
- revoke 권한 및 롤 from 계정; 
- revoke create sequence from test;

# 키
- 키는 테이블에서 행들을 구별할 수 있는 속성 또는 속성들의 집합을 말합니다. 특징으로 모든 행에서 유일값을 가져야하는 유일성, 최소한의 속성들로만 키를 구성하는 최소성이 있습니다. 대표적으로 슈퍼키, 후보키, 기본키, 대체키, 외래키가 있습니다.

## 슈퍼키
- 유일성을 만족하는 키, 즉 고유하게 식별하는 모든 조합을 슈퍼키라고 합니다.

## 후보키
- 기본키로 선정될 수 있는 후보라는 의미로 유래된 이름이며, 유일성과 최소성을 만족하는 키입니다.

## 슈퍼키와 후보키의 차이점
- 슈퍼키의 조합에서 더 줄일 수 없이 꼭 필요한 키로 구성된 조합을 후보키라고 합니다. 예를 들어 ‘마을ID’, ‘도시명’, ‘도명’이 있는 테이블에 {마을ID, 도시명, 도명} 으로 구성된 키는 슈퍼키가 될수 있으며, {마을ID}, {도시명, 도명}이 후보키가 될 수 있습니다.

## 기본키
- 후보키 중에서 설계자에 의해 선택된 키입니다.

## 대체키
- 후보키 중에서 기본키로 선택되지 못한 키입니다.

## 외래키
- 다른 테이블의 기본키를 참조하는 속성을 외래키라고 합니다.

# 기본키와 외래키 조인의 문제점
- 기본키와 외래키 사이의 참조 무결성 지키기 위해 복잡해진다.

# 기본키와 외래키 조인의 장점
- 보안성이 좋아진다.



# 회복
 * 회복(Recovery)은 트랜잭션들을 실행하는 도중 장애(Failure)가 발생하여 데이터베이스가 손상되었을 경우 손상되기 이전의 정상 상태로 복구하는 작업이다.

## 회복 장애
 *  * ᆞ실행 장애(Action Failure) : 사용자의 실수, 무결성 규정 위반 등으로 질의 실행이 실패하는 현상
 *  * ᆞ트랜잭션 장애(Transaction Failure) : 트랜잭션 내부에서 입력 데이터 오류, 불명확한 데이터, 시스템 자원
 *  * 요구의 과다 등 비정상적인 상황으로 인하여 트랜잭션 실행이 중지되는 현상
 * ᆞ( 1 ) 장애(System Failure) : 데이터베이스에는 손상을 입히지 않으나 하드웨어 오동작, 정전, 소프트웨어(운영체제나 DBMS 등) 오류, 교착 상태 등에 의해 실행중인 모든 트랜잭션들이 더 이상 실행을 계속할 수 없는 현상; 시스템 장애
 * ᆞ미디어 장애(Media Failure) : 저장 장치인 디스크 블록의 손상이나 디스크 헤드의 충돌 등에 의해 데이터 베이스의 일부 또는 전부가 물리적으로 손상되는 현상
 * 
 * 회복 관리기는 로그(Log), 메모리 ( 2 ) 등을 이용하여 회복 기능을 수행하는 DBMS의 핵심 구성 요소이다. 회복 관리기는 트랜잭션 실행이 성공적으로 완료되지 못하면 로그를 이용하여 트랜잭션이 데이터베이스에 생성했던 모든 변화를 취소(Undo)시켜서, 트랜잭션 실행 이전의 원래 상태로 되돌리는 역할을 담당한다. 덤프


## 회복기법의 종류
 * ᆞ연기 갱신(Deferred Update) 기법 : 연기 갱신 기법은 트랜잭션이 성공적으로 종료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 기법이다.
 * ᆞ즉각 갱신(Immediate Update) 기법 : 즉각 갱신 기법은 트랜잭션이 데이터를 변경하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 기법이다.
 * ᆞ그림자 페이지(Shadow Paging) 기법 : 그림자 페이지 기법은 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지로 별도 보관해 두고, 실제 페이지를 대상으로 트랜잭션에 대한 변경 작업을 수행하는 기법이다.
 * ᆞ( 3 ) 기법 : 시스템 장애가 발생하였을 경우, Redo와 Undo를 수행하기 위해 로그 전체를 조사해야 하는 경우를 피하기 위한 기법이다. 검사점
