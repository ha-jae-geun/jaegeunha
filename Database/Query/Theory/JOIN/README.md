# 내부조인
* 내부조인은 테이블의 값이 일치하지 않는다면 해당 레코드는 출력되지 않는다.


# 중첩 루프 조인
```JAVA
한 집합의 원소 값을 다른 집합의 원소 값과 매칭해 나가는 방법

(가능한 모든 경우를 조회하여 결과 집합을 찾는 방법)

 

성능을 높이기 위한 방법

  가) 후행테이블의 크기가 작을수록

  나) 요소들의 비교가 빠르게 이루어 지도록 인덱스가 미리 설정되어 있어야 한다.

 

* 선행테이블(Driving Table) : 찾는 주체가 되는 테이블

* 후행테이블(Driven Table) : 비교 대상이 되는 테이블

 

▷ 예제

 --Nested-Loop Join

SELECT *

FROM pubs.dbo.employee e inner loop join pubs.dbo.jobs j

on e.job_id = j.job_id

 

[쿼리 분석기에서 Ctrl+L 을 눌러 실행계획을 실행]



옵티마이저는 통계를 기반으로 로우의 크기가 작은 쪽을 후행테이블로 선택한다. 
여기서 선행 테이블(Driving Table)은 Employee 테이블이다. 선행 테이블 Employee 를 
기준으로 Nested Loop 해서 Jobs 테이블을 조인한다.

쿼리 분석기의 실행계획에서는 선행테이블의 선이 굵게 나타난다. Nested Loop 조인은 
가장 기본적인 조인 전략으로 데이터 량이 적은 경우에는 이보다 확실한 방법이 없다.
```

# HASH 
```JAVA
해시를 사용하는 경우는 해당 조인 키가 전혀 정렬되어 잇지 않고, 인덱스도 존재하지 않으면서 비교해야 할 대상은 많은 때이다.

 

 

▷ 예제

 --Hash Join

SELECT *

FROM pubs.dbo.employee e inner hash join pubs.dbo.jobs j

on e.job_id = j.job_id

 

[쿼리 분석기에서 Ctrl+L 을 눌러 실행계획을 실행]
```
```JAVA
해시 조인(Hash-Join)은 두 테이블 중 하나를 기준으로 비트맵 해시 테이블을 메모리에 올린 후 
나머지 테이블을 스캔 하면서 해싱 테이블을 적용하여 메모리에 로딩된 테이블과 비교하여 매칭되는 
데이터를 추출하는 방식의 조인이다.
RDBMS에 서 비용이 가장 많이 들어가는 Join 방법으로 주로 작은 Table과 큰 Table 의 Join 시 사용되어 지며 , 
Driving 조건과 상관없이 좋은 성능을 발휘할 수 있다.


1. 작은 테이블(Build Input)을 읽어 Hash Area에 해시 테이블 생성한다.
(해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인에 엔트리를 연결)
2. 큰테이블 집합(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인하는 방식이다.
(해시 함수에서 리턴 받은 버킷 주소로 찾아가 해시 체인을 스캔하면서 데이터를 찾는다)


[특징]

- 해시 조인은 안티 조인과 병렬처리와 잘 맞으며 범위 검색(Range scan)이 아닌 동등 비교(Equi-Join,
where절에서 등호로 비교하는 경우)에 더 적합하다.
- NL조인 과 달리 Random 액세스 부하가 없다.(단, 양쪽집합을 읽는 과정에서 인덱스를 이용한다면 Random 액세스 발생)
- NL조인 과 달리 Hash Area에 미리 생성해 둔 해시 테이블(또는 해시 맵)을 이용한다.
(해시테이블을 만드는 단계는 전체범위처리 불가피, Probe Input을 스캔하는 단계는 NL조인처럼 부분범위처리가능)
- 소트머지조인과 달리 조인 전에 미리 양쪽 집합을 정렬하는 부담이 없으며 NL조인 과 달리 래치획득 과정없이 
PGA에서 빠르게 데이터 탐색한다.
- 해시 테이블을 생성하는 비용이 수반됨으로 Build Input이 작을때 효과적이며 PGA(or SGA) 메모리에 할당되는
Hash Area에 담길 정도로 충분히 작아야 한다. 해시키 값으로 사용되는 컬럼에 중복값이 거의 없을 때 효과적이다.
- SQL 문장에서 옵티마이저는 해쉬 조인으로 수행하기 위해 작은 테이블을 메모리에 로드 한 후 큰 테이블을 
여러 Partition으로 분리하여 메모리에 로드가 되어 있는 작은 테이블을 해쉬 알고리즘에 의하여 탐색하게 되고
여러 Partition 으로 나뉘어 지는 테이블은 HASH_AREA_SIZE 에 명시된 메모리에 상주되며 메모리가 충분치 않아
메모리에 모두 상주 시킬수 있는 상황이라면 디스크에 위치하게 된다. (충분한 hash_area_size 제공필요)
- 해시조인을 사용하기 위해서는 USE_HASH hint를 사용 한다.


해시 조인 사용기준

- 기준
1. 한쪽 테이블이 Hash Area에 담길 정도로 충분히 작아야함.
2. Build Input 해시 키 컬럼에 중복 값이 거의 없어야 함.

- 조건
1. 조인 컬럼에 적당한 인덱스가 없어 NL조인이 비효율적일때
2. 조인 컬럼에 인덱스가 있더라고 NL 조인 드라이빙 집합에서 Inner 쪽 집합으로서의 조인 액세스량이 많아
Random 액세스 부하가 심할 때
3. 소트 머지 조인하기에는 두 테이블이 너무 커 소트 부하가 심할때
4. 수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 조인할때

- 결과
1. 해시테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조이다.
2. 수행빈도가 낮고, 쿼리수행 시간이 오래 걸리는, 대용량테이블을 조인할 때
```

# 병합 조인
```JAVA
한집합과 다른 집합을 합하기 위해서 양쪽 다 정렬이 되어 이썽야만 비교 가능하다. 
그리고 Sort Merge의 경우 대등하게 합병되기 때문에 선행 또는 후행 테이블이 존재하지 않는다.

 

▷ 예제

 --Sort Merge Join

SELECT *

FROM pubs.dbo.employee e inner merge join pubs.dbo.jobs j

on e.job_id = j.job_id

 

[쿼리 분석기에서 Ctrl+L 을 눌러 실행계획을 실행]
```

# 리모트 조인

# Self Join
* 자기자신 테이블과 조인을 하는 경우
* 같은 테이블을 두 번 사용하므로 테이블 별칭을 반드시 사용해야 한다.
* 특별한 경우로 ㅎ나 테이블의 외래키칼럼이 자기 자신 테이블의 주키를 참조하는 경우 이용하게 된다.
* emp 테이블의 MGR 칼럼은 외래키로서 자기자신 테이블 EMP의 EMPNO를 참조한다.


## 서브 쿼리 사용 말고 Self Join 사용할 때
```SQL
select e1.ename
from emp e1, emp e2
where e1.deptno = e2.deptno
and e2.eanme = 'Smith'
```


# Union과 Union ALl 차이
* Union은 합집합을 구했을 때 교집합이 되는 부분을 Distinct를 해서 하나의 row로 출력해주는 명령어
* Union All은 말 그대로 교집합 부분도 가감없이 모두 출력해주는 명령어

## Union All를 사용해야 할 때
* union은 Sort 연산을 발생시키는 명령어이기 때문에 굳이 중복값을 제고하지 않아도 되는 상황 PK 컬럼이 잉써서 row의 유니크함이 보장되는 상황일 떄는 Union ALl을 사용하는 것이 좋다.

## Union 처럼 sort 명령어를 사용하는 명령어
