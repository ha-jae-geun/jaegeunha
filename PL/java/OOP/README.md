## [정아마추어](https://jeong-pro.tistory.com/95?category=793347)

# OOP
* [OOP]('http://woowabros.github.io/study/2016/07/07/think_object_oriented.html')
* 메세지가 객체를 정한다.
  ^messages decide to create object // message first
```java
객체지향 디자인 원리들을 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있습니다. 
```

# [OOP 설계 원칙(SOLID)](http://www.nextree.co.kr/p6960/)

### SRP(The Single Responsibility Principle); 단일 책임 원칙
* 한 클래스는 하나의 역할만 맡는다. 
* Responsibility: Method
* 어떤 클래스(메소드, 컴포넌트)가 변경되는 이유는 유일해야 한다.

### OCP(Open Close) 개방-폐쇄 원칙
* 인터페이스는 가능하면 변경되어서는 안 됩니다. 
* 확장에 대해 열려있고 수정에 대해 닫혀있다.
  - 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
  - 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
* interface, protocol, standard, HTTP 표준을 rendering 하는 각종 browser 들
* 운전자 -> 자동차 -> 마티즈/소나타(사용자는 마티즈, 소나타를 볼 수 없다.)
* 자바 애플리 케이션 <> JDBC 인터페이스 <> JDBC 드라이버(오라클, MySQL, MS-SQL)

### LSP(Liskov Substitution); 리스코프 교체 원칙
* 이미 언어 상에서 구현되어 있음
* 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 
* 기반 클래스의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
  서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다.
  펭귄은 동물의 한 종류이다.(상속)
* 상위 분류는 하위분류의 종류여야 한다. 하위타입은 그것의 기반 타입에 대해 치환 가능해야 한다.
* 구현 클래스는 인터페이스가 될 수 있어야 한다.
  펭귄은 날 수 있어야 한다.(인터페이스)
  Base Class의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
* 위키피디아 논문: 하위형에서 선행 조건은 강화될 수 없다.
  하위형에서 후행 조건은 약화될 수 없다.
  하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

### ISP(Interface Segregation); 인터페이스 격리 원칙
* 클라이언트는 자신이 쓰지 않는 인터페이스에 의존하지 않는다.(그러니 인터페이스를 더 작게 나눈다.)
* 로버트 마틴: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

### DIP(Dependency Inversion); 의존 관계 역전 원칙
* 상위 수준 모듈이 하위 수준 모듈에 의존하면 안 된다.
* 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙
* 로버트 마틴: 자주 변경되는 구체 클래스에 의존하지 말아야 한다.
* 자동차 -> 타이어(인터페이스) > 스노우타이어


# 객체지향 프로그램이이란?
```java
"객체 지향 프로그래밍에 대해 설명 한번 해주세요" 

가장 기본이면서 이것마저 대답을 명확하게 못하면 첫인상이 안 좋아지는(?) 결과를 만드는 질문이다.

그리고 워밍업같지만 꼬리에 꼬리를 무는 모든 질문의 시작(?)이다.

객체 지향 프로그래밍(OOP)이 뭐에요?

객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 
추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

이러면 이제 아까 말했던 꼬리에 꼬리를 무는 질문이 시작된다.

"객체 지향 프로그래밍을 했을 때 장점이 뭐에요?"

"객체 지향 프로그래밍의 특징을 말씀해주세요"

"객체(또는 클래스)가 뭐에요?"

=> 결국 객체 지향 키워드 5가지와 관련된 내용과 장단점을 알고 있는지에 대한 질문이다.

(객체지향의 5원칙(SOLID)은 아님)

객체 지향 프로그래밍의 장, 단점 간단하게 설명해주세요

- 장점

▶코드 재사용이 용이

남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.

▶유지보수가 쉬움

절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 
반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨. 

▶대형 프로젝트에 적합

클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.



- 단점

▶처리속도가 상대적으로 느림

▶객체가 많으면 용량이 커질 수 있음

▶설계시 많은 시간과 노력이 필요

객체 지향 프로그래밍 키워드 5가지

1) 클래스 + 인스턴스(객체)

2) 추상화

3) 캡슐화

4) 상속

5) 다형성

클래스와 인스턴스(객체)는 무엇인지 설명해주세요.

클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 
속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것

인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

객체지향프로그래밍에서 추상화 (자료의 추상화)

불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.

(= 객체지향 관점에서 클래스를 정의하는 것.)

(!= abstract 클래스, abstract 메서드와는 다른 이야기임)

캡슐화가 무엇인가요?

캡슐화의 목적 : 코드를 재수정 없이 재활용하는 것.

프로그램 코드에서 변수와 함수를 재활용하기에는 분산되어 있기 때문에 재활용이 어려웠으나 
캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활해졌다.

객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다.

객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.

상속은 무엇인가요?

절자 지향 프로그래밍에서도 "라이브러리"를 통해서 남이 짜놓은 소스 코드를 가져와 사용할 수 있었다.

하지만 내 의도에 맞게 수정하게되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 
불필요한 코드의 수정작업을 해야한다는 것이다.

이런 문제를 해결하기 위해 [상속]이라는 것을 도입하였다.

상속은 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 
상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.

* 다중상속은 불가하다. (클래스의 상속 관계에서 혼란을 줄 수 있기 때문에 상속은 반드시 하나만 가능하고 
필요에 따라 인터페이스를 사용할 수 있게 했다. 자세한 내용은 이전 포스트에 있음.)

다형성은 무엇인가요?

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.

즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.

오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.

오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에
따라 다르게 호출할 수 있게 하는 것.

getter, setter 를 사용하는 이유는 무엇인가요?

멤버변수에 직접접근하지 못하게 private으로 접근지정자를 설정하고 public으로 getter, setter 메서드를 만드는 것을 많이 해왔다.

그러면서 이럴꺼면 어차피 아무나 접근가능한데 왜 private을 할까? 라고 생각했었다.

결론부터 말하면 getter, setter를 사용하면 메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 
어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문이다.

예를들면 setter에서 유효범위를 넘은 정수가 들어왔을 때의 처리를 하고나서 set하거나 예외처리를 해버릴 수 있는 것이다.

getter도 마찬가지로 굳이 예를들자면 자료에 무언가 더하거나 빼고 준다든지가 가능하다.
```



# 상속과 구현의 차이점 과 특징 및 장단점

1. 상속 : is-a 관계(태생부터 무엇인가 기질을 타고 난 경우)

2. (인터페이스)구현 : can-do 관계(후천적인 형질)
* 장점 : 코드의 중복이 없음, 메소드 오버라이드를 통한 확장, 인터페이스 공유를 통한 다형성 구현
* 단점 : 다중상속을 통한 복잡성 증가(다이아몬드 형태)





# 객체지향
* 나(추상화) -> 옆(캡슐화; 클래스 다수) -> 밑(상속성, 다형성)  

```java
1. 추상화

 추상화라고 하는 것은 객체들의 공통적인 특징(속성 과 기능)을 뽑아내는 것이다.
 즉, 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
 추상화는 절차지향 프로그래밍에서도 있어왔다. 대표적인 것이 구조체와 같은 사용자 데이터형이다.
 이것은 데이터를 추상화해서 하나의 새로운 데이터 유형을 만드는 것이다. 예를들어 struct와 같은 구조체가 있다.
 하나의 새로운 데이터형을 정의하는 데 그 안에는 여러개의 부속데이터를 둘 수 있다. 이 때 그 데이터를 추상화를 통해 정의한 것이다.


 
2. 캡슐화(객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다.[5][6]>
 객체지향에서 캡슐화는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다.
 특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다.
 객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는 것이다.
 또한, 이러한 특징은 다른 의미로 사용되기도 한다. 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로 
 사용할 때 캡슐화라는 용어를 사용한다. 즉, 데이터를 기능이라는 캡슐로 보호한다는 것이다.


3. 상속성
 상속이 없으면 객체지향은 절차지향과 별 다른 바가 없다.
 상속이란 특징을 가지면서 객체지향 언어가 절차지향 언어의 비해 문법의 규모가 2배이상 늘어났다.
 상속이란 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 가지고 있는 특징(데이터와 함수)들을 
 그대로 다른 클래스가 물려주고자 할 때 상속성의 특징을 사용한다.


4. 다형성
 가장 까다롭고 이해하기 어려운 특징으로 잘 이해하고 활용한다면 객체지향 언어를 제대로 쓰는 것으로 봐도 무방할 정도이다.
 다형성의 의미는 약간 다른 방법으로 일을 하는 함수를 동일한 이름으로 호출해 주는 것을 말한다.
```

## 다형성
* 다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
```java
다형성(Polymorphism)은 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것을 의미한다. 
다형성은 어떤 한가지 기능을 의미하는 것이 아니라 개념이기 때문에 여러가지 방법으로 표현할 수 있다.

Java에서 다형성을 위한 대표적인 기능은 바로 추상 클래스(Abstract Class)와 인터페이스(Interface), 
그리고 Overloading이 있다. 추상 클래스와 인터페이스는 사실 그 용도가 조금 다르지만 필자가 예로 들 
간단한 예시에서는 그 차이를 크게 느끼기 힘들기도 하고 무엇보다 이 포스팅은 Java 포스팅이 아니라 단순히 
다형성을 설명하기 위함이므로 필자는 이 중 추상 클래스만을 사용할 것이다.

그럼 이 기능들이 어떤 역할을 하는 지 살펴보면서 다형성이 무엇인가를 좀 더 자세히 알아보도록 하자. 
먼저, 추상 클래스를 사용하여 다형성을 만족시키는 예시를 먼저 설명할텐데, 사실 다형성이라는 단어를 
모르고 있던 분들이라도 자신도 모르게 이런 설계 패턴을 사용하고 있었을 수도 있을 정도로 기본적인 예시이다.

추상 클래스를 사용한 다형성 구현
추상 클래스는 Java에서 다형성을 만족시키기 위해 자주 사용되는 대표적인 기능이다. 말로만 설명하면 
재미가 없으니 한번 코드를 직접 눈으로 보는 것이 좋은데, 필자는 오버워치를 좋아하기 때문에 추상 클래스에
대한 예시도 오버워치를 가져와서 설명하겠다.

자, 필자는 이제 오버워치의 여러 영웅들을 클래스로 만드려고 한다. 오버워치의 영웅들은 공통적으로 
궁극기 게이지가 찼을 때 Q 버튼을 누르면 궁극기가 발동된다라는 기능을 가지고 있다. 하지만 오버워치의 
영웅들은 각자 특색에 맞게 다른 궁극기를 가지고 있는데, 라인하르트는 망치를 내리치며 다른 영웅들을 
기절시키고 맥크리는 시야에 보이는 여러 영웅에게 동시에 헤드샷을 날릴 수 있으며 메이는 로봇을 던져서 일정 범위 안의 영웅들을 얼린다.

이런 경우 다형성을 가지지 않은 오버워치 영웅 클래스는 다음과 같은 모습을 보일 것이다.
이때 만약 우리가 Hero 클래스를 상속받은 영웅 클래스들의 궁극기를 발동시키고 싶다면 어떻게 해야할까? 
안봐도 뻔하겠지만 눈물나는 if문 또는 switch문의 향연이 펼쳐질 것이다.

모든 영웅들의 궁극기 발동 메소드의 이름이 다르기 때문에 달리 방도가 없다. 그리고 추가적으로 
Hero 클래스에는 궁극기 발동 메소드가 없기 때문에 객체를 해당 영웅의 클래스로 형변환 해줘야하는 불편한 작업도 해야한다.

그래도 혹시 이 두 기능이 뭐가 다른지 궁금하신 분이 있을 것 같으니 최대한 간단히만 설명하고 넘어가자면, 
추상 클래스는 어떤 클래스의 기능을 그대로 사용하면서 그 기능을 확장하고 싶을 때 사용하는 것이고 인터페이스는
아무런 구현체가 없는 그냥 껍데기만 구현하는 것이다. 그렇기 때문에 인터페이스에는 자세한 메소드의 구현체가 
들어갈 수 없지만 추상 클래스는 자체적인 메소드의 구현체를 가질 수도 있다.(Java 8부터는 default 키워드를 
사용하여 인터페이스에도 메소드 구현체를 넣을 수 있게 변경되긴했다. 덕분에 구분이 더 애매해짐.)

이 예제의 Hero 클래스는 name 멤버 변수를 생성자로부터 받아서 자신의 멤버 변수로 추가하는 기능을 가지고 
있기 때문에 추상 클래스를 사용하는 것이 더 적절하다. 그럼 이제 추상 클래스를 사용하여 ultimate 메소드의 구현을 강제해보도록 하자.
```
