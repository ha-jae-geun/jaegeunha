# 객체지향 프로그램이이란?
```java
"객체 지향 프로그래밍에 대해 설명 한번 해주세요" 

가장 기본이면서 이것마저 대답을 명확하게 못하면 첫인상이 안 좋아지는(?) 결과를 만드는 질문이다.

그리고 워밍업같지만 꼬리에 꼬리를 무는 모든 질문의 시작(?)이다.

객체 지향 프로그래밍(OOP)이 뭐에요?

객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 
추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

이러면 이제 아까 말했던 꼬리에 꼬리를 무는 질문이 시작된다.

"객체 지향 프로그래밍을 했을 때 장점이 뭐에요?"

"객체 지향 프로그래밍의 특징을 말씀해주세요"

"객체(또는 클래스)가 뭐에요?"

=> 결국 객체 지향 키워드 5가지와 관련된 내용과 장단점을 알고 있는지에 대한 질문이다.

(객체지향의 5원칙(SOLID)은 아님)

객체 지향 프로그래밍의 장, 단점 간단하게 설명해주세요

- 장점

▶코드 재사용이 용이

남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.

▶유지보수가 쉬움

절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 
반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨. 

▶대형 프로젝트에 적합

클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.



- 단점

▶처리속도가 상대적으로 느림

▶객체가 많으면 용량이 커질 수 있음

▶설계시 많은 시간과 노력이 필요

객체 지향 프로그래밍 키워드 5가지

1) 클래스 + 인스턴스(객체)

2) 추상화

3) 캡슐화

4) 상속

5) 다형성

클래스와 인스턴스(객체)는 무엇인지 설명해주세요.

클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 
속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것

인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터

객체지향프로그래밍에서 추상화 (자료의 추상화)

불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.

(= 객체지향 관점에서 클래스를 정의하는 것.)

(!= abstract 클래스, abstract 메서드와는 다른 이야기임)

캡슐화가 무엇인가요?

캡슐화의 목적 : 코드를 재수정 없이 재활용하는 것.

프로그램 코드에서 변수와 함수를 재활용하기에는 분산되어 있기 때문에 재활용이 어려웠으나 
캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활해졌다.

객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는것이 캡슐화다.

객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.

상속은 무엇인가요?

절자 지향 프로그래밍에서도 "라이브러리"를 통해서 남이 짜놓은 소스 코드를 가져와 사용할 수 있었다.

하지만 내 의도에 맞게 수정하게되면 다른 라이브러리가 되어 버전에 따라 동작하지 않을 수 있고 
불필요한 코드의 수정작업을 해야한다는 것이다.

이런 문제를 해결하기 위해 [상속]이라는 것을 도입하였다.

상속은 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 
상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.

* 다중상속은 불가하다. (클래스의 상속 관계에서 혼란을 줄 수 있기 때문에 상속은 반드시 하나만 가능하고 
필요에 따라 인터페이스를 사용할 수 있게 했다. 자세한 내용은 이전 포스트에 있음.)

다형성은 무엇인가요?

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.

즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.

오버라이딩 : 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는것.

오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에
따라 다르게 호출할 수 있게 하는 것.

getter, setter 를 사용하는 이유는 무엇인가요?

멤버변수에 직접접근하지 못하게 private으로 접근지정자를 설정하고 public으로 getter, setter 메서드를 만드는 것을 많이 해왔다.

그러면서 이럴꺼면 어차피 아무나 접근가능한데 왜 private을 할까? 라고 생각했었다.

결론부터 말하면 getter, setter를 사용하면 메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 
어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문이다.

예를들면 setter에서 유효범위를 넘은 정수가 들어왔을 때의 처리를 하고나서 set하거나 예외처리를 해버릴 수 있는 것이다.

getter도 마찬가지로 굳이 예를들자면 자료에 무언가 더하거나 빼고 준다든지가 가능하다.
```

# 추상클래스와 인터페이스
```java
- 공통점

: 추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스다.

(자바8부터 인터페이스에 default method 구현이 가능해졌지만 일반적으로 인터페이스는 구현이 없다.)

따라서 인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없다.

추상클래스를 extends로 상속받아 구현한 자식클래스나 인터페이스를 implements 하고 구현한 자식클래스만이 객체를 생성할 수 있다.

=> 결국 자식클래스가 무언가 반드시 구현하도록 위임해야할 때 사용해야 한다.

- 차이점

추상클래스

추상클래스는 추상메서드(abstract method)가 하나라도 존재하는 클래스를 말한다.

추상클래스는 추상메서드(abstract method)가 없어도 무방하다.

추상클래스와 인터페이스의 차이점에서 키워드는 목적이다.

추상클래스의 목적은 말 그대로 공통적인 기능을 하는 객체들의 추상화다.

예제들을 보면 사자 클래스, 원숭이 클래스, 고래 클래스 같은 구체적인 클래스가 있고, 
추상클래스로 공통기능을 가진 동물 클래스를 만드는 것이 나온다.

이번 포스트에서는 동물 클래스 대신 포유류 클래스를 만들었다고 가정하자.

위키백과에 따르면 포유류는 젖먹이 동물이라고 한다.

즉, 젖을 먹이는 공통적인 기능을 가지고 있고, 각 포유류에 속하는 동물인 사자, 원숭이, 고래에게 중복으로 구현할 필요가 없다.

그래서 추상 클래스인 포유류 클래스를 만드는 것이다.

처음에 말했듯 추상클래스에 "젖을 먹인다" 라는 행위(메서드)를 추상메서드가 없어도 무방하다.

그러면 일반클래스와 뭐가 다른가? 다시 한 번 말하지만 키워드는 "목적"이다.

객체 지향 관점에서 봤을 때 클래스는 어떤 객체를 만드는 틀에 비유한다.

즉, 클래스는 어떤 인스턴스를 생성할 수 있다는 것인데, 추상 클래스는 생성할 수 없다는 특징이 있다. 
왜? 추상화된 클래스니까. 형용할 수 없으니까.

포유류 클래스에서 포유류를 생성하면 그 인스턴스(객체)는 뭐라고 구체적으로 말할 수 있을까? 없다. 세상에 없는 객체다.

추상 클래스에 추상 메서드가 없어도 된다는 것에서 일반 클래스와 다른 점을 설명했지만, 인터페이스와 차이점도 일맥상통한다.

추상 클래스는 일반적인 추상화 및 상속에 더 초점을 맞춘다면, 인터페이스는 인터페이스 메서드를 구현하게 하는 것에 초점을 맞춘다고 보면 된다.

포인트는 추상클래스를 언제 사용해야하는 지다.

인터페이스와 추상클래스를 단순하게 자식클래스에서 반드시 구현하게 위임시키는 것만 생각하면 비슷하지만 용도를 봤을 때 다르다.

추상클래스는 말그대로 추상화 시킬 때 사용하면 된다.

책에서 보는 is-a 관계가 핵심이다.

쉽게 말하면 만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용하는 것이 개발에서 이득일 때!

예를들면 냉장고, TV, 커피머신, 전자렌지등의 클래스를 만들어야할 일이 있을 때 가전제품이라는 추상클래스로 추상화 시켜서 사용하면 좋을 때 사용한다.

가전제품은 공통적으로 (on(), off(), 전기소모(), 기타등) 사용되는 메서드들을 적고, 구체적인 가전제품별로 별도의 동작(메서드)을 나눠서 적는다. 냉장고는 차갑게하고 전자렌지는 물분자운동을 시키는 동작 말이다.

(냉장고 is a 가전제품, 커피머신 is a 가전제품, 전자렌지 is a 가전제품)

상속 받아서 기능을 확장시키는데 목적, 전형적인 상속의 목적

또한 자바특성상 다중상속이 불가한 점을 고려해서 사용해야한다.

요약하면 다중상속 불가, 멤버 변수 존재 가능, 구현된 메서드 존재 가능 이다.




인터페이스

인터페이스는 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할이다.

즉 구현 객체가 같은 동작을 한다는 것을 보장하기 위한 목적이다.

위의 추상 클래스에서 예제처럼 "젖을 먹인다"라는 행위(메서드)를 사자, 원숭이, 고래 클래스가 한다고 
보장하기 위한 목적으로 한다면 인터페이스로 "젖을 먹인다"라는 메서드를 만들어서 해당 객체들이 구현할 수 있다.

판단을 잘해서 써야한다.

또 다른 차이점은 클래스가 아니기 때문에 인터페이스는 다중 상속이 가능하다.

interface도 is-a관계다.

Thread는 runnable이다. 라고 했을 때 인터페이스도 상속이니 is-a관계로 볼 수 있다.

Inheritance (IS-A) vs. Composition (HAS-A) Relationship 으로 상속과 관련되면 is-a로보고 멤버 변수로 사용되면 has-a로 본다. 

* 차이점을 말할 때 다중 상속이 되냐 안되냐는 포인트가 아니다. 목적이 다르다는게 포인트다.

* 참고로 has-a 관계는 어떤 클래스의 멤버 변수로 가지고 있을 수 있으면 뭐든 has-a 관계인 것 같다.
```

# 상속과 구현의 차이점 과 특징 및 장단점

1. 상속 : is-a 관계(태생부터 무엇인가 기질을 타고 난 경우)

2. (인터페이스)구현 : can-do 관계(후천적인 형질)
* 장점 : 코드의 중복이 없음, 메소드 오버라이드를 통한 확장, 인터페이스 공유를 통한 다형성 구현
* 단점 : 다중상속을 통한 복잡성 증가(다이아몬드 형태)





# 객체지향
* 나(추상화) -> 옆(캡슐화; 클래스 다수) -> 밑(상속성, 다형성)  

```java
1. 추상화

 추상화라고 하는 것은 객체들의 공통적인 특징(속성 과 기능)을 뽑아내는 것이다.
 즉, 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
 추상화는 절차지향 프로그래밍에서도 있어왔다. 대표적인 것이 구조체와 같은 사용자 데이터형이다.
 이것은 데이터를 추상화해서 하나의 새로운 데이터 유형을 만드는 것이다. 예를들어 struct와 같은 구조체가 있다.
 하나의 새로운 데이터형을 정의하는 데 그 안에는 여러개의 부속데이터를 둘 수 있다. 이 때 그 데이터를 추상화를 통해 정의한 것이다.


 
2. 캡슐화
 객체지향에서 캡슐화는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다.
 특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다.
 객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는 것이다.
 또한, 이러한 특징은 다른 의미로 사용되기도 한다. 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로 사용할 때 캡슐화라는 용어를 사용한다. 즉, 데이터를 기능이라는 캡슐로 보호한다는 것이다.


3. 상속성
 상속이 없으면 객체지향은 절차지향과 별 다른 바가 없다.
 상속이란 특징을 가지면서 객체지향 언어가 절차지향 언어의 비해 문법의 규모가 2배이상 늘어났다.
 상속이란 상위개념의 특징을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 가지고 있는 특징(데이터와 함수)들을 그대로 다른 클래스가 물려주고자 할 때 상속성의 특징을 사용한다.


4. 다형성
 가장 까다롭고 이해하기 어려운 특징으로 잘 이해하고 활용한다면 객체지향 언어를 제대로 쓰는 것으로 봐도 무방할 정도이다.
 다형성의 의미는 약간 다른 방법으로 일을 하는 함수를 동일한 이름으로 호출해 주는 것을 말한다.
```

## 설계
* 패키지 -> 클래스 -> DTO -> Control ->  DAO -> Service -> Main
