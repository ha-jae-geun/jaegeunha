# 데이터 타입
```java
컴퓨터 메모리에는 비트의 패턴이 저장된다. 이것이 무엇을 의미할지는 순전히 어떻게 쓰여질지에 따라 달려있다.

 
이렇게 어떻게 쓰일지를 결정하는게 바로 데이터 타입이다.


Data Type

데이터가 어떻게 표현되고 사용될지를 결정한다.
데이터 타입에 따라 컴퓨터가 어떻게 데이터를 다룰지 알 수 있다.
컴퓨터에 저장된 모든 값은 데이터타입에 의해서 표현될 수 있다.
- 자바는 데이터를 표현하기 위한 가장 기본적인 몇가지 내장된 데이터 타입을 가지고 있다.


이것을 primitive data type라고 한다. 자바는 8개의 primitive 데이터 타입을 가지고 있다.


[ byte, short, int, long, float, double, char, boolean ]
 

같이 비트로 저장되어 있는 데이터 일지라도 데이터타입의 의해서 다시 해석되어 사용될때 표현이 달라질수 있다는 점을

명심해야한다.


```

# 변수란
```java
우리가 변수를 사용하기 위해서는 변수를 우선 선언을 하고 나서 사용을 해야만 한다.

변수를 선언한다는 것은 메모리 공간에 데이터타입에 맞는 저장 공간이 확보되어 사용할 준비가 되는 것입니다.

변수를 선언할 때에는 우리가 사용하고자 하는 용도에 맞게 변수의 데이터타입을 지정해 줘야되는데

데이터타입에는 크게 두가지 분류로 나누어 볼수 있다.

 
⑴ java Compiler가 지원하는 데이터타입 8가지

⑵ User defined types의 데이터타입

쉽게 기억하자면 기본적으로 지원하는 8가지를 제외하고는 모두 사용자들이 만들어 내는 데이터타입이다 보시면 됩니다.


그럼 저 데이터타입을 가지고 어떻게 변수를 선언하는지 보도록 하자.

기본 데이터타입을 분류해 보면 논리형, 문자형, 정수형, 실수형 으로 나누어 볼수 있다.

```




# Value 타입과 Reference 타입
 ```java
 □값 형식(Value Type)

먼저 기본 자료형(string을 제외한)과 사용자 정의 구조체의 변수는 값 형식이며 스택에 저장됩니다.

ex) int x  = 10; // 변수 x는 스택에 저장.

값 형식으로 저장된 변수들은 범위 밖을 나가면 스택에서 제거됩니다.

 

□참조 형식(Reference Type)

이번엔 참조형식인데 인스턴스 변수(클래스,배열)들은 참조 형식이며 힙 영역에 저장됩니다.

 

ex) Student stu = new Student();    // 인스턴스 변수 stu는 힙 영역에 저장.

 

참조 형식으로 저장된 변수들은 C#에서 효율적인 메모리 관리를 위해 가비지 컬렉터란 것이 소멸 되는 시점을 판단하여 객체를 수거해갑니다.

 

이 두개의 차이점은 엑세스에 있는데요. 값 형식은 효율적이지만 
수명이 제한되어 서로 다른 클래스 간에 데이터를 공유하는 데 적합하지 않고, 

참조 형식은 다른 클래스에서 엑세스하는데 적합하지만 오버헤드가 커진다는 단점이 있습니다.
 ```
 
 
 # String 타입이 아닌 Char 타입을 쓰는 이유
 * char은 (는) 한 문자입니다. String이 (가) 0 자 이상입니다.
* char은 기본 유형입니다. String은 (는) 클래스입니다.
 
 
 
 
 # char 배열과 String 배열의 차이
 ```java
 예외적으로 char배열은 println메서드로 출력하면 각 요소가 구분자없이 그대로 출력되는데, 
 이것은 println메서드가 char배열일 때만 이렇게 동작하도록 작성되었기 때문이다.

for문 대신 System클래스의 arraycopy()를 사용하면 보다 간단하고 빠르게 배열을 복사할 수 있다.


 
자바에서 char배열이 아닌 String클래스를 이용해서 문자열을 처리하는 이유는 
String클래스가 char배열에 여러 가지 기능을 추가하여 확장한 것이기 때문이다.
char배열과 String클래스의 한 가지 중요한 차이는, String객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다. 
(변경 가능한 문자열을 다루려면, StringBuffer 클래스를 사용하면 된다.)
 ```
 
 
 
 # equals와 ==의 차이
* equals () 는 메소드 입니다. 객체끼리 내용을 비교할 수 있도록 합니다.
* == 은 비교를 위한 연산자 입니다.
```java
equals 메소드는 비교하고자 하는 대상의 내용 자체를 비교하지만,

== 연산자는 비교하고자 하는 대상의 주소값을 비교합니다.

주소값이라는 것은 확실하게 집주소나 이메일주소처럼 확정적으로 정해져서 보여지는 것은 아니지만

대상을 구별할 수 있게하는 값이라고 알아두시면 됩니다.

이는 Call By Reference, Call By Value에 대한 공부를 하시면 이해할 수 있는 부분입니다.

 
CBV(Call By Value. 이하 CBV) 는 기본적으로 대상에 주소값을 가지지 않는 것으로 
값을 할당받는 형태로 사용됩니다. 예를 들어 int, float, double, byte 등 primitive type에 해당됩니다.


CBR(Call By Reference. 이하 CBR) 는 대상을 선언했을 때, 주소값이 부여됩니다.

그래서 어떠한 객체를 불러왔을 때는 그 주소값을 불러온다고 봅니다.

Class, Object(객체)가 CBR에 해당됩니다.


예를 들어, String 클래스를 이용해 문자열을 생성해보겠습니다.

 

String a = "aaa";

String b = a;

String c = new String ("aaa");

 

a, b, c 모두 "aaa" 라는 내용을 가지고 있지만 주소값에 대해서는 다른 값을 가지는 변수가 존재합니다. 
세 문자열이 주소값을 할당받는 내용을 그림으로 표현해보았습니다.

회색 테두리가 문자열 변수 a, b, c를 표현한 내용입니다.

그림에서는 a, b, c 모두 같은 aaa라는 문자열 내용을 가지고 있지만, a, b는 500이라는 임의의 주소값을 할당 받았으며, 
c는 600이라는 임의의 주소값을 할당받았습니다.



내용은 같지만 c가 다른 주소값을 할당받은 이유는 "aaa" 라는 문자열을 대입한 것이 아니라 
new String ("aaa") 를 통해 새로운 문자열을 선언하였기 때문입니다. 
```
