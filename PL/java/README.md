# JAVA
## JAVA 개발을 위한 tool JDK

# 구성맴버
- 클래스의 구성 멤버 - 필드/생성자/메서드

# 라이브러리
- rt.jar


# 인스턴스
- 참조 자료형은 메모리상에 인스턴스(객체라고 하면 오브젝트와 헷갈림)가 있는 주소를 저장한다.
- 객체이기도 하고 힙에 저장 되어있기에 인스턴스라고 한다. 인스턴스로 저장되는 이유는 생명주기가 길어 일정하게 정보를 유지할 수 있다.
- 인스턴스화: 영어 단어인 의 사전적 의미는 예시하다 등이 있으며 여기에서는 인스턴스화라는 instantiate 의미가 된다. new 키워드를 사용하여 생성하고 생성된 인스턴스화된 오브젝트는 힙에 저장이 된다.
- A a = new A()
- A a // 사실상 이거는 스택에 공간 할당 위한 것
- new A() 가 인스턴스화 객체를 만든 것.


# 프로퍼티
- 영어 단어인 의 사전적 의미는 소유물 등이 있으며 여기에서는 속성이라는 의미가 된다 property . 자바의 속성은 직접 호출하지 못하고 메소드로 호출해서 변경해야 한다. 속성은 private 접근 제한자로 선언한 멤버변수를 멤버변수 자신을 가리키는 this 키워드로 접근하여 변경한다. 

# 생성자
- 영어 단어인 constructor의 사전적 의미는 제작자 등이 있으며 여기에서는 생성자라는 의미가 된다. 생성자는 클래스인 오브젝트를 초기화하여 오브젝트가 인스턴스화되는 시점에서 호출된다. 
- 역할은 초기화; 파이썬에서는 초기화라 부름 

# 캡슐화
- 영어 단어인 의 사전적 의미는 캡슐에 넣음 등이 있으며 여기에서는 캡슐화라는 Encapsulation 의미가 된다. 캡슐화는 특정 인스턴스 변수를 오브젝트 내에서만 적용할 수 있도록 정의하여 외부 접근을 허용하지 않는 것이다. 자바에서는 인스턴스 변수에 private 접근 제한자를 선언하여 캡슐화한다. 캡슐화된 인스턴스 변수는 메소드에 의해서만 호출이나 변경이 가능하다.
- 멤버 변수들의 집합이다.  멤버 변수 앞에 접근 제한자 private를 붙여 메소드에 의해서만 호출이나 변경을 가능하게 한다.
- 1. # 커맨드(DB와 연동 안함)  2. # DTO(데이터 베이스와 연동) 3. # VO(DB와 연결하지만 get-set만 사용)
- 접근법: 1. 생성자 2. get-set 3. toString


# 추상화
- 영어 단어인 abstraction의 사전적 의미는 관념 등이 있으며 여기에서는 추상화라는 의미가 된다. 추상하는 복잡한 상속을 통한 오브젝트의 속성의 결합은 반드시 현실 세계를 모의 실험을 할 수 있어야 한다는 것이다.

# 메소드
- 영어 단어인 의 사전적 의미는 방법 등이 있으며 여기에서는 기능이라는 의미가 된다 method . 메소드는 오브젝트에 의해서 접근하여 퍼렌씨시스 안의 매개변수를 통해서 인스턴스의 ( )( ) 값을 전달하고 호출한다. 

# 필드
- 매개 변수를 필드라 부르기도 하며 클래스 안의  멤버 변수 등도 필드라 한다.

# 상속
- 영어 단어인 inheritance의 사전적 의미는 상속 등이 있으며 여기에서는 상속이라는 의미가 된다. 상속은 부모 클래스에 의해서 자식 클래스로 생성하는 방법으로 일반적으로 메소드를 사용한다.
- 상속 받았다고 하면 대다수 메소드를 상속받은 것이다.

# 다형성
- 영어 단어인 의 사전적 의미는 동질 이상 등이 있으며 여기에서는 다형성이라는 polymorphism 의미가 된다. 화학에서 동질 이상은 화학 조성이 같은 물질이지만 다른 결정 구조를 갖는 것을 의미하는 것과 같이 프로그래밍에서의 다형성은 오브젝트들이 같은 메소드를 정의하지만 구현하는 방법이 다른 것을 말한다. 
- 상속에 의해서 이루어짐.


# OOP
* [OOP]('http://woowabros.github.io/study/2016/07/07/think_object_oriented.html')
* 메세지가 객체를 정한다.
  ^messages decide to create object // message first

## OOP 설계 원칙(SOLID)

### SRP(The Single Responsibility Principle); 단일 책임 원칙
* 한 클래스는 하나의 역할만 맡는다. 
* Responsibility: Method
* 어떤 클래스(메소드, 컴포넌트)가 변경되는 이유는 유일해야 한다.

### OCP(Open Close) 개방-폐쇄 원칙
* 확장에 대해 열려있고 수정에 대해 닫혀있다.
  - 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
  - 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
* interface, protocol, standard, HTTP 표준을 rendering 하는 각종 browser 들
* 운전자 -> 자동차 -> 마티즈/소나타(사용자는 마티즈, 소나타를 볼 수 없다.)
* 자바 애플리 케이션 <> JDBC 인터페이스 <> JDBC 드라이버(오라클, MySQL, MS-SQL)

### LSP(Liskov Substitution); 리스코프 교체 원칙
* 이미 언어 상에서 구현되어 있음
* 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 
* 기반 클래스의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
  서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다.
  펭귄은 동물의 한 종류이다.(상속)
* 상위 분류는 하위분류의 종류여야 한다. 하위타입은 그것의 기반 타입에 대해 치환 가능해야 한다.
* 구현 클래스는 인터페이스가 될 수 있어야 한다.
  펭귄은 날 수 있어야 한다.(인터페이스)
  Base Class의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
* 위키피디아 논문: 하위형에서 선행 조건은 강화될 수 없다.
  하위형에서 후행 조건은 약화될 수 없다.
  하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

### ISP(Interface Segregation); 인터페이스 격리 원칙
* 클라이언트는 자신이 쓰지 않는 인터페이스에 의존하지 않는다.(그러니 인터페이스를 더 작게 나눈다.)
* 로버트 마틴: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

### DIP(Dependency Inversion); 의존 관계 역전 원칙
* 상위 수준 모듈이 하위 수준 모듈에 의존하면 안 된다.
* 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙
* 로버트 마틴: 자주 변경되는 구체 클래스에 의존하지 말아야 한다.
* 자동차 -> 타이어(인터페이스) > 스노우타이어


# java
## 도스
* 관리자 명령어 
* cd .., cd  2. md 3. C:, D:  4. dir
* 디렉터리명 특정 디렉터리로 이동한다 cd : . 
* 상위 디렉터리로 이동한다 cd.. : .       
* 최상위 디렉터리로 이동한다 cd/ : . 
* del

## 번역기
* # 번역기 종류: 컴파일/인터프리터
* # 컴파일: 문법에 맞는지 확인
* # 인터프리터; 문법에 관계없이 확인(종료 없이 일단 수행 후 알려줌) -> 예외처리


# 자바 설치
## (1) Java SE; 웹과 연동 안됨
* Java SE Development Kit 8 Downloads
* Windows X86: 32비트
  * 는 의 약자로 일반적인 프로그램 개발을 위한 플랫폼이다 SE Java Standard Edition Java . 는 자바로 프로그래밍을 할 때 가장 기본적이고 핵심적인 패키지들이 포함되어 있다 Java SE . 는 웹 프로그래밍이나 모바일 프로그래밍을 할 때도 기본적으로 사용된다 Java SE . 를 이용하면 데스크톱에서 실행할 수 있는 어플리케이션 개발이 가능하지만 최근에는Java SE 인터넷이 연결되지 않은 프로그램이나 모바일용이 아닌 프로그래밍은 자바로는 거의 개발이 되지 않고 있는 추세이다. 

## (2) Java EE; 브라우저 연동; 많은 사전들이 들어있어 보통 SE를 받고 필요한 사전을 다운받는 방식을 사용; SE를 깔고 라이브러리로 이용 가능; 포트 충돌도 일으킬 수 있음
  * 는 의 약자로 엔터 프라이즈급 개발을 위한 플랫폼이다 EE Java Enteprise Edition . 는 엔터프라이즈 기반 어플리케이션으로 웹 어플리케이션에서 서버 측 프로그램을Java EE 위한 다양한 가 지원된다 API . 는 미들웨어 서버에서 제공하는 각종 기능에 대한 라이브러리를 제공한다 Java EE . 는 엔터프라이즈 웹 어플리케이션을 개발하기 위한 완벽한 를 제공한다 Java EE APl . 

## (3) Java ME; 테블릿 같은 모바일
  * 는 의 약자로 모바일 플랫폼 등 ME Java Mico Edition 임베디드 시스템용 개발을 위한 플랫폼이다. 는 모바일 및 임베디드 기반 어플리케이션으로 스마트폰이나 모바일 기기 등 소형기기를Java ME 지원한다. 는 와 에 대한 호환성이 제공된다 Java ME Java SE Java EE 

# JDK 설치의 의미 
* JDK 를 설치한다는 것은 자바에서 컴파일러를 설치한다는 의미다 JDK . 프로그래밍을 위해서는 기본적으로 가 필요하다 Java JavaSE . 는 다른 말로 으로 불린다 JavaSE JRE . 는 의 약자로 자바 실행 환경이다 JRE Java Runtime Environment .
* 나중에 Program files 경로에 빈칸 없애는 기능 있음


## 디렉터리의 기능 
* 디렉터리 bin ⎼자바 개발에서 실행하는데 필요한 도구와 유틸리티가 있다; begin의 약자라고 생각하면 쉬움(즉 실행시켜주는 파일)
* 디렉터리 db ⎼데이터 관련 도구와 유틸리티가 있다. 
* 디렉터리 include ⎼네이티브 코드 프로그래밍에 필요한 헤더 파일이 있다. 
⎼네이티브 코드는 와 운영체제가 직접 실행할 수 있는 코드를 의미한다 CPU . 
* 디렉터리 jre ⎼자바 런타임 환경으로 클래스 라이브러리 등의 실행에 필요한 파일이 있다 JVM, 
* 디렉터리 lib ⎼ 의 기본 라이브러리 외에 추가 라이브러리와 개발 도구에서 필요한 여러 파일이 있다 


# 클래스 파일
- java는 그냥 읽어오는 것; 클래스 파일을 찾기 위한 과정; 실행하는 것은 class 파일; javac __.java; class 파일 나오고 .java 파일 삭제해도 실행됨.
- 자바는 클래스 파일로 생성되는데 이를 자바코드로 인식하게 하는 것이 소스코드; java 이름

##  CLASSPATH 설정
* 변수 이름인 는 실행 시에 클래스 파일의 위치와 참조 파일들의 위치 지정한다 CLASSPATH . 에는 등의 도구 본채가 있으므로 를 설정하면 어디에서나 tools.jar javac.exe JDK CLASSPATH 클래스 파일을 실행시킬 수 있다. 이상 버전에서는 를 설정하지 않아도 되지만 이하 버전에서는 개발의 JDK 7 CLASSPATH JDK 6 편리성을 위해서 를 반드시 설정해야 한다 CLASSPATH .
* 라. 환경 변수의 등록 확인 환경 변수 설정 후에는 명령 프롬프트에서 으로 자바의 컴파일 버전을 확인한다 javac -version . 자바의 버전이 출력되면 환경 변수 설정이 제대로 되었다는 의미가 된다. 자바 버전이 출력되지 않고 은는 내부 또는 외부 명령으로 실행할 수 있는 프로그램 또는 javac ( ) 배치 파일이 아닙니다 라고 나오면 환경 설정이 제대로 되지 않았으므로 환경 변수 설정을 수정한다 . . 새로운 환경 변수를 수정하고 나면은 기존에 실행한 명령 프롬프트는 종료하고 반드시 새로운 명령 프롬프트에서 확인을 해야 한다. 새로운 명령 프롬프트가 아니면 환경 변수에서 수정한 내용을 인식하지 않는다. 환경 변수 설정 후에 도스 명령어가 실행되지 않으면 에 를 path %SystemRoot%\system32 추가 해주면 된다.
* CLASSPATH 설정 변수값을설정할때주의할점은 설정할 때 도트 기호 부분을 .( ) 명확하게 해 주어야 한다. 도트 기호는 컴퓨터의 자신을 가리킨다.

## Path
 * Path Path . 일반적으로 프로그램의 실행 디렉터리의 이름은 의 약자인 으로 되어 있다 binary bin . 변수 값을 뒤에 추가를 해 주면 끝에 세미콜론 이 없다면 세미콜론 을 추가한다 
 * * 설정 AVA_HOME 변수인 은 JAVA_HOME 자바의 홈 디렉터리로 자바가 설치된 경로를 의미한다.
 * Path 설정 는실행 디렉터리의 위치를Path 지정한다. 자바의 디렉터리가 위치한 bin 경로이다.
 * 자바의 bin
 * 시스템 변수에 C:\Program Files\Java\jdk1.8.0_202\bin  를 추가함으로 인해 자바 소스코드를 자바 폴더안에만 넣을 필요가 없음
 * 시스템 변수 PATH에 넣기
 *  혹은 시스템 변수 새로 만들기 - 변수 이름 지정(JAVA_HOME)/경로 넣기
 *   C:\Program Files\Java\jdk1.8.0_202;  버전 바뀌면 자바 홈만 변경
 * %JAVA_HOME%\bin             
 * 윈도우 7이엇으면 ;
* javac -version: 으로 확인; 명령 프롬프트를 재실행 해주어야 함.
* java -version: 자바 안의 프로그램 구조


# java 특징
* appliance -> support all OS
* oop + 
* JVM
* 다중 상속을 지원하지 않는다.  
  ^don't support multi inheritance
* no pointer
 * 다. 안전하다. 자바는 분산 환경에서 실행될 수 있도록 개발 환경과 실행 환경이 분리되어 있다. 자바 가상 머신인 은 의 약자이며 무결성에 대한 필수적인 검사를 JVM Java Virtual Machine 수행한다.
 * 라. 견고하다. 자바는 다양한 컴퓨터에서 실행되어야 하므로 높은 신뢰성이 요구되므로 견고하다. 엄격한 자료형의 검사를 지원하며 프로그램 실행할 때에 오류가 발생하면 예외로 처리한다.
 * 구조에 중립적이고 이식성이 높다. 자바는 에서 실행되는 바이트 코드를 사용함으로 특정 컴퓨터에 종속되지 않는다 JVM . 자바는 한번 작성되면 이 설치된 모든 종류의 컴퓨터에서 실행할 수 있다 JVM . 자바는 언어의 문법뿐만 아니라 시스템 종속적인 부분까지도 시스템 구조에 대하여 중립적으로 설계되어 있어 높은 이식성을 제공한다.
 * 바. 높은 성능을 가지고 있다. 자바가 지원하는 바이트 코드는 인터프리터에 의해 효율적으로 수행될 수 있도록 설계되다. 자바 번역기는 바이트 코드 생성 시에 자동 레지스터 할당과 최적화를 수행하여 효율적인 바이트 코드를 생성한다. 실행의 효율성을 제공하기 위해 컴파일러를 제공한다 JIT . 는 의 약자이며 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 JIT Just In Iime Compiler 컴파일 하는 방식이다. 
 * 사. 멀티스레드를 지원한다. 자바는 동시에 수행하여야 하는 작업들을 스레드 기술할 수 있으며 스레드의 편리한 사용을 위한 라이브러리를 제공한다. 하나의 프로그램에서 여러 개의 스레드가 병렬적으로 수행되기 때문에 프로그램이 효율적으로 실행될 수 있다. 서블릿에서도 클라이언트의 요청에 대해서 하나하나를 스레드 단위로 처리해 주기 때문에 성능이 우수하다. 
 * 아. 플랫폼에 독립적이다. 플랫폼에 상관없이 한번 작성되어 컴파일 된 파일은 어떤 플랫폼에서도 동일하게 실행된다  
 * 자. 동적이다. 자바는 변화하는 환경에 적응되도록 설계된 언어로서 기존의 프로그램에 영향을 주지 않고 라이브러리에 새로운 메소드나 속성들을 추가할 수 있다. 프로그래밍 실행시에 프로그램 실행에 필요한 라이브러리들을 연결하는 기능을 제공한다. 
 * 차. 보안이 강하다. 자바는 네트워크 프로그래밍을 수행할 때 외부에서의 데이터 접근을 허용하지 않는다. 자바는 어플리케이션 구조나 데이터에 접근하지 못하게 할 수 있다.
 * 카. 분산 환경에 적합하다. 자바는 네트워크 또는 인터넷을 통하여 효율적으로 수행될 수 있도록 설계되었다. 자바는 프로토콜 등과 연관된 라이브러리를 제공한다 HTTP, FTP . 
 * 타. 가 적용된다 RTTI . 는 의 약자이다 RTTI Run Time Type Information . 는 다형성에 나오는 개념으로 호출하는 메소드 결정을 런타임 시에 결정하므로 다형성을RTTI 사용할 수 있다. 
 * 파. 인터프리터에 의해 실행된다. 자바는 컴파일과 인터프리터를 동시에 수행하는 독특한 실행 방식으로 실행된다.


# JDK 8의 주요 특징 
 * Lambda Expression ⎼ 은 함수형 프로그래밍이다 Lambda Expression . ⎼클래스를 사용하지 않고 메소드 정의 수준으로 인자로 전달할 로직을 표현할 수 있는 표기법을 람다식 또는 람다표현이라고 말하며 익명 메소드라고도 부른다. ⎼람다식으로 표현된 로직은 함수형 인터페이스로 자동으로 변환한다. 
 * 함수형; 즉 프로토타입 기반: 복제를 통한 프로그래밍(자바의 인터페이스)을 위함(파이썬의 장점 좆음)
 * 속도가 굉장히 빨라짐(하지만 11까지 나온 지금 파이썬에게 밀림)

# 기반
* 프로토타입 기반: 복제를 통한 프로그래밍(자바의 인터페이스)
* 클래스 기반: 상속을 통한 프로그래밍


# import; 패키지명.클래스명
* import 키워드는 패키지의 클래스를 사용하기 위하여 선언한다. 임포트를 사용하게 되면 패키지가 서로 달라도 접근이 가능하다. 중에서 패키지는 최상위 패키지이므로 임포트하지 않아도 패키지의 클래스를 API java.lang 사용할 수 있는 유일한 패키지이다. 임포트의 선언은 클래스 선언보다 먼저 선언되어야 한다. 패키지를 선언할 경우에는 패키지 선언 다음에 임포트의 선언을 해야한다. 클래스명 대신에 모든 클래스를 의미하는 아스테리스크 기호를 사용할 수도 있지만 가독성이 ( ) 떨어지므로 권장하지 않는다.  모두 다 찾아와서 속도를 늦춰 권장하지 않는다.
 * java.lang에 있는 것들은 import 필요 없음
 * java.util 은 다른 사람들이 만든 것을 공유해 주는 것


# class
* 영어 단어인 의 사전적 의미는 학급 등과 같이 여러가지가 있으며 여기에서는 부류라는 class 의미가 된다. 품사는 단어를 기능 형태 의미에 따라 나눈 갈래인데 영어로는 라고 한다 , , word class . 에서의 를 가져다가 적용한 것이 word class class class 키워드라고 생각하면 된다. class 키워드는 클래스를 선언하며 클래스명 앞에 선언하며 소문자로 작성해야 한다.

# main 키워드
* 영어 단어인 main의 사전적 의미는 중요한 등과 같이 여러가지가 있으며 여기에서는 주된이라는 의미가 된다. 
* main 키워드는 메소드의 이름이며 main 메소드는 자동으로 실행하는 특수한 메소드이다. main 메소드는 프로그램의 시작점으로 자동 실행되어 나머지 필요한 메소드를 호출하여 실행한다. 일반적인 메소드는 호출되어야 실행되지만 main 메소드는 호출되지 않아도 실행될 수 있는 유일한 메소드이다. 
* 자바 프로그램은 main 메소드 내에서 클래스의 인스턴스를 생성 한 다음에 그 인스턴스에 메시지를 보내어 원하는 결과를 얻는다.
* main 메소드의 매개변수인 String[ ] args는 프로그램 실행시에 초기값을 전달한다.

# print
* print 메소드는 동기화가 되지 않고 출력한다.  println . 메소드는 동기화가 되어 출력한다
1. 공간을 만든다, 주소 생성(절대, 상대)
2. 패키지는 충돌을 방지
3. 사람이 소수일 땐 print(속도가 빠름), 많을 땐 println

# printf
 * System.out.printf("%5c", 'A');  // 5칸 띄어서 출력
 *  가운데 ,는 연결 자료형


# static
 * 영어 단어인 의 사전적 의미는 정지 상태 등과 같이 여러가지가 있으며 여기에서는 공유라는 static 의미가 된다. 
 * static 키워드는 new 키워드로 인스턴스를 생성하지 않고도 main 메소드를 실행시킬 수 있다. 
 * static 키워드로 지정된 멤버변수나 메소드는 메모리에서 같은 주소를 계속해서 사용한다. 
 * static 키워드를 사용하면 메모리에 제일 먼저 전달이 되므로 main 메소드 앞에 지정해야 한다. 
 * static 멤버변수나 메소드에 의해 호출이 되면은 클래스를 초기화 할 때에 맨 처음으로 메모리에 적재된다.
- static 안달면 스택에 직접 접근할 수 있는 방법이 사라져 Class에서 불러올 경우 new 로 힙으로 당긴 후 값을 가져와야 한다.

# 패키지 만들기
 * 디렉토리 만들기: javac -d . PackageCall.java; 이러면 import 안의 경로로 class가 들어감;  d는 패키지 선언
 * java 민.내가만든.패키지관련.PackageCall;  명령 프롬프트에서 이렇게 실행


# 이클립스
 * https://www.eclipse.org/downloads/
 * 자바 버전에 맞게 다운 받기
 * 자바는 힙 크기 조절해 주어야 함(new 사용이 많음)
 * OpenPerspective 자바 변경

## 이클립스 설정
 * eclipse 설정 클릭
 * -Dfile.encoding=UTF-8

## 이클립스 단축키
 * Ctrl + I : 들여쓰기 자동 수정
 * Ctrl + Shift + O : 자동 import 
 * Ctrl + Shift + L    단축키 표시
 * Ctrl + Shift + F 줄정렬
 * Ctrl + / 주석처리
 
# 컴파일
 * 자바의 컴파일 과정은 간단하다. 개발자가 작성한 자바 코드(.java)를 컴파일러가 기계어인 자바 바이트 코드(.class)로 변환시켜 주고, 변환된 코드를 인터프리터가 한줄씩 실행시키면서 애플리케이션을 실행하게 된다.
 
# 클래스 파일
 * 자바 소스는 에서 실행될 수 있는 기계어인 바이트 코드로 번역되며 번역된 바이트 코드는 JVM 바이트 코드 해석기가 있는 어떠한 기종의 컴퓨터 환경에서도 실행될 수 있다. 


# 힙
 * 자바는 힙 크기 조절해 주어야 함(new 사용이 많음)
- 힙은 개발자가 관리하는 가상 메모리
- 값의 변경이 불가하다.
- 값의 변경이 불가하기 떄문에 중괄호가 없는(return 값 받을 수 없는) 값 생성 의미없음
- 힙에 저장되는 주소: System.out.println(s.hashCode());
    - 눈에 안보이는 힙에 저장되는 주소
  - 누구나 접근 가능하지만 값을 수정할 수는 없다. 누구나 수정할 수 있는 스택과 다르다; 여기서 ‘누구나’는 개발자가 아니라 사용자를 말한다.
- 메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역입니다.
- 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.


# 스택
* 모든 데이터는 스텍으로 구성된다. 여기서 new로 객체 생성하면 힙으로 옮겨진다.
- 모든 데이터가 담기는 곳; 자동으로 소멸
- 스택은 값의 변경이 가능하다
- InputStreamReader inputStreamReader = new InputStreamReader(System.in);
뒤에 있는 힙 값을 변경하기 위해서는 스택에 저장을 해야 함.
* 오브젝트: 스택에 저장
* 스택의 자료를 힙에 저장: new; 힙에 저장됨으로 인해 접근이 가능하다.(파이썬에서는 자동으로 new를 안써도 생성해줌)
* 인스턴스: 힙에 저장됨
- 누구나 수정할 수 있지만 누구나 접근할 수 있는 힙과 다르다. (static 하면 접근 가능); 여기서 ‘누구나’는 개발자가 아니라 사용자를 말한다.

# jar
 * rt.jar; 자바에서 기본 제공하는 단어들
 * 속성 - Java Source Attachment -> external -> C:\Program Files\Java\jdk1.8.0_202\src 열기
 * java.lang -string

# 주소
- 스택에 저장되는 주소:  
- System.out.println(System.identityHashCode(a));
     - 힙에 저장되는 주소: System.out.println(s.hashCode());

## @
- jg.begin.start.jae_0305.B@15db9742; // @ 주소값에 0305 패키지 안의 B 클래스 값이 저장되어 있다.


# 플러그인
 * Eclipse market place - jad 
 *  -> preference-> Editor -> file assosiation -> default -> class deomplier ‘default’ 설정

# 똑똑하게 압축풀기
 * OS마다 길이 제한
 * 한글 사용 오류 가능성

# 동기화
 * print 메소드는 동기화가 되지 않고 출력한다.  println . 메소드는 동기화가 되어 출력한다
 * 사람이 소수일 땐 print(속도가 빠름), 많을 땐 println 

# 실수형
 * 고정; 고정 소수점 방식
 * 가변; 부동 소수점 방식; 컴퓨터가 가지고있는 기능에 맡기겠다.
 * 고정(32비트)
 * 가변(64비트)
-  float f = 1f / 3f;
  -  double f = 1f / 3f;  // 더 정밀도가 있고 double형도 f를 써도 된다.
  - double f = .1f / .3f;  // 0 생략 가능
  - double f = 1.f / .3f; // 1.0f는 1.0이라는 의미다.

# ()
 * 무조건 실행; 타입 검증

# IDE; 통합개발환경
 * 이클립스, 파이참

# static
 * 스택

# UTF
 * UTF-8; 가변적 인코딩 방식; UTF-16; 고정적 인코딩 방식

# 패키지
 * 유사 단어들의 모임
 * 충돌 방지
 * import 보다 먼저 선언되어야 한다.
 * java.으로 시작하면 안된다.(sun에서 독점); javax는 외부개발자들의 패키지를 같이 배포해주는 패키지 명이기에 사용 가능. 하지만 안쓰는게 좋다.
 * 보통 자기 이니셜을 1번에 놓는다. jg.begin.start

# 진수
 * 2진수: 0 b숫자
 * 16진수: 0xB
 * int be = 000111; // 0을 붙이면 8진수로 인식

# char
 * 정수타입: byte, short, int, long, char(자판기; 쓰면 아스키코드로 바뀜)
- 배열의 공백 인식한다.


### varchar
- 배열의 공백 인식 안한다.


# string
 * 클래스형 타입; 클래스도 자료형(타입)이 될 수 있다
 * 특별한 클래스이다; 영역이 틀려도 값만 같으면 같은 클래스로 참조한다.
 * 예시
 * String s = “홍길동”’  // A클래스
 * String d = “홍길동”; // B 클래스
 * System.out.println(System.identityHashCode(); 하면 같은 주소 가짐
 * System.out.println(s.hashcode(); 하면 같은 주소 가짐
 * - new를 안쓰고 쓸 수 있는 참조 래퍼런스
-  이미 만들어진 클래스인 String 클래스는 스택과 힙이 서로 다른 주소 가짐


# 클래스
클래스형 타입; 클래스도 자료형(타입)이 될 수 있다; string; 


# 예약어 = 키워드
 * 미리 만들어 놓은 단어; 식별자로 쓸 수 없음.

# 인코딩
 * A라는 문자가 들어오면 같은 형태의 글꼴로 인식할 수 있도록 코드로 변환해 주는 것
 * 가변적, 고정적 모두 존재
 * UTF-8; 가변적 인코딩 방식; UTF-16; 고정적 인코딩 방식

# 식별자
 * 개발자가 사용하는 단어 <>예약어
 *  변수:  일반적으로 변수의 첫 글자는 소문자로 작성한다. 변수가 두 단어가 합쳐질 경우에는 두 번째 단어의 첫 문자를 대문자로 작성한다.

# _ 
 * 원래의 용도에서 확장 되었다.
 * 저장은 되는데 검색이 안되어 _ 를 사용
 * 출력할 때는 안보이고 _ 없이 검색 가능
 * 밑줄 문자인 언더스코어는 컴퓨터에서 공백 문자를 대신하여 사용하기 위하여 고안된 기호로서 _( ) 아스키 코드 번에 해당한다.
 * ( ) 지금도 프로그램 등에서 변수의 이름처럼 공백을 쓰지 못하는 경우에 공백 문자를 대신하여 사용되고 있다.
 * JDK 7부터 제공하는 언더스코어 JDK 7 ( )로 정수 리터럴 값의 자릿수 구분을 위한 구분자로 사용한다. 



# ‘’
 * 자바에서는 char 표시할 때 ‘’만 쓸 수 있다. 이유는 main 매개변수 string을 보면 this.value = "".value; 라고 표기되어있기 때문이다.

# 공백 문자
 * 저장은 되는데 검색이 안되어 _ 를 사용

# 소스코드
 * 자바 코드를 클래스 파일로 보여주는 것


# UML 
 * http://objectaid.com/

# 브라우저
 * 인터넷을 이용해서 사용자에게 보여주는 그래픽 화면

# 주석
 * 프로그램 실행에도 영향을 주지 않지만 로그에도 남지 않는다.
- 주석문의 용도는 소스 코드에 필요한 추가 정보를 추가해서 가독성을 높이기 위한 방법으로 주로 사용된다. 
- 주석문으로 자바 소스 코드 내에 프로그램 수행에 불필요한 코드를 주석 처리 할 수 있으므로 프로그램 수정에도 활용이 된다. 
중간에 과정 찍은 print 문 주석처리
# 로그
 * 주석은 프로그램 실행에도 영향을 주지 않지만 로그에도 남지 않는다.

# static
_ _ i  // 파이썬


# 자료형
1. 원시 자료형: 직접 접근
 * 수치 타입
 * 정수타입: byte, short, int, long, char(자판기; 쓰면 아스키코드로 바뀜)
 * 기본형은 int 형
 * 부동 소수점: float, double
 * 기본이 double이라 float형은 f 붙여 주어야 함.
 * 불리언 타입
 * 원시 자료형은 크기가 작고 고정적이기 때문에 메모리의 스택에 저장이 된다.
 * 자바에서는 원시 타입을 제외하고는 다 참조다. 하지만 파이썬, R은 다 참조다.(원시타입이 존재하지 않는다.)
 * 2진수, 8진수, 10진수(올림형), 16진수로 표현 가능하고, 정수형 중 음수는 보수를 사용한다
 * char 자료형은 기본적으로 아스키 코드를 기반으로 한 문자 데이터이므로 int 자료형으로 변환을 하면은 아스키 코드인 숫자를 반환한다. 
 * char 자료형은 한글이나 영문 그리고 특수 문자 등의 모든 글자 형태는 동일하게 한 문자씩만 인식하며 비트 유니코드 문자 데이터로 최대 자를 표현할 수 있다 16 65,536 . 
 * char 자료형은 하나의 문자로 유니코드 값을 표현하므로 두 문자를 할당하면 예외가 발생한다.
 *  char 자료형은 반드시 싱글 쿼터를 사용해서 표현하고 더블 쿼터를 사용하면 예외가 발생한다 ‘( ) “( ) . 유니코드는 각 나라별 언어를 모두 표현하기 위해 나온 코드 체계이며 사용중인 운영체제, 프로그램 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다 , .

 2. 참조 자료형(레퍼런스); 간접 접근; 주소값과 실제값으로 나뉘고 유저가 선택한 값을 ‘리터럴’이라고 함; 힙에 저장(자바의 new)
 * 클래스, 인터페이스, 배열, 열거
 * 클래스형 타입; 클래스도 자료형(타입)이 될 수 있다; string; 
      - 항상 자료형의 공간이 만들어지고 그에 값이 들어가면 가비지컬렉션에 의해 처리된다.
      - 참조 자료형은 메모리상에 인스턴스(객체라고 하면 오브젝트와 헷갈림)가 있는 주소를 저장한다. 
      - 참조 자료형은 가변적이고 동적이기 때문에 동적으로 관리되는 임시 기억장치인 힙 영역에 저장이 되며 주소값을 가진다. 
      - 자바에서는 원시 타입을 제외하고는 다 참조다. 하지만 파이썬은 다 참조다.(원시타입이 존재하지 않는다.)


# 배열
- 원시 타입을 메모리에 테이블처럼 저장하는 것
- 참조타입을 저장할 수 있음.
- 리스트, 튜플(인덱스의 크기를 가지고 접근) | 세트 | 딕셔너리(배열의 리터럴 방식을 확장, 특정 내용만 인덱스로 접근하고 나머지는 인덱스로 접근불가) // 배열의 확장
- 목표: 메모리에 저장하고 유지권을 가지고 데이터를 꺼내오기 위함.
- int [][] num;     int num[][];  모두 가능
- 자료형이 다른 것도 배열에 들어갈 수 있다. 대신에 리스트와 다른건 다른 자료형이 들어가면 뭉쳐서 A라고 부르고 리스트는 각각의 타입을 구분한다. 클래스도 하나의 자료형이다. 하지만 클래스 안에 모든 자료형을 넣기 귀찮으니 나온게 리스트다.
- 배열이 쓰이는 이유: 1. 고정적이여서 하나의 요소도 빠지면 안되는 프로그램을 짤 때; ex)  RGB  2. 일정한 값을 가져야 하는 수치적 계산 
- 출력: System.out.println(num); // 주소값 나온다
배열의 빈 값은 0으로 출력된다..
- int[] num = { 1, 2, 3, 4 }; // 중괄호로 배열 사용 가능; 배열의 리터럴; 선언과 초기화 동시
- int[ ] number 스택 ;  
- number = new int 힙  // number는 참조 변수
- 3차원 배열 [면; 엑셀의 시트] [행] [열]
- 동적 배열: 행은 무조건 있어야 함, 열은 생략 가능


## 배열 기호
- 2차원: [ [],1]; 1차원 안에 1차원

## 동적 배열 -1
    - int num[][] = new int[3][2];
    - num[0] = new int[2];  // 행 개수 만큼 선언해 주어야 함; 열은 관련 없음
    - num[1] = new int[2];  // 행 개수 만큼 선언해 주어야 함; 열은 관련 없음
    - num[2] = new int[2];  // 행 개수 만큼 선언해 주어야 함; 열은 관련 없음



## 동적 배열 -2
-     int[][] num = { { 1, 2 }, { 4, 5 }, { 1, 2, 3, 4, 5, 6, 7, 8 } };

### 배열의 for문
- 배열 문;  초기식 인덱스 조건식증감식 ( ; ; ); length 사용

### 향상된 for문 
- for (선언한 배열의 자료형 변수명 배열명 : )
- for (String string : name) { ~ } ⎼
- 향상된 for 문으로 배열명으로 배열을 반복하여 나열한다. 
- 향상된 for 문은 배열의 인덱스를 사용하지 않고 배열명만을 사용하기 때문에 배열의 인덱스를 잘못 사용해서 발생할 수 있는 예외에 대한 위험을 제거 할 수 있다.

#### 향상된 for문 예제 -1
-     for (int[] is : num) {
-       for (int is2 : is) {  // 위의 배열이 아래 값으로 들어옴
-         System.out.println(is2);
-       }
-     }



## 2차원 배열
- for (int j = 0; j < num[i].length; j++); // 열의 길이 구하는 법


### 2차원 배열 구구단 예제
 * public class GugudanArray {
 * public static void main(String[] args) {
 *  //2차원 구구단 배열 선언
 *  int[][] gugudan = new int[10][9];
 *   //첫번째 행의 배열에 단을 입력할 수 넣기
 *  for (int k = 0; k < 9; k++) {
 *   gugudan[0][k] = k + 1;
 *  }
 *   //2번쨰 행부터 구구단 결과값 넣기
 *  for (int i = 1; i < 10; i++) {
 *   for (int j = 0; j < 9; j++) {
 *    gugudan[i][j] = i * (j + 1);
 *   }
 *  }
 *   //구구단 출력
 *  for (int n = 0; n < 10; n++) {
 *   for (int m = 0; m < 9; m++) {
 *    if (gugudan[n][m] > 9) {
 *     //두자리 수는 공백수 하나 적음
 *     System.out.print("  " + gugudan[n][m] + "  ");
 *    } else {
 *    
 *     System.out.print("  " + gugudan[n][m] + "   ");
 *    }
 *   }
 *   if (n == 0) {
 *    //첫번째 단의 수 표시하기 위해서
 *    System.out.println();
 *    System.out.println("--------------------------------------------------");
 *   } else {
 *    //구구단 결과값 표시 9단까지 표시후 줄바꿈
 *    System.out.println();
 *   }
 *  }
 * }
 * }



### 배열 생성의 형태
- ① byte 자료형 : 0 
② short 자료형 : 0 
③ int 자료형 : 0 
④ long 자료형 : 0L 
⑤ float 자료형 : 0.0f 
⑥ double 자료형 : 0.0 
⑦ char 자료형 : '\u0000'  // 키보드의 null을 의미한다.



# 리스트
 - 자료형이 다른 것도 배열에 들어갈 수 있다. 대신에 리스트와 다른건 다른 자료형이 들어가면 뭉쳐서 A라고 부르고 리스트는 각각의 타입을 구분한다. 클래스도 하나의 자료형이다. 하지만 클래스 안에 모든 자료형을 넣기 귀찮으니 나온게 리스트다.

## ArrayList
- 출력하면 비어있는 값은 출력 안하고 출력되지도 않는다. -> 가변적이다.
- B b = new B(); 같이 클래스를 추가하면 주소값으로 들어가고 나중에 실제값으로 바꾸면 값을 표현할 수 있다.


# 컬렉션
- 참조타입을 메모리에 테이블처럼 저장하는 것
- 원시타입을 저장할 수 있음.

# 자료형 변환
 * System.out.println("한글" + (int) eword); // 아스키 코드값

# 리터럴
 * 참조 자료형(레퍼런스); 간접 접근; 주소값과 실제값으로 나뉘고 유저가 선택한 값을 ‘리터럴’이라고 함; 힙에 저장(자바의 new)
 * 실제값
* 원시 자료형의 변수는 실제 데이터를 리터럴로 저장한다. 참조 자료형의 변수는 실제 데이터가 저장된 주소로 저장한다. 참조 자료형의 자료값을 주소값이라고 한다.
- int[] num = { 1, 2, 3, 4 }; // 중괄호로 배열 사용 가능; 배열의 리터럴; 선언과 초기화 동시


# 진수
 * 16진수: 2진수로 표현하는 것을 가변적으로 변화; 공간 활용 위해 사용.
 * 8진수: 주로 이미지 표현을 위해 사용함.

# 객체지향
 * 클래스 기반: 힙 만들 때 ‘new’ 사용
 * 자바는 프로토타입 패턴에 의거하여 클래스, 배열, 열거(enum), interface 사용
 * 프로토타입 기반: 힙 만들 때 복제



# 아스키 코드
 * 10번 \n  과 13번 \r이 합쳐지면 엔터
 * 48번 0;  65번 대문자 A
 *   ​char a = (char) System.in.read();
   *  이 함수가 입력되는 것은 0-255까지의 아스키코드 값이므로 char형으로 받고 싶다면 형변환을 하여서 받아야한다.​모든 아스키코드는 char에 담을 수도 있고 데이터의 손실또한 없다는 겁니다.
- int i = System.in.read() - 48; // 사용자가 입력한 숫자로 변환하기 위해 48(0)을 뺌
-   public static void result(int a, char b, int c, int d) {
    - System.out.println("연산 결과");
    - System.out.println(a + b); // 아스키 코드가 더한 값이 나옴




# wrapper
- 참조 자료형은 메모리상에 인스턴스가 있는 주소를 저장하며 주소를 레퍼런스라고도 한다. 참조 자료형의 데이터 크기는 가변적이고 동적이기 때문에 동적으로 관리되는 임시 기억장치인 힙 영역에 저장이 되며 주소값을 가진다. 
- 참조 자료형은 인스턴스에 대한 레퍼런스를 가지고 있으며 매개변수인 값을 전달한다. new 키워드를 이용하여 인스턴스를 생성하여 데이터가 생성된 주소를 참조하는 자료형이다. 참조 자료형에서 더 이상 참조하는 변수가 없을 때는 가비지 컬렉션에 의해 삭제된다. 개의 원시 자료형을 제외한 자료형은 참조 자료형으로 종류는 다음과 같다
- 1. 클래스 자료형 2. 인터페이스 자료형 3. 배열 자료형 4. 열거 자료형

# ()
- 동작한다; 
- 클래스(); // 클래스를 동작한다.

# byte
 * ⎼byte 자료형을 int 형인 i 변수로 강제 자료형 변환을 하고 b 변수에 할당한다. 
 * ⎼int 형의 255, 256, 257은 byte 형의 -1, 0, 1로 변환된다.

# 수행 > 실행
 * 런타임을 ‘수행’했다고 한다. 수행이 더 큰 개념.
 * 실행: 결과를 보여줌

# 자료형 크기
 * byte: 1바이트; 8번째 자리 버리고 -125 - 124
 * short: 16비트; 2의 15승까지 계산 가능
 * int: 2의 31승까지 계산 가능.

#  자료형 변환
 *  크기가 작은 자료형에서 큰 자료형으로 자동으로 변환한다.
 * 묵시적 자료형 변환을 자동 자료형 변환이라고도 한다. 
 * 수치 자료형은 상호간에 묵시적 자료형 변환이 가능하다. 
 * 큰 자료형에서 작은 자료형으로 묵시적 자료형 변환을 하면은 예외가 발생한다.

# 명시적
 * 강제 <> 묵시적
 * ⎼byte 자료형을 int 형인 i 변수로 강제 자료형 변환을 하고 b 변수에 할당한다. 
 * ⎼int 형의 255, 256, 257은 byte 형의 -1, 0, 1로 변환된다.
 1.
 *     int i = 48;  // int를 char로 명시적 변환
 * 
 *     char a;
 *     a = (char) i;
 2.
 *     System.out.println(a);  // 아스키 코드 값 ‘0’으로 출력
 *     byte i;  // byte를 int로 명시적 변환
 * 
 *     int a = 255;
 *     i = (byte) a;
 * 
 *     System.out.println(i); // -1 결과값 출력; 바이트수에 보수 탑재
 3. choice = (char) System.in.read( );  // read할 때 char 좋으니 강제

# []
리스트; 배열

# ()
튜플

# {}
세트

# {키와 값]
딕셔너리

# 변수
 * 변수명 만들어주는 사이트: https://curioustore.com/#!/ 
 * 공간의 위치; 이 위치를 알기 위해 이름을 부여(변수명)
 * 공간의 위치에 따른 변수의 역할
 * 멤버변수(C 언어의 전역변수); 클래스 안의 변수
 * 멤버 변수는 0으로 자동으로 초기화됨; 생성자에 의해 이루어 짐
 * 인스턴스 변수: private int age1 = 9; // 메소드로만 호출 가능(get, set)
 * 프로퍼티; this; 맴버변수 = 매개변수
 *           -     공유 변수 = C 언어의 전역 변수:  static int age2 = 29;
 *         - System.out.println(A.age2);
 *         - main 함수에 직접 접근하려면 static으로 접근하여 
 *   같은 영역을 만들어주어야 한다.
 *                     -     일반 멤버 변수
 * 로컬변수(지역변수); 메소드 안의 변수
 * 초기화 선언이 따로 필요!
 * 블록 안에 있는 것이 보유(유지) 되지 않고 소멸된다.
 * 매개 변수(parameter)
 * 다 소문자; 두개의 명사 붙일 때 _ 사용

## 변수 선언 주의사항
- int i = 10; // 바로 선언하는 건 이 숫자만 사용하겠다는 암묵적 의미
- int i;  먼저 선언하고 나중에 값을 지정하는 것을 권장
  - int i, y; // 변수를 동시에 선언하는 것도 비권장


### 변수 종류 예
- 필드 : 클래스 안에서 선언되는 멤버 변수, 인스턴스 변수라고도 함.
- 지역 변수(local variable) : 메소드나 블록 안에서 선언되는 변수
- 매개변수(parameter) : 메소드 선언에서의 변수

 * class
 * {
 *   public int speed ->필드
 *   ...
 *   void start(int s) ->매개변수
 *   {
 *     int t; ->지역 변수
 *     ...
 *   }
 * }



# null
 * 모든 참조 타입의 기본값;

# http
 * hyper: 뛰어넘다; text: 무작위로 선택할 수 있는 것; 목차에 관계없이 접근


# ; 
 * 영역의 종료

# :
 * 영역의 변경
 * System.out.println("클래스 클래스다.");

# 로컬변수
 * 가. 로컬변수의 개요 로컬변수는 메소드 안에서만 선언한 변수이다. (메소드 만이 아니라 {}(코드 블록) 내에 선언된 변수 
 * 로컬변수는 멤버변수와 같이 선언과 동시에 초기화가 이루어지지 않으므로 자료형의 초기값을 할당해야 한다. 
 * 실행 영역인 코드 블록 내에서 선언된 로컬 변수는 코드 블록의 범위를 벗어나면 자동으로 { }( ) 삭제된다. 

# {} -  
 * 코드 블록 {} 
 * 네임 스페이스; public class A

# scanner
 * import java.util.Scanner;
 * Scanner sc = new Scanner(System.in);
 * 이렇게 객체생성을 하며 System.in은 입력한 값을 바이트 단위로 읽는 것을 뜻합니다.
 * next()라는 메소드가 있는데 이 next() 메소드는 공백 이전까지의 문자열을 입력 받습니다.
 * sc 보다는 scanner; 클래스를 알아보기 위해
 * nextLine() // 라인을 추가한다.(두줄이 띄어져서 잘 안씀 -> next())
 * name = scanner.next(); // 사용자 편의성 위해 변수에 직접 넣어준다.
- - c = input.next().charAt(0); // char 값 가져오기
- 스택에 저장하는 이유: 나중에 값을 int 형 등으로 형 변환 위해
- 엔터(\n  \r)  탑재 되어있음.
  * System.in.skip(2); 를 하면 System.in.read()를 2번 넘어간 것과 같은현상


## CharAt
- c = input.next().charAt(0); // 0인덱스의 값 가져옴


# static
 * 공유: 키워드에 의해서 멤버변수는 전역적인 범위가 될 수가 있다

# 캡슐화 
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다

# 상수 
 * final 키워드에 의해서 멤버변수나 로컬변수는 상수가 된다.

# private
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다
 * get/set 으로 호출

# get/set
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다

# final
 * ① 클래스의 상수 선언 클래스에서 상수의 선언는 final 키워드로 선언한다. 상수는 선언할 때 단 한번 초기화를 하며 상수 앞에 static 키워드를 붙여서 final 키워드로 선언하면 전역적인 상수가 된다. 클래스의 상수는 일반적으로 static final로 선언해서 전역적인 상수 변수를 만들어서 사용하는 경우가 많다.
 * ② 인터페이스의 상수 선언 인터페이스에서 멤버변수를 선언하면 자동으로 상수가 되며 그 이유는 인터페이스에서는 생성자가 없기 때문이다.
 * 클래스에 final 붙이면 상속 불가


# 생성자
② 인터페이스의 상수 선언 인터페이스에서 멤버변수를 선언하면 자동으로 상수가 되며 그 이유는 인터페이스에서는 생성자가 없기 때문이다.
멤버 변수는 0으로 자동으로 초기화됨; 생성자에 의해 이루어 짐


# # read()
 * choice = (char) System.in.read( );  // read할 때 char 좋으니 강제
 *   ​char a = (char) System.in.read();
 *  이 함수가 입력되는 것은 0-255까지의 아스키코드 값이므로 char형으로 받고 싶다면 형변환을 하여서 받아야한다.​모든 아스키코드는 char에 담을 수도 있고 데이터의 손실또한 없다는 겁니다.
 

 *  문
 * 비순차적 문장
 * 머신러닝 같이 데이터 검출을 목표로 할 때는 if 문을 쓰는 것이 맞다. 순차적으로 모두 확인해야 한다.
 * :(영역 변경) 뒤에 {} 생략 가능; 파이썬 방식

# MVC
 * M(Model): 멤버 변수가 모여 있음
 * V(View)
 * C(Control): 유일하게 변경할 수 있음; ex) API

# 연산자
- 단항: a++
- 이항: 5 + 5
- 삼항
- 조건(수식)? A:B  // 와일드 카드
- ?: 플레이스 홀더

##  연산자의 결합 방향
- 오른쪽에서 왼쪽으로 결합 이라는 수식은 오른쪽에서 왼쪽으로 결합하여 연산을 한다 a = b = c . 

# 배열과 리스트 차이
- 배열은 한개의 타입(자료형)만 넣을 수 있음.
- 리스트는 여러 개의 타입(자료형)을 넣을 수 있음.


# instance of
- System.out.println(string instanceof String);
- 외부에서 실제값을 확인하는 것; 객체를 비교하는 것이 아니다.
- 기본값인 ‘null’은  
 * String string = null;  
 * System.out.println(string instanceof String)  // 하면 false
⎼ String 클래스형의 string 로컬변수에 기본값인 null을 할당하고 instanceof 연산자로 비교하면은 할당된 null은 String 클래스형인지를 확인할 수가 없으므로 false를 반환한다. 
- ⎼instanceof 연산자는 참조 자료형에 할당된 자료값에 대한 정확한 자료형을 검증한다.


## 자료형 확인
- System.out.println(string instanceof String);

# ==(더블 이퀄)
- 일반적으로 수를 비교
- 문자열을 비교할 때는 equals 라는 메소드로 비교한다.

# 비교
- ‘==’는 일반적으로 수를 비교
- 문자열을 비교할 때는 equals 라는 메소드로 비교한다.

# 논리 연산자
- 자바에서는 속도 때문에 &&   ||  등 2개 짜리를 권장한다.
- &&는 앞이 거짓이면 뒤 검증 안함, || 도 앞이 참이면 뒤 검증 안함.


## &
- 파이썬에서는  and, or, not 을 논리 연산자로 쓰고  &는 보통 비트 연산자로 사용한다.


## |
 - 버티컬바 |( ) 연산자



# 복합 대입 연산자
- 복합 대입 연산자는 다른 연산자보다 우선순위가 낮아 생각지 못한 결과가 발생할 수 있으므로 유의해야한다. 자주 사용하지 않는다.

# 증감 연산자
- a++ 보다는 a = a+1 을 사용하기를 권장한다.

## ~     - Tilde; 틸드
- ~숫자;  // +1 한 값 앞에 마이너스 기호 붙이기
- 컴퓨터에는 마이너스 개념이 없어서 2의 보수를 통해 표현

## ^
 - 서컴플렉스;  Circumflex 




# 비트 연산자
- 컴퓨터 입장에서 인식이 빨라 정확도와 속도 모두 빠르다. 
- &,  |,  ^,  ~
- 시프트 연산자; <<, >>; C++ 에서 자주 사용
- 더블 레프트 앵글브래킷❷ 연산자로 만큼 이동한 비트의 연산을 하고 이동하여 비어있는 2 8 공간은 0으로 채운다
- 더블 라이트 앵글브래킷 연산자는 4>>2 4/2/2 4 2 누어 주면 되는 것 같이 이동한 숫자만큼 로 나누어준다 2 .
- 컴퓨터에는 마이너스 개념이 없어서 2의 보수를 통해 표현

# 보수
- 각 자리의 숫자의 합이 어느 일정한 수가 되게 하는 수이다.
- 2진수에는 1의 보수와 2의 보수가 있으며 의 보수와 의 보수를 구하면 다음과 같다. 결과를 비교해 보면은 2의 보수는 1의 보수에 1을 더한 것과 같으므로 1의 보수에서 1을 더해주면 의 보수를 구할 수 있다 
- 9의 보수와 10의 보수의 차이는 끝자리에 1을 더했느냐의 차이이다.
- 2의 보수는 그래서 1을 더하고 -을 붙여준다.
- 1의 보수: 모두 1로 맞추는 작업 -> 2의 보수: 1을 더해서 자리 올림을 만들어 그 1을 부호로 만든다. 

# 조건 연산자
int c = (a > b) ? a : b;  이렇게 값을 변수로 지정한다.


# 연결 연산자
- 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)


# +
- 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)


# StringBuffer 클래스
- StringBuffer bu  = new StringBuffer();
      - System.out.println(bu.append(s).append(t));

# 문자열
# StringBuffer 클래스
- StringBuffer bu  = new StringBuffer();
      - System.out.println(bu.append(s).append(t));

      2. - 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)
- 잘 쓰지 않고 StringBuffer를 사용한다.

# “”
- String number = ""; 
- ⎼String 클래스형인 numbe 변수에 아무 값도 할당받지 않은 상태인 빈 문자열 ""를 할당하여 문자열을 저장할 임시 공간을 설정한다. 
- String number = " "; // 공백문자라고 함. 


# 배열
- for 문과 주로 같이 쓰임
- 자바의 배열은 C언어의 포인터 배열
 - 1차원 배열: 일반 for문, 2차원 배열: 중첩 for문 
- 차원이 증가하는 건 1차원이 포함되었다고 표현; 사실상 2차원의 개념은 없다.

# for문
- 일반 for문, 배열 for문, 컬렉션 for 문, 향상된 for문
- 길이를 알고 있을 때; 배열, 리스트
- 메모리에 임시저장 시킬 때 for문
- 목적 달성 전치사
      - 1차원 배열: 일반 for문, 2차원 배열: 중첩 for문 
     - 다중 for문: 중첩 for문을 2개 이상 쓴 것.

## foreach
- for (int i: num)  // num은 배열
System.out.println(i);  // 배열 안의 하나씩 출력됨


## for문 실행 순서
 * for( 식1 ; 조건1 ; 식2)
 * {
 *    코드 1
 * }
 * 정답
 * 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 ...
 * 오답
 * 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 ...

# while 문
- 일반 while문, do-while 문
- 규격에 맞게 학습
- 무한 반복 때 사용.

# break
- 실행이 아니라 수행을 종료
- 블록을 벗어날 수 있다.
- break
  - ForLabel: for (int i = 2; i <= 9; i++) { ~ }
  - break ForLabel;

# return
- 값의 변경이 불가하기 떄문에 중괄호가 없는(return 값 받을 수 없는) 값 생성 의미없음


# if
 * 조건이 거짓이면 실행이 안되는 것이 아니라 default 값 실행.
 * else; 는 뒤에 {} 가 있어도 같이 사용되지 않음.
 * 정렬을 위해 if문이 존재

# 다중 if 문
 * else 에서 범위를 확장 시킬 때 다중 if 구문이라고 한다. <> 중첩 if문
 * else의 조건을 확장시킬 때 사용, 용도에 맞게 사용해야 함.

# 중첩 if문
 * 밖의 조건을 먼저 만족하고 안에 있는 문을 확인한다.
 * else 가 아닌 if 조건 안에 쓰는 것이다. <> 다중 if 문



# do-while
- do {  } while (condition);  // while 뒤에 종료 ; 표시


## {}
- 코드블럭 없이 한 줄 아래는 문 안에 속하지만 자바에서는 한줄만 있을 때 블럭을 치지 않는다.


# 입력
 * scanner
   * 강제로 형변환(parseInt)가 엇음.
   * Scanner scanner = new Scanner(System.in);
 * System.in.readin(); int a =  System.in.read() - 48
   * - 한글자만 넣을 수 있음.
   * - char형일 때는  c >= 'A' & c <= 'Z'
 * Stream
   * InputStreamReader inputStreamReader = new InputStreamReader(System.in);

## scanner
- scanner.close(); // 자원 해제


## 입력 차이
Space Enter를 모두 경계로 인식하기에 입력받은 데이터를 가공하기 매우 편리합니다. 하지만 그에비해 BufferedReader는 Enter만 경계로 인식하고 받은 데이터가 String으로 고정되기때문에 입력받은 데이터를 가공하는 작업이 필요할경우가 많습니다. Scanner에 비해 다소 사용하기 불편하죠. 하지만 많은 양의 데이터를 입력받을경우 BufferedReader를 통해 입력받는 것이 효율면에서 훨씬 낫습니다. 입력시 Buffer 메모리줌으로써 작업속도 차이가 많이납니다.

# Stream
 * - read() 대신에 버퍼에 저장할 수 있게 해주는 -> 
 * InputStreamReader name = new InputStreamReader(System.in)
 * 키보드에 연속적으로 입력받아 버퍼에 저장하고, 
 * BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
 *  데이터를 버퍼에서 읽어 오겠다
 * Integer은 문자열을 숫자로 변경할 수 있다.
 * su1 = Integer.parseInt(bufferedReader.readLine());.
 * 문자열을 받아들일 때; string = bufferedReader.readLine();
 * 문자열 비교할 때; string.equals("DF")

# equals
 * string.equals("DF")
 * string.equalsIgnoreCase("GK") // 대소문자 구분 없이

## equals 와 ==의 차이
 * equals () 는 메소드 입니다. 객체끼리 내용을 비교할 수 있도록 합니다. == 은 비교를 위한 연산자 입니다.
 * equals 메소드는 비교하고자 하는 대상의 내용 자체를 비교하지만, == 연산자는 비교하고자 하는 대상의 주소값을 비교합니다.


# 가비지 컬렉터
 * JVM은 메모리를 부여받고 열심히 프로그램들을 실행하다가 메모리가 부족해지는 순간이 오면 OS에게 추가로 메모리를 더 요청하게 된다. 바로 이 메모리를 더 달라고 요청하는 때에 가비지 컬렉터(Garbage Collector)가 실행된다.
 * 또, 서버 프로그램인 경우에는 24시간 내내 돌아가는데, 이 때에는 JVM이 한가할 때(idle time) 가비지 컬렉터가 실행된다.
 * (JVM이 종료되면, 당연히 사용하던 모든 메모리는 OS에게 반납된다.)

## 자원 해제
※ 자원 해제 
- ◽자원 해제는 메모리 해제 또는 메모리 삭제로 이해하면 된다. 
- ◽새로운 객체가 필요할 때 자바는 요구된 크기의 메모리를 할당하고 객체가 사용 완료되면 가비지 컬렉션을 통해 자동으로 회수한다. 
- ◽자바의 가비지 컬렉션은 자원을 관리하기 위해서가 아니라 메모리를 관리하기 위한 의도로   개발되었다. 
- ◽ 의 사전적 의미는 쓰레기 등과 같이 여러가지가 있으며 여기에서는 쓰레기라는 garbage 의미가 된다. 
- ◽가비지 컬렉션은 객체를 참조하는 참조가 증가하면 객체에 몇 개나 참조하는지 카운트를 하고 카운트가 0이 되는 것들을 모아서 주기적으로 쓰레기인 가비지를 처리하게 된다. 
- ◽프로그램이 메모리 등을 할당한 후에 해당 메모리가 필요하지 않음에도 해제되지 않을 경우에는 자원이 세는 메모리 누수의 문제가 발생할 수 있다. 
- ◽메모리 누수는 더 이상 필요하지 않은 메모리가 해제되지 않고 남아있는 버그를 가리킨다. 
- ◽메모리 누수 현상이 있으면 창을 열고 닫을 때마다 그리고 문서를 열고 닫을 때마다 지속적으로 메모리가 증가되어 성능 저하뿐만 아니라 결국에는 메모리 오류 발생으로 프로그램이 종료되는 심각한 현상이 발생한다. 
- ◽자바에서는 가비지 컬렉션에 의해 메모리가 자동으로 관리되어 메모리 누수를 방지하지만 가비지 컬렉션에서 관리하지 못하는 객체에 대해서는 메모리 누수가 발생할 수 있다. 
- ◽실제로 사용되지 않는 객체의 참조를 프로그램에서 잡고 있으면 그 객체는 가비지 컬렉션에 의해 처리되지 않고 프로그램 내에서도 접근하여 사용될 수 없는 사실상 쓰레기로서 메모리를 점유하게 된다. 
- ◽자바의 가비지 컬렉션에서 관리하지 못하는 객체의 메모리 누수 현상을 방지하기 위해서 close 메소드를 호출하여 메모리 누수를 방지한다.


## 객체
 * 인스턴스: Scanner scanner =  // 앞부분은 객체를 생성한 것이 아니라 참조형 변수를 지정해 준 것; 즉 인스턴스화를 의미한다; 객체 생성은 뒷부분만을 의미하는 것임.
 * 확장성을 주기 위한 것
 * 객체생성: new Scanner(System.in) // new 를 통해 객체를 생성했다.

## 정렬
 * 정렬을 위해 if문이 존재

## while
 * 무한정 루프를 돌릴때 사용; 무한 루프의 가능성이 있어 잘 사용하지 않음.

# Integer
 * 문자열로 들어오는 것을 강제로 숫자로 변경할 수 있다.
 *  su1 = Integer.parseInt(bufferedReader.readLine( )); ⎼Integer 클래스의 parseInt 메소드의 인자인 bufferedReader 인스턴스의 readLine 메소드로 자료를 문자열로 읽어오고 정수로 강제로 변환한다. 
 * su1 = Integer.parseInt(bufferedReader.readLine( )) // buffer에서 받은 문자열을 숫자로
 * su1 = Integer.parseInt(scanner.next()); // scanner에서 받은 문자열을 숫자로

# try-catch
 * 자원해제 방지

## “”
- 자바 String 나타낼 때 사용

## ‘’
- 파이썬 자연어 검색때 사용

# switch
 * 조건식에 따라 case 옆 자료형이 달라짐.
 * byte, short, char, int, string, enum 만 조건식에 들어갈 수 있음.
 * byte, short, char, int를 이용하여 접근할 때 다중 if 문보다 향상되어 있다.
 * JDK 1.7버전부터 지원하는 String 클래스 자료형이다. 
 * switch 문은 순서에 관계없이 선택할 수 있으며 위치 이동을 제어한다. 
 * switch 문은 case 문의 값은 각각 달라야 하고 값의 크기와 순서는 무관하다.
 * 다른말로 인덱스로 접근하지 않는다.

# 초기화
 * 원상태의 공간으로

# 인덱스
 * switch 문은 case 문의 값은 각각 달라야 하고 값의 크기와 순서는 무관하다.
 * 다른말로 인덱스로 접근하지 않는다.

# 가변
 * 값의 크기가 무관하다 = 가변적이다.
 * switch 문은 case 문의 값은 각각 달라야 하고 값의 크기와 순서는 무관하다.
 * 다른말로 인덱스로 접근하지 않는다.

# 순서
 * 순서와 무관하다는 말은 인덱스로 접근하지 않는다는 의미
 * switch 문은 case 문의 값은 각각 달라야 하고 값의 크기와 순서는 무관하다.
 * 다른말로 인덱스로 접근하지 않는다.


## =
 * <=, 사용하지 않는다.


## 이스케이프 문자
 * \t: 8칸; 수평 맞추기; 구구단 줄 맞추기


# 증감 연산자
 * 후위 연산자
   * num3 = num1;
   * num1 = num1 + 1;
 * 전위 연산자
   * num1 = num1 + 1;
   * num3 = num1;
   * -  System.out.println(i++) 의 출력값은 i가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 System.out.println(i) 의 출력값을 확인 해 보니 1이 나온다. 그렇다면 i의 값이 증가는 된 것이다.

# 함수
## 람다 함수 = 익명함수 = 이름 없는 함수

# 스태틱 메소드
 * - Math.random() // 0.0 - 0.9까지 난수 발생
 * 1부터 100까지 구하려면 100 해준다.


# 실수
 * 기본값 double; float 표현하려면 0.0f


# System
 * 에러가 없이 정상적으로 종료되었을 때는 System.exit(0);
 * 이렇게 0을 운영체제에 돌려주고, 에러가 있을 때에는 0이 아닌 값을, System.exit(1);
 * System.exit(-1); // 완전하거나 불안전하거나 그냥 종료
 * System.out.format; // 정규식 사용
- System.err.println(a + " " + b + " " + c + "=" + d); // 오류가 빨갛게 표시
- System.in.read(); // 두개를 집어 넣으면 엔터키 기능을 한다; 처음껀 \n(아스키 13)을 인식, 두 번째는 \r을 인식  
- System.in.skip(2); 를 하면 System.in.read()를 2번 넘어간 것과 같은현상


## printf
 * System.out.printf("평균 = %.2f\n", avg); // 소수 두번째 자리까지 표현

## 동적
- 동적 할당: 자료형을 자동으로 생성
- 동적 배열: 행은 무조건 있어야 함, 열은 생략 가능

# 클래스 기반
- 생성자로 접근; ex) 메소드
-힙으로 데이터 관리할 수 있게 하는 것: new;  new는 클래스 기반
- 웹과 연동할 때는 클래스 기반을 사용하는 것이 좋다. 빠르기 때문이다.
- 클래스 기반의 클래스는 오브젝트의 기본적인 기능인 구조와 동작 방식을 정의하고 인스턴스는 특정 클래스의 양식인 상태를 기반으로 한다. 
- 클래스 기반의 클래스는 동작 방식인 메소드로 동작하고 모든 인스턴스는 오브젝트의 자료를 가지고 있다. 
- 클래스 기반의 클래스의 생성자를 통하여 인스턴스를 새로 만들고 결과로 만들어진 인스턴스는 선택된 클래스의 설계와 행동을 따르게 된다. 
- 클래스 기반 언어로는 등이 있다 C++, C#, Java, Python, Ruby . 
- 클래스 기반을 프로토 타입 방식으로 쓰기 위해 JDK8 부터 람다식이 나왔다.

## new
 * int num = new Scanner(System.in).nextInt();  // 이렇게 접근 가능
-  힙으로 데이터 관리할 수 있게 하는 것: new;  new는 클래스 기반
추상 클래스는 new로 힙 공간 못만듬; {} return 이 없는 완벽한 값이 아니다.
- 메인 메소드에 new가 많으면 비효율적이다. new는 다른 곳에서 만들고 main에서는 메소드만 사용하는 것이 좋다.

# 프로토 타입 기반
- 복제; ex) 함수
- new를 안쓰고 복제하여 한번에 접근과 저장 동시에 가능.
  - 데이터를 접근해서 분석이나 시각화 작용을 하려면 프로토 타입을 사용하는 것이 좋다. 안정성 때문이다.
     - 프로토타입 기반은 오브젝트를 직접 사용하여 오브젝트를 생성하고 복제의 개념으로 재사용한다. 
     - 프로토타입 기반은 프로토타입의 복제 과정을 통하여 오브젝트가 가지고 있는 동작 방식을 다시 사용할 수 있다. 
     - 프로토타입 기반 언어는 동적으로 자유롭게 오브젝트의 구조와 동작 방식을 바꿀 수 있다. 프로토타입 기반 언어로는 자바스크립트 등이 있다
- sum() 를 sum 으로 변수처럼 직접적으로 사용 가능; 원래는 함수인 것을 사용.


# 클래스

# 중첩 클래스
- 레이아웃에 사용


# 추상 클래스
-  힙으로 데이터 관리할 수 있게 하는 것: new;  new는 클래스 기반
추상 클래스는 new로 힙 공간 못만듬; {} return 이 없는 완벽한 값이 아니다.
- 인터페이스와 달리 1:1 접근에 서용
- 추상 클래스는 미완성 클래스라 하고 구상 클래스는 완성된 설계라고 한다. 인터페이스는 설계도라고 한다.
- 목적: 1. 다형성(상속과 같이 사용) 2. 메소드의 강제성


# enum
- 상수 열거

# 인터 페이스
추상 클래스와 달리 여러 곳에 접근하게 할 때 사용.
- - 추상 클래스는 미완성 클래스라 하고 구상 클래스는 완성된 설계라고 한다. 인터페이스는 설계도라고 한다.
- 상수와 추상 메소드로 이루어 짐.

# 객체
- 속성과 동작을 가진다. 이 값을 표현할 수 없기 때문에 값이 아니라 주소값을 가진다.
- 컴퓨터에서는 모든 것이 객체로 이루어짐. 
1. 사물적 개념
2. 이름 부여
- 객체가 되면 두개의 주소를 가진다. 이를 참조 변수라 한다.(Call By Reference); 1개는 스택(identityHashCode(a)), 1개는 힙에 저장(s.hashCode())
- 파이썬은 모든 것이 객체다; 
int a 값도 id(a)로 주소값 구할 수 있고(힙에 저장) hash(a)로 접근할 수도 있다(스택에 저장).
누구나 수정하는 스택과 누구나 접근할 수 있는 스택이 합쳐진 것이 객체다.

## 파이썬 객체
- 파이썬은 모든 것이 객체다; 
- int a 값도 id(a)로 주소값 구할 수 있고 hash(a)로 접근할 수도 있다.

## 인스턴스
- 참조 자료형은 메모리상에 인스턴스(객체라고 하면 오브젝트와 헷갈림)가 있는 주소를 저장한다.
- 객체이기도 하고 힙에 저장 되어있기에 인스턴스라고 한다. 인스턴스로 저장되는 이유는 생명주기가 길어 일정하게 정보를 유지할 수 있다.
- 인스턴스화: 영어 단어인 의 사전적 의미는 예시하다 등이 있으며 여기에서는 인스턴스화라는 instantiate 의미가 된다. new 키워드를 사용하여 생성하고 생성된 인스턴스화된 오브젝트는 힙에 저장이 된다.
- A a = new A()
- A a // 사실상 이거는 스택에 공간 할당 위한 것
- new A() 가 인스턴스화 객체를 만든 것.

## 객체 생성
- A a = new A(); a 입장에서 힙에도 저장하고 스택에도 저장하여 객체 생성이라고 한다.

## 객체의 저장 영역
* 가. 메소드 영역 (method) 
- 메소드 영역은 자바에서 사용되는 클래스에 대한 정보와 함께 멤버 변수가 저장된다. 
- 특정 클래스가 사용되면 해당 클래스의 클래스 파일을 읽어들여 해당 클래스에 대한 정보를 메소드 영역에 저장한다. 

* 나. 힙 영역 (heap) 
- 힙 영역은 자바에서 사용되는 모든 인스턴스 변수가 저장되는 영역으로 메소드로 호출하여도 스택 영역처럼 소멸되지 않고 유지하므로 긴 생명주기를 가지는 자료들이 저장된다.  // # 긴 생명주기
- 힙에서 생성된 자료 중에 불필요한 자료들은 가비지 컬렉션이 해제한다. 
- 힙 영역은 사용자가 관리하는 영역으로 사용자에 의해서 메모리 공간이 동적으로 할당되고 해제된다. 
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다. 
* 다. 스택 영역 (stack) 스택 영역은 자바에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역이다. 
- 자바에서 메소드가 호출되면 메소드의 호출과 관계되는 로컬변수와 매개변수를 스택 영역에 저장한다. 
- 스택 영역은 메소드의 호출과 함께 할당되며 메소드의 호출이 완료되면 소멸한다. 
- 스택 영역에 저장되는 메소드의 호출 정보를 스택 프레임이라고 한다. 
- 스택 영역은 동작으로 데이터를 저장하고 동작으로 데이터를 인출한다
-  push pop . 스택은 후입선출 방식에 따라 동작하므로 가장 늦게 저장된 데이터가 가장 먼저 인출된다. 
- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

## 객체의 종류
### 오브젝트
 * - 가. 인스턴스 영어 단어인 의 사전적 의미는 사례 등이 있으며 여기에서는 객체라는 의미가 된다 instance . 인스턴스는 오브젝트에 의해서 생성되는 객체이지만 메모리에 저장되는 공간은 힙이 된다. 힙의 영역은 사용자에 의해서 메모리 공간이 동적으로 할당되고 해제된다. 힙은 사용자가 관리할 수 있는 공간이므로 오브젝트가 힙에 저장되어지면 자유롭게 접근하여 필요한 오브젝트의 요소를 가져다가 사용할 수가 있다. 사용자는 스택에 있는 오브젝트의 주소를 통해서 인스턴스의 정보에 접근하여 실제값을 전달하고 전달된 실제값은 스택에 있는 오브젝트의 주소에 의해서 실제값이 변경된다. 힙의 영역에 저장되는 정보는 메소드나 생성자에 의해서 호출하여도 스택 영역처럼 정보를 해제하지 않고 유지하기 때문에 스택 영역을 활용해야 한다. 참조 변수는 저장되는 메모리 주소는 스택 영역에 저장이 되고 주소가 가리키는 메모리는 모두 힙에 저장이 되므로 객체의 저장 공간은 상호 연관성을 가지고 있다.
- 

### 인스턴트
- 오브젝트는 객체의 본래 성격으로 자료와 자료에 관련된 절차 방법 기능 동작 등을 포함하는 , , , 의미이다. 오브젝트는 스택 영역에 저장이 되며 스택 영역은 컴퓨터가 관리하는 공간이므로 일반적으로 가비지 컬렉션에서 해제되는 것이 아니라 호출이 완료되면 해제한다. 스택 영역에 저장이 되는 것은 반환값 로컬변수 매개변수 등이 있다 , , . 오브젝트 안에는 오브젝트에 필요한 요소들이 가질 수가 있다. 오브젝트의 요소에는 속성인 정적인 요소와 동작인 동적인 요소가 있다. ① 정적인 요소 스태틱 멤버변수 인스턴스 멤버변수 생성자의 매개변수인 필드 : , , ② 동적인 요소 메소드 기본 생성자 필드 생성자 
- 유사 개념이지만 오브젝트가 포괄적 개념.


## 객체 예제
 * package jg.begin.start.jae_0305;
 * 
 * public class Object {
 * 
 *   String string = "문자열입니다.";
 * 
 *   public static void main(String[] args) {
 * 
 *     new Object().string = "인스턴스화 오브젝트입니다."; // 힙은 수정이 안되는데 힙에 저장하고 있다.
 *     System.out.println(new Object().string); // 위의 문자열이 출력된다.
 *     Object a = new Object(); // A를 생성하여 A 라는 스택에 저장한다.
 *     a.string = "인스턴스로 접근한다.";
 *     System.out.println(a.string);  // 인스턴스로 접근한다가 출력된다.
 *   }
 * }
  - 누구나 접근 가능하지만 값을 수정할 수는 없다.



## 객체 예제 2
 * package jg.begin.start.jae_0305;
 * 
 * public class Object {
 * 
 * public static void main(String[] args) {
 *  B b = new B();
 * 
 *  System.out.println(b);
 *  System.out.println(System.identityHashCode(b));
 *  System.out.println(b.hashCode());
 * 
 * }
 * }
- //서로 같은 결과 출력; 힙의 주소를 스택이 가지게 되기 때문.
- // 이미 만들어진 클래스인 String 클래스는 스택과 힙이 서로 다른 주소 가짐


# toString()
- 주소값을 값으로 변환해주는 메소드
- 힙에 있는 주소로 접근하게 되면 힙이 스택에 있는 값을 알려준다.(static을 하지 않으면 스택으로 직접적으로 접근할 수 없다.)


# 메모리
## Static area(스태틱 메모리 영역)
-  하나의 JAVA 파일은 크게 필드(field), 생성자(constructor), 메소드(method)로 구성된다. 그중 필드 부분에서 선언된 변수(전역변수)와 정적 멤버변수(static이 붙은 자료형) Static 영역에 데이터를 저장한다. Static 영역의 데이터는 프로그램의 시작부터 종료가 될 때까지 메모리에 남아있게 된다. 다르게 말하면 전역변수가 프로그램이 종료될 때까지 어디서든 사용이 가능한 이유이기도 하다. 따라서 전역변수를 무분별하게 많이 사용하다 보면 메모리가 부족할 우려가 있어 필요한 변수만 사용할 필요가 있다.(전역변수와 생성자에 관한 포스팅은 별도 진행 예정)

## Stack area(스택 메모리 영역)
 - 우리가 현재까지 작성하던 메소드 내에서 정의하는 기본 자료형(int, double, byte, long, boolean 등)에 해당되는 지역변수(매개 변수 및 블럭문 내 변수 포함)의 데이터의 값이 저장되는 공간이 Stack(스택) 영역이다. 해당 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. 

## Heap area(힙 메모리 영역)
-  이전 포스팅에서 객체와 인스턴스에 대해서 알아보았었다. 인스턴스를 생성하는 방법은 "클래스 변수 =  new 클래스();" 라는 것을 기억하면서 밑에 내용을 확인해 보자.
-  참조형(Reference Type)의 데이터 타입을 갖는 객체(인스턴스), 배열 등은 Heap 영역에 데이터가 저장된다. 이때 변수(객체, 객체변수, 참조변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조값(reference value, 해시코드 / 메모리에 저장된 주소를 연결해주는 값)을 new 연산자를 통해 리턴받는다. 다시 말하면 실제 데이터를 갖고 있는 Heap 영역의 참조 값을 Stack 영역의 객체가 갖고 있다. 이렇게 리턴 받은 참조 값을 갖고 있는 객체를 통해서만 해당 인스턴스를 핸들 할 수 있다.

# 상속
- 강제하기: 부모 클래스에 abstract 메소드

## import와의 차이
- 상속은 다형성에 기준을 잡는다. 그래서 구상 클래스의 상속은 의미가 없다. 그래서 메소드를 받지 않으면 의미가 없다. 추상 클래스에서는 자동으로 강제성을 부여하기에 의미가 있다.




# 초기화
- ① 묵시적 초기화 멤버변수가 선언되었을 때에 생성자에 의해 자동으로 초기화 한다. 
- ② 명시적 초기화 명시적으로 멤버변수에 값을 초기화 한다. 
- ③ 생성자에 의한 초기화 클래스의 생성자를 호출하여 초기화한다. 클래스의 내부에서 명시적으로 생성자를 호출하면은 기본 생성자라고 한다. new 키워드로 클래스의 생성자를 호출하여 인스턴스를 생성하면은 생성자에 의해서 초기화한다. 



-------------------
# 스트림
* ArrayList<Socket> roomNumber = new ArrayList<Socket>();
* 입력 스트림 : 키보드/ 파일/ 프로그램으로 입력받고 프로그램을 도착지로 향하는 것이 입력 스트림입니다.
* 출력 스트림 : 프로그램을 출발지로 모니터/ 파일/ 프로그램으로 향하는 것이 출력 스트림입니다. 
* 스트림 클래스는 그림,멀티미디어,문자등 모든 종류의 데이터를 주고 받는 바이트 기반 스트림과 문자만 주고받을 수 있도록 특화된 문자 기반 스트림 2종류로 나눌 수 있습니다. 
* Inputstream, Outputstream | Reader, Writer
* DataInputStream과 DataOutputStream 은 FilterInputStream과 FilterOutputStream을 상속하고 있어, 객체 생성시에 InputStream과 OutputStream을 매개변수 인자로 가진다.
* FileInputStream / FileOutputStream 과의 차이점은 자바 기본 자료형 데이터를 입/출력 할 수 있다는 것이다.
  FileInputStream / FileOutputStream 은 byte[] 단위의 데이터만 입/출력을 할 수 있었다. 
  하지만 DataStream Filter를 적용함으로써, 자바 기본 자료형(char, int, long, ...) 으로 데이터를 입력하고 출력할 수 있다.
* 생성자: DataInputStream(InputStream in),  DataOutputStream(OutputStream out)
* ArrayList<Socket> roomNumber = new ArrayList<Socket>();

# 클래스

## 내부 클래스
* Outer 클래스에서 Inner 클래스 멤버 사용 불가능
* Inner in = new Inner(); // 원형 : Exam03.Inner in = this.new Inner();
*  내부클래스 역시 외부클래스 입장에서 보면 멤버. 내부클래스도 나름의 속성과 기능을 가지고 있기 때문에 외부클래스를 new로 생성후 내부클래스도 다시 new로 생성해줘야한다.
  - 인스턴스 클래스
  	지역 변수와 같이 선언됨
  - 스태틱 클래스  
  	지역 변수와 같이 선언됨
  - 지역 클래스  
    지역 클래스: 메인 메소드 안에 들어있는 클래스.지역클래스는 컴파일러가 읽고나면 바로 변수가 사라지는 (지역변수의 특성) 특성을 가지고 있기 때문에 새로 생성되어 메인 내에서 사용되어야한다.
  - 익명 클래스 / 무명클래스 / Anonymous
    익명클래스(무명클래스, Anonymous) - 지역클래스의 일부 : 한방에 만들면서 쓴다.
    클래스명 정의를 안하는데 클래스인지 어떻게 식별하나? 메소드를 담는건 클래스밖에 없으니 메소드가 내부에 있는것을 보고안다. 







