# java
## 도스
* 관리자 명령어 
* cd .., cd  2. md 3. C:, D:  4. dir
* 디렉터리명 특정 디렉터리로 이동한다 cd : . 
* 상위 디렉터리로 이동한다 cd.. : .       
* 최상위 디렉터리로 이동한다 cd/ : . 
* del

## 번역기
* # 번역기 종류: 컴파일/인터프리터
* # 컴파일: 문법에 맞는지 확인
* # 인터프리터; 문법에 관계없이 확인(종료 없이 일단 수행 후 알려줌) -> 예외처리


# 자바 설치
## (1) Java SE; 웹과 연동 안됨
* Java SE Development Kit 8 Downloads
* Windows X86: 32비트
  * 는 의 약자로 일반적인 프로그램 개발을 위한 플랫폼이다 SE Java Standard Edition Java . 는 자바로 프로그래밍을 할 때 가장 기본적이고 핵심적인 패키지들이 포함되어 있다 Java SE . 는 웹 프로그래밍이나 모바일 프로그래밍을 할 때도 기본적으로 사용된다 Java SE . 를 이용하면 데스크톱에서 실행할 수 있는 어플리케이션 개발이 가능하지만 최근에는Java SE 인터넷이 연결되지 않은 프로그램이나 모바일용이 아닌 프로그래밍은 자바로는 거의 개발이 되지 않고 있는 추세이다. 

## (2) Java EE; 브라우저 연동; 많은 사전들이 들어있어 보통 SE를 받고 필요한 사전을 다운받는 방식을 사용; SE를 깔고 라이브러리로 이용 가능; 포트 충돌도 일으킬 수 있음
  * 는 의 약자로 엔터 프라이즈급 개발을 위한 플랫폼이다 EE Java Enteprise Edition . 는 엔터프라이즈 기반 어플리케이션으로 웹 어플리케이션에서 서버 측 프로그램을Java EE 위한 다양한 가 지원된다 API . 는 미들웨어 서버에서 제공하는 각종 기능에 대한 라이브러리를 제공한다 Java EE . 는 엔터프라이즈 웹 어플리케이션을 개발하기 위한 완벽한 를 제공한다 Java EE APl . 

## (3) Java ME; 테블릿 같은 모바일
  * 는 의 약자로 모바일 플랫폼 등 ME Java Mico Edition 임베디드 시스템용 개발을 위한 플랫폼이다. 는 모바일 및 임베디드 기반 어플리케이션으로 스마트폰이나 모바일 기기 등 소형기기를Java ME 지원한다. 는 와 에 대한 호환성이 제공된다 Java ME Java SE Java EE 

# JDK 설치의 의미 
* JDK 를 설치한다는 것은 자바에서 컴파일러를 설치한다는 의미다 JDK . 프로그래밍을 위해서는 기본적으로 가 필요하다 Java JavaSE . 는 다른 말로 으로 불린다 JavaSE JRE . 는 의 약자로 자바 실행 환경이다 JRE Java Runtime Environment .
* 나중에 Program files 경로에 빈칸 없애는 기능 있음


## 디렉터리의 기능 
* 디렉터리 bin ⎼자바 개발에서 실행하는데 필요한 도구와 유틸리티가 있다; begin의 약자라고 생각하면 쉬움(즉 실행시켜주는 파일)
* 디렉터리 db ⎼데이터 관련 도구와 유틸리티가 있다. 
* 디렉터리 include ⎼네이티브 코드 프로그래밍에 필요한 헤더 파일이 있다. 
⎼네이티브 코드는 와 운영체제가 직접 실행할 수 있는 코드를 의미한다 CPU . 
* 디렉터리 jre ⎼자바 런타임 환경으로 클래스 라이브러리 등의 실행에 필요한 파일이 있다 JVM, 
* 디렉터리 lib ⎼ 의 기본 라이브러리 외에 추가 라이브러리와 개발 도구에서 필요한 여러 파일이 있다 


# 클래스 파일
- java는 그냥 읽어오는 것; 클래스 파일을 찾기 위한 과정; 실행하는 것은 class 파일; javac __.java; class 파일 나오고 .java 파일 삭제해도 실행됨.
- 자바는 클래스 파일로 생성되는데 이를 자바코드로 인식하게 하는 것이 소스코드; java 이름

##  CLASSPATH 설정
* 변수 이름인 는 실행 시에 클래스 파일의 위치와 참조 파일들의 위치 지정한다 CLASSPATH . 에는 등의 도구 본채가 있으므로 를 설정하면 어디에서나 tools.jar javac.exe JDK CLASSPATH 클래스 파일을 실행시킬 수 있다. 이상 버전에서는 를 설정하지 않아도 되지만 이하 버전에서는 개발의 JDK 7 CLASSPATH JDK 6 편리성을 위해서 를 반드시 설정해야 한다 CLASSPATH .
* 라. 환경 변수의 등록 확인 환경 변수 설정 후에는 명령 프롬프트에서 으로 자바의 컴파일 버전을 확인한다 javac -version . 자바의 버전이 출력되면 환경 변수 설정이 제대로 되었다는 의미가 된다. 자바 버전이 출력되지 않고 은는 내부 또는 외부 명령으로 실행할 수 있는 프로그램 또는 javac ( ) 배치 파일이 아닙니다 라고 나오면 환경 설정이 제대로 되지 않았으므로 환경 변수 설정을 수정한다 . . 새로운 환경 변수를 수정하고 나면은 기존에 실행한 명령 프롬프트는 종료하고 반드시 새로운 명령 프롬프트에서 확인을 해야 한다. 새로운 명령 프롬프트가 아니면 환경 변수에서 수정한 내용을 인식하지 않는다. 환경 변수 설정 후에 도스 명령어가 실행되지 않으면 에 를 path %SystemRoot%\system32 추가 해주면 된다.
* CLASSPATH 설정 변수값을설정할때주의할점은 설정할 때 도트 기호 부분을 .( ) 명확하게 해 주어야 한다. 도트 기호는 컴퓨터의 자신을 가리킨다.

## Path
 * Path Path . 일반적으로 프로그램의 실행 디렉터리의 이름은 의 약자인 으로 되어 있다 binary bin . 변수 값을 뒤에 추가를 해 주면 끝에 세미콜론 이 없다면 세미콜론 을 추가한다 
 * * 설정 AVA_HOME 변수인 은 JAVA_HOME 자바의 홈 디렉터리로 자바가 설치된 경로를 의미한다.
 * Path 설정 는실행 디렉터리의 위치를Path 지정한다. 자바의 디렉터리가 위치한 bin 경로이다.
 * 자바의 bin
 * 시스템 변수에 C:\Program Files\Java\jdk1.8.0_202\bin  를 추가함으로 인해 자바 소스코드를 자바 폴더안에만 넣을 필요가 없음
 * 시스템 변수 PATH에 넣기
 *  혹은 시스템 변수 새로 만들기 - 변수 이름 지정(JAVA_HOME)/경로 넣기
 *   C:\Program Files\Java\jdk1.8.0_202;  버전 바뀌면 자바 홈만 변경
 * %JAVA_HOME%\bin             
 * 윈도우 7이엇으면 ;
* javac -version: 으로 확인; 명령 프롬프트를 재실행 해주어야 함.
* java -version: 자바 안의 프로그램 구조

# 스택, 힙
* 오브젝트: 스택에 저장
* 스택의 자료를 힙에 저장: new; 힙에 저장됨으로 인해 접근이 가능하다.(파이썬에서는 자동으로 new를 안써도 생성해줌)
* 인스턴스: 힙에 저장됨

# java 특징
* appliance -> support all OS
* oop + 
* JVM
* 다중 상속을 지원하지 않는다.  
  ^don't support multi inheritance
* no pointer
 * 다. 안전하다. 자바는 분산 환경에서 실행될 수 있도록 개발 환경과 실행 환경이 분리되어 있다. 자바 가상 머신인 은 의 약자이며 무결성에 대한 필수적인 검사를 JVM Java Virtual Machine 수행한다.
 * 라. 견고하다. 자바는 다양한 컴퓨터에서 실행되어야 하므로 높은 신뢰성이 요구되므로 견고하다. 엄격한 자료형의 검사를 지원하며 프로그램 실행할 때에 오류가 발생하면 예외로 처리한다.
 * 구조에 중립적이고 이식성이 높다. 자바는 에서 실행되는 바이트 코드를 사용함으로 특정 컴퓨터에 종속되지 않는다 JVM . 자바는 한번 작성되면 이 설치된 모든 종류의 컴퓨터에서 실행할 수 있다 JVM . 자바는 언어의 문법뿐만 아니라 시스템 종속적인 부분까지도 시스템 구조에 대하여 중립적으로 설계되어 있어 높은 이식성을 제공한다.
 * 바. 높은 성능을 가지고 있다. 자바가 지원하는 바이트 코드는 인터프리터에 의해 효율적으로 수행될 수 있도록 설계되다. 자바 번역기는 바이트 코드 생성 시에 자동 레지스터 할당과 최적화를 수행하여 효율적인 바이트 코드를 생성한다. 실행의 효율성을 제공하기 위해 컴파일러를 제공한다 JIT . 는 의 약자이며 프로그램을 실행하는 시점에서 필요한 부분을 즉석에서 JIT Just In Iime Compiler 컴파일 하는 방식이다. 
 * 사. 멀티스레드를 지원한다. 자바는 동시에 수행하여야 하는 작업들을 스레드 기술할 수 있으며 스레드의 편리한 사용을 위한 라이브러리를 제공한다. 하나의 프로그램에서 여러 개의 스레드가 병렬적으로 수행되기 때문에 프로그램이 효율적으로 실행될 수 있다. 서블릿에서도 클라이언트의 요청에 대해서 하나하나를 스레드 단위로 처리해 주기 때문에 성능이 우수하다. 
 * 아. 플랫폼에 독립적이다. 플랫폼에 상관없이 한번 작성되어 컴파일 된 파일은 어떤 플랫폼에서도 동일하게 실행된다  
 * 자. 동적이다. 자바는 변화하는 환경에 적응되도록 설계된 언어로서 기존의 프로그램에 영향을 주지 않고 라이브러리에 새로운 메소드나 속성들을 추가할 수 있다. 프로그래밍 실행시에 프로그램 실행에 필요한 라이브러리들을 연결하는 기능을 제공한다. 
 * 차. 보안이 강하다. 자바는 네트워크 프로그래밍을 수행할 때 외부에서의 데이터 접근을 허용하지 않는다. 자바는 어플리케이션 구조나 데이터에 접근하지 못하게 할 수 있다.
 * 카. 분산 환경에 적합하다. 자바는 네트워크 또는 인터넷을 통하여 효율적으로 수행될 수 있도록 설계되었다. 자바는 프로토콜 등과 연관된 라이브러리를 제공한다 HTTP, FTP . 
 * 타. 가 적용된다 RTTI . 는 의 약자이다 RTTI Run Time Type Information . 는 다형성에 나오는 개념으로 호출하는 메소드 결정을 런타임 시에 결정하므로 다형성을RTTI 사용할 수 있다. 
 * 파. 인터프리터에 의해 실행된다. 자바는 컴파일과 인터프리터를 동시에 수행하는 독특한 실행 방식으로 실행된다.


# JDK 8의 주요 특징 
 * Lambda Expression ⎼ 은 함수형 프로그래밍이다 Lambda Expression . ⎼클래스를 사용하지 않고 메소드 정의 수준으로 인자로 전달할 로직을 표현할 수 있는 표기법을 람다식 또는 람다표현이라고 말하며 익명 메소드라고도 부른다. ⎼람다식으로 표현된 로직은 함수형 인터페이스로 자동으로 변환한다. 
 * 함수형; 즉 프로토타입 기반: 복제를 통한 프로그래밍(자바의 인터페이스)을 위함(파이썬의 장점 좆음)
 * 속도가 굉장히 빨라짐(하지만 11까지 나온 지금 파이썬에게 밀림)

# 기반
* 프로토타입 기반: 복제를 통한 프로그래밍(자바의 인터페이스)
* 클래스 기반: 상속을 통한 프로그래밍


# import; 패키지명.클래스명
* import 키워드는 패키지의 클래스를 사용하기 위하여 선언한다. 임포트를 사용하게 되면 패키지가 서로 달라도 접근이 가능하다. 중에서 패키지는 최상위 패키지이므로 임포트하지 않아도 패키지의 클래스를 API java.lang 사용할 수 있는 유일한 패키지이다. 임포트의 선언은 클래스 선언보다 먼저 선언되어야 한다. 패키지를 선언할 경우에는 패키지 선언 다음에 임포트의 선언을 해야한다. 클래스명 대신에 모든 클래스를 의미하는 아스테리스크 기호를 사용할 수도 있지만 가독성이 ( ) 떨어지므로 권장하지 않는다.  모두 다 찾아와서 속도를 늦춰 권장하지 않는다.



# class
* 영어 단어인 의 사전적 의미는 학급 등과 같이 여러가지가 있으며 여기에서는 부류라는 class 의미가 된다. 품사는 단어를 기능 형태 의미에 따라 나눈 갈래인데 영어로는 라고 한다 , , word class . 에서의 를 가져다가 적용한 것이 word class class class 키워드라고 생각하면 된다. class 키워드는 클래스를 선언하며 클래스명 앞에 선언하며 소문자로 작성해야 한다.

# main 키워드
* 영어 단어인 main의 사전적 의미는 중요한 등과 같이 여러가지가 있으며 여기에서는 주된이라는 의미가 된다. 
* main 키워드는 메소드의 이름이며 main 메소드는 자동으로 실행하는 특수한 메소드이다. main 메소드는 프로그램의 시작점으로 자동 실행되어 나머지 필요한 메소드를 호출하여 실행한다. 일반적인 메소드는 호출되어야 실행되지만 main 메소드는 호출되지 않아도 실행될 수 있는 유일한 메소드이다. 
* 자바 프로그램은 main 메소드 내에서 클래스의 인스턴스를 생성 한 다음에 그 인스턴스에 메시지를 보내어 원하는 결과를 얻는다.
* main 메소드의 매개변수인 String[ ] args는 프로그램 실행시에 초기값을 전달한다.

# print
* print 메소드는 동기화가 되지 않고 출력한다.  println . 메소드는 동기화가 되어 출력한다
1. 공간을 만든다, 주소 생성(절대, 상대)
2. 패키지는 충돌을 방지
3. 사람이 소수일 땐 print(속도가 빠름), 많을 땐 println

# printf
 * System.out.printf("%5c", 'A');  // 5칸 띄어서 출력
 *  가운데 ,는 연결 자료형


# static
 * 영어 단어인 의 사전적 의미는 정지 상태 등과 같이 여러가지가 있으며 여기에서는 공유라는 static 의미가 된다. 
 * static 키워드는 new 키워드로 인스턴스를 생성하지 않고도 main 메소드를 실행시킬 수 있다. 
 * static 키워드로 지정된 멤버변수나 메소드는 메모리에서 같은 주소를 계속해서 사용한다. 
 * static 키워드를 사용하면 메모리에 제일 먼저 전달이 되므로 main 메소드 앞에 지정해야 한다. 
 * static 멤버변수나 메소드에 의해 호출이 되면은 클래스를 초기화 할 때에 맨 처음으로 메모리에 적재된다.


# 패키지 만들기
 * 디렉토리 만들기: javac -d . PackageCall.java; 이러면 import 안의 경로로 class가 들어감;  d는 패키지 선언
 * java 민.내가만든.패키지관련.PackageCall;  명령 프롬프트에서 이렇게 실행


# 이클립스
 * https://www.eclipse.org/downloads/
 * 자바 버전에 맞게 다운 받기
 * 자바는 힙 크기 조절해 주어야 함(new 사용이 많음)
 * OpenPerspective 자바 변경

## 이클립스 설정
 * eclipse 설정 클릭
 * -Dfile.encoding=UTF-8

## 이클립스 단축키
 * Ctrl + I : 들여쓰기 자동 수정
 * Ctrl + Shift + O : 자동 import 
 * Ctrl + Shift + L    단축키 표시
 * Ctrl + Shift + F 줄정렬
 * Ctrl + / 주석처리
 
# 컴파일
 * 자바의 컴파일 과정은 간단하다. 개발자가 작성한 자바 코드(.java)를 컴파일러가 기계어인 자바 바이트 코드(.class)로 변환시켜 주고, 변환된 코드를 인터프리터가 한줄씩 실행시키면서 애플리케이션을 실행하게 된다.
 
# 클래스 파일
 * 자바 소스는 에서 실행될 수 있는 기계어인 바이트 코드로 번역되며 번역된 바이트 코드는 JVM 바이트 코드 해석기가 있는 어떠한 기종의 컴퓨터 환경에서도 실행될 수 있다. 


# 힙
 * 자바는 힙 크기 조절해 주어야 함(new 사용이 많음)

# jar
 * rt.jar; 자바에서 기본 제공하는 단어들
 * 속성 - Java Source Attachment -> external -> C:\Program Files\Java\jdk1.8.0_202\src 열기
 * java.lang -string


# 플러그인
 * Eclipse market place - jad 
 *  -> preference-> Editor -> file assosiation -> default -> class deomplier ‘default’ 설정

# 똑똑하게 압축풀기
 * OS마다 길이 제한
 * 한글 사용 오류 가능성

# 동기화
 * print 메소드는 동기화가 되지 않고 출력한다.  println . 메소드는 동기화가 되어 출력한다
 * 사람이 소수일 땐 print(속도가 빠름), 많을 땐 println 

# 실수형
 * 고정; 고정 소수점 방식
 * 가변; 부동 소수점 방식; 컴퓨터가 가지고있는 기능에 맡기겠다.
 * 고정(32비트)
 * 가변(64비트)
-  float f = 1f / 3f;
  -  double f = 1f / 3f;  // 더 정밀도가 있고 double형도 f를 써도 된다.
  - double f = .1f / .3f;  // 0 생략 가능
  - double f = 1.f / .3f; // 1.0f는 1.0이라는 의미다.

# ()
 * 무조건 실행; 타입 검증

# IDE; 통합개발환경
 * 이클립스, 파이참

# static
 * 스택

# UTF
 * UTF-8; 가변적 인코딩 방식; UTF-16; 고정적 인코딩 방식

# 패키지
 * 유사 단어들의 모임
 * 충돌 방지
 * import 보다 먼저 선언되어야 한다.
 * java.으로 시작하면 안된다.(sun에서 독점); javax는 외부개발자들의 패키지를 같이 배포해주는 패키지 명이기에 사용 가능. 하지만 안쓰는게 좋다.
 * 보통 자기 이니셜을 1번에 놓는다. jg.begin.start

# 진수
 * 2진수: 0 b숫자
 * 16진수: 0xB
 * int be = 000111; // 0을 붙이면 8진수로 인식

# char
 * 정수타입: byte, short, int, long, char(자판기; 쓰면 아스키코드로 바뀜)


# string
 * 클래스형 타입; 클래스도 자료형(타입)이 될 수 있다
 * 특별한 클래스이다; 영역이 틀려도 값만 같으면 같은 클래스로 참조한다.
 * 예시
 * String s = “홍길동”’  // A클래스
 * String d = “홍길동”; // B 클래스
 * System.out.println(System.identityHashCode(); 하면 같은 주소 가짐
 * System.out.println(s.hashcode(); 하면 같은 주소 가짐
 * - new를 안쓰고 쓸 수 있는 참조 래퍼런스

# 클래스
클래스형 타입; 클래스도 자료형(타입)이 될 수 있다; string; 


# 예약어 = 키워드
 * 미리 만들어 놓은 단어; 식별자로 쓸 수 없음.

# 인코딩
 * A라는 문자가 들어오면 같은 형태의 글꼴로 인식할 수 있도록 코드로 변환해 주는 것
 * 가변적, 고정적 모두 존재
 * UTF-8; 가변적 인코딩 방식; UTF-16; 고정적 인코딩 방식

# 식별자
 * 개발자가 사용하는 단어 <>예약어
 *  변수:  일반적으로 변수의 첫 글자는 소문자로 작성한다. 변수가 두 단어가 합쳐질 경우에는 두 번째 단어의 첫 문자를 대문자로 작성한다.

# _ 
 * 원래의 용도에서 확장 되었다.
 * 저장은 되는데 검색이 안되어 _ 를 사용
 * 출력할 때는 안보이고 _ 없이 검색 가능
 * 밑줄 문자인 언더스코어는 컴퓨터에서 공백 문자를 대신하여 사용하기 위하여 고안된 기호로서 _( ) 아스키 코드 번에 해당한다.
 * ( ) 지금도 프로그램 등에서 변수의 이름처럼 공백을 쓰지 못하는 경우에 공백 문자를 대신하여 사용되고 있다.
 * JDK 7부터 제공하는 언더스코어 JDK 7 ( )로 정수 리터럴 값의 자릿수 구분을 위한 구분자로 사용한다. 



# ‘’
 * 자바에서는 char 표시할 때 ‘’만 쓸 수 있다. 이유는 main 매개변수 string을 보면 this.value = "".value; 라고 표기되어있기 때문이다.

# 공백 문자
 * 저장은 되는데 검색이 안되어 _ 를 사용

# 소스코드
 * 자바 코드를 클래스 파일로 보여주는 것


# UML 
 * http://objectaid.com/

# 브라우저
 * 인터넷을 이용해서 사용자에게 보여주는 그래픽 화면

# 주석
 * 프로그램 실행에도 영향을 주지 않지만 로그에도 남지 않는다.

# 로그
 * 주석은 프로그램 실행에도 영향을 주지 않지만 로그에도 남지 않는다.

# static
_ _ i  // 파이썬


# 자료형
1. 원시 자료형: 직접 접근
 * 수치 타입
 * 정수타입: byte, short, int, long, char(자판기; 쓰면 아스키코드로 바뀜)
 * 기본형은 int 형
 * 부동 소수점: float, double
 * 기본이 double이라 float형은 f 붙여 주어야 함.
 * 불리언 타입
 * 원시 자료형은 크기가 작고 고정적이기 때문에 메모리의 스택에 저장이 된다.
 * 자바에서는 원시 타입을 제외하고는 다 참조다. 하지만 파이썬, R은 다 참조다.(원시타입이 존재하지 않는다.)
 * 2진수, 8진수, 10진수(올림형), 16진수로 표현 가능하고, 정수형 중 음수는 보수를 사용한다
 * char 자료형은 기본적으로 아스키 코드를 기반으로 한 문자 데이터이므로 int 자료형으로 변환을 하면은 아스키 코드인 숫자를 반환한다. 
 * char 자료형은 한글이나 영문 그리고 특수 문자 등의 모든 글자 형태는 동일하게 한 문자씩만 인식하며 비트 유니코드 문자 데이터로 최대 자를 표현할 수 있다 16 65,536 . 
 * char 자료형은 하나의 문자로 유니코드 값을 표현하므로 두 문자를 할당하면 예외가 발생한다.
 *  char 자료형은 반드시 싱글 쿼터를 사용해서 표현하고 더블 쿼터를 사용하면 예외가 발생한다 ‘( ) “( ) . 유니코드는 각 나라별 언어를 모두 표현하기 위해 나온 코드 체계이며 사용중인 운영체제, 프로그램 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다 , .

 2. 참조 자료형(레퍼런스); 간접 접근; 주소값과 실제값으로 나뉘고 유저가 선택한 값을 ‘리터럴’이라고 함; 힙에 저장(자바의 new)
 * 클래스, 인터페이스, 배열, 열거
 * 클래스형 타입; 클래스도 자료형(타입)이 될 수 있다; string; 
      - 항상 자료형의 공간이 만들어지고 그에 값이 들어가면 가비지컬렉션에 의해 처리된다.
      - 참조 자료형은 메모리상에 인스턴스(객체라고 하면 오브젝트와 헷갈림)가 있는 주소를 저장한다. 
      - 참조 자료형은 가변적이고 동적이기 때문에 동적으로 관리되는 임시 기억장치인 힙 영역에 저장이 되며 주소값을 가진다. 
      - 자바에서는 원시 타입을 제외하고는 다 참조다. 하지만 파이썬은 다 참조다.(원시타입이 존재하지 않는다.)


# 배열
- 원시 타입을 메모리에 테이블처럼 저장하는 것
- 참조타입을 저장할 수 있음.

## 배열 기호
- 2차원: [ [],1]; 1차원 안에 1차원

# 컬렉션
- 참조타입을 메모리에 테이블처럼 저장하는 것
- 원시타입을 저장할 수 있음.

# 자료형 변환
 * System.out.println("한글" + (int) eword); // 아스키 코드값

# 리터럴
 * 참조 자료형(레퍼런스); 간접 접근; 주소값과 실제값으로 나뉘고 유저가 선택한 값을 ‘리터럴’이라고 함; 힙에 저장(자바의 new)
 * 실제값
* 원시 자료형의 변수는 실제 데이터를 리터럴로 저장한다. 참조 자료형의 변수는 실제 데이터가 저장된 주소로 저장한다. 참조 자료형의 자료값을 주소값이라고 한다.


# 진수
 * 16진수: 2진수로 표현하는 것을 가변적으로 변화; 공간 활용 위해 사용.
 * 8진수: 주로 이미지 표현을 위해 사용함.

# 객체지향
 * 클래스 기반: 힙 만들 때 ‘new’ 사용
 * 자바는 프로토타입 패턴에 의거하여 클래스, 배열, 열거(enum), interface 사용
 * 프로토타입 기반: 힙 만들 때 복제

# 인스턴스
- 참조 자료형은 메모리상에 인스턴스(객체라고 하면 오브젝트와 헷갈림)가 있는 주소를 저장한다. 

# 아스키 코드
 * 10번 \n  과 13번 \r이 합쳐지면 엔터
 * 48번 0;  65번 대문자 A
 *   ​char a = (char) System.in.read();
   *  이 함수가 입력되는 것은 0-255까지의 아스키코드 값이므로 char형으로 받고 싶다면 형변환을 하여서 받아야한다.​모든 아스키코드는 char에 담을 수도 있고 데이터의 손실또한 없다는 겁니다.
- int i = System.in.read() - 48; // 사용자가 입력한 숫자로 변환하기 위해 48(0)을 뺌


# wrapper
- 참조 자료형은 메모리상에 인스턴스가 있는 주소를 저장하며 주소를 레퍼런스라고도 한다. 참조 자료형의 데이터 크기는 가변적이고 동적이기 때문에 동적으로 관리되는 임시 기억장치인 힙 영역에 저장이 되며 주소값을 가진다. 
- 참조 자료형은 인스턴스에 대한 레퍼런스를 가지고 있으며 매개변수인 값을 전달한다. new 키워드를 이용하여 인스턴스를 생성하여 데이터가 생성된 주소를 참조하는 자료형이다. 참조 자료형에서 더 이상 참조하는 변수가 없을 때는 가비지 컬렉션에 의해 삭제된다. 개의 원시 자료형을 제외한 자료형은 참조 자료형으로 종류는 다음과 같다
- 1. 클래스 자료형 2. 인터페이스 자료형 3. 배열 자료형 4. 열거 자료형

# ()
- 동작한다; 
- 클래스(); // 클래스를 동작한다.

# byte
 * ⎼byte 자료형을 int 형인 i 변수로 강제 자료형 변환을 하고 b 변수에 할당한다. 
 * ⎼int 형의 255, 256, 257은 byte 형의 -1, 0, 1로 변환된다.

# 수행 > 실행
 * 런타임을 ‘수행’했다고 한다. 수행이 더 큰 개념.
 * 실행: 결과를 보여줌

# 자료형 크기
 * byte: 1바이트; 8번째 자리 버리고 -125 - 124
 * short: 16비트; 2의 15승까지 계산 가능
 * int: 2의 31승까지 계산 가능.

#  자료형 변환
 *  크기가 작은 자료형에서 큰 자료형으로 자동으로 변환한다.
 * 묵시적 자료형 변환을 자동 자료형 변환이라고도 한다. 
 * 수치 자료형은 상호간에 묵시적 자료형 변환이 가능하다. 
 * 큰 자료형에서 작은 자료형으로 묵시적 자료형 변환을 하면은 예외가 발생한다.

# 명시적
 * 강제 <> 묵시적
 * ⎼byte 자료형을 int 형인 i 변수로 강제 자료형 변환을 하고 b 변수에 할당한다. 
 * ⎼int 형의 255, 256, 257은 byte 형의 -1, 0, 1로 변환된다.
 1.
 *     int i = 48;  // int를 char로 명시적 변환
 * 
 *     char a;
 *     a = (char) i;
 2.
 *     System.out.println(a);  // 아스키 코드 값 ‘0’으로 출력
 *     byte i;  // byte를 int로 명시적 변환
 * 
 *     int a = 255;
 *     i = (byte) a;
 * 
 *     System.out.println(i); // -1 결과값 출력; 바이트수에 보수 탑재
 3. choice = (char) System.in.read( );  // read할 때 char 좋으니 강제

# []
리스트; 배열

# ()
튜플

# {}
세트

# {키와 값]
딕셔너리

# 변수
 * 변수명 만들어주는 사이트: https://curioustore.com/#!/ 
 * 공간의 위치; 이 위치를 알기 위해 이름을 부여(변수명)
 * 공간의 위치에 따른 변수의 역할
 * 멤버변수(C 언어의 전역변수); 클래스 안의 변수
 * 멤버 변수는 0으로 자동으로 초기화됨; 생성자에 의해 이루어 짐
 * 인스턴스 변수: private int age1 = 9; // 메소드로만 호출 가능(get, set)
 * 프로퍼티; this; 맴버변수 = 매개변수
 *           -     공유 변수 = C 언어의 전역 변수:  static int age2 = 29;
 *         - System.out.println(A.age2);
 *         - main 함수에 직접 접근하려면 static으로 접근하여 
 *   같은 영역을 만들어주어야 한다.
 *                     -     일반 멤버 변수
 * 로컬변수(지역변수); 메소드 안의 변수
 * 초기화 선언이 따로 필요!
 * 블록 안에 있는 것이 보유(유지) 되지 않고 소멸된다.
 * 매개 변수(parameter)

## 변수 선언 주의사항
- int i = 10; // 바로 선언하는 건 이 숫자만 사용하겠다는 암묵적 의미
- int i;  먼저 선언하고 나중에 값을 지정하는 것을 권장
  - int i, y; // 변수를 동시에 선언하는 것도 비권장

# null
 * 모든 참조 타입의 기본값;

# http
 * hyper: 뛰어넘다; text: 무작위로 선택할 수 있는 것; 목차에 관계없이 접근


# ; 
 * 영역의 종료

# :
 * 영역의 변경
 * System.out.println("클래스 클래스다.");

# 로컬변수
 * 가. 로컬변수의 개요 로컬변수는 메소드 안에서만 선언한 변수이다. (메소드 만이 아니라 {}(코드 블록) 내에 선언된 변수 
 * 로컬변수는 멤버변수와 같이 선언과 동시에 초기화가 이루어지지 않으므로 자료형의 초기값을 할당해야 한다. 
 * 실행 영역인 코드 블록 내에서 선언된 로컬 변수는 코드 블록의 범위를 벗어나면 자동으로 { }( ) 삭제된다. 

# {} -  
 * 코드 블록 {} 
 * 네임 스페이스; public class A

# scanner
 * import java.util.Scanner;
 * Scanner sc = new Scanner(System.in);
 * 이렇게 객체생성을 하며 System.in은 입력한 값을 바이트 단위로 읽는 것을 뜻합니다.
 * next()라는 메소드가 있는데 이 next() 메소드는 공백 이전까지의 문자열을 입력 받습니다.
 * sc 보다는 scanner; 클래스를 알아보기 위해
 * nextLine() // 라인을 추가한다.(두줄이 띄어져서 잘 안씀 -> next())
 * name = scanner.next(); // 사용자 편의성 위해 변수에 직접 넣어준다.

# static
 * 공유: 키워드에 의해서 멤버변수는 전역적인 범위가 될 수가 있다

# 캡슐화 
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다

# 상수 
 * final 키워드에 의해서 멤버변수나 로컬변수는 상수가 된다.

# private
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다
 * get/set 으로 호출

# get/set
 * private 키워드에 의해서 멤버변수는 캡슐화가 되어 메소드에 의해서만 접근이 가능하다

# final
 * ① 클래스의 상수 선언 클래스에서 상수의 선언는 final 키워드로 선언한다. 상수는 선언할 때 단 한번 초기화를 하며 상수 앞에 static 키워드를 붙여서 final 키워드로 선언하면 전역적인 상수가 된다. 클래스의 상수는 일반적으로 static final로 선언해서 전역적인 상수 변수를 만들어서 사용하는 경우가 많다.
 * ② 인터페이스의 상수 선언 인터페이스에서 멤버변수를 선언하면 자동으로 상수가 되며 그 이유는 인터페이스에서는 생성자가 없기 때문이다.
 * 클래스에 final 붙이면 상속 불가


# 생성자
② 인터페이스의 상수 선언 인터페이스에서 멤버변수를 선언하면 자동으로 상수가 되며 그 이유는 인터페이스에서는 생성자가 없기 때문이다.
멤버 변수는 0으로 자동으로 초기화됨; 생성자에 의해 이루어 짐


# # read()
 * choice = (char) System.in.read( );  // read할 때 char 좋으니 강제
 *   ​char a = (char) System.in.read();
 *  이 함수가 입력되는 것은 0-255까지의 아스키코드 값이므로 char형으로 받고 싶다면 형변환을 하여서 받아야한다.​모든 아스키코드는 char에 담을 수도 있고 데이터의 손실또한 없다는 겁니다.
 
# switch 문
 * 비순차적 문장
 * 머신러닝 같이 데이터 검출을 목표로 할 때는 if 문을 쓰는 것이 맞다. 순차적으로 모두 확인해야 한다.
 * :(영역 변경) 뒤에 {} 생략 가능; 파이썬 방식

# MVC
 * M(Model): 멤버 변수가 모여 있음
 * V(View)
 * C(Control): 유일하게 변경할 수 있음; ex) API

# 연산자
- 단항: a++
- 이항: 5 + 5
- 삼항
- 조건(수식)? A:B  // 와일드 카드
- ?: 플레이스 홀더

##  연산자의 결합 방향
- 오른쪽에서 왼쪽으로 결합 이라는 수식은 오른쪽에서 왼쪽으로 결합하여 연산을 한다 a = b = c . 

# 배열과 리스트 차이
- 배열은 한개의 타입(자료형)만 넣을 수 있음.
- 리스트는 여러 개의 타입(자료형)을 넣을 수 있음.


# instance of
- System.out.println(string instanceof String);
- 외부에서 실제값을 확인하는 것; 객체를 비교하는 것이 아니다.
- 기본값인 ‘null’은  
 * String string = null;  
 * System.out.println(string instanceof String)  // 하면 false
⎼ String 클래스형의 string 로컬변수에 기본값인 null을 할당하고 instanceof 연산자로 비교하면은 할당된 null은 String 클래스형인지를 확인할 수가 없으므로 false를 반환한다. 
- ⎼instanceof 연산자는 참조 자료형에 할당된 자료값에 대한 정확한 자료형을 검증한다.


## 자료형 확인
- System.out.println(string instanceof String);

# ==(더블 이퀄)
- 일반적으로 수를 비교
- 문자열을 비교할 때는 equals 라는 메소드로 비교한다.

# 비교
- ‘==’는 일반적으로 수를 비교
- 문자열을 비교할 때는 equals 라는 메소드로 비교한다.

# 논리 연산자
- 자바에서는 속도 때문에 &&   ||  등 2개 짜리를 권장한다.
- &&는 앞이 거짓이면 뒤 검증 안함, || 도 앞이 참이면 뒤 검증 안함.


## &
- 파이썬에서는  and, or, not 을 논리 연산자로 쓰고  &는 보통 비트 연산자로 사용한다.


## |
 - 버티컬바 |( ) 연산자



# 복합 대입 연산자
- 복합 대입 연산자는 다른 연산자보다 우선순위가 낮아 생각지 못한 결과가 발생할 수 있으므로 유의해야한다. 자주 사용하지 않는다.

# 증감 연산자
- a++ 보다는 a = a+1 을 사용하기를 권장한다.

## ~     - Tilde; 틸드
- ~숫자;  // +1 한 값 앞에 마이너스 기호 붙이기
- 컴퓨터에는 마이너스 개념이 없어서 2의 보수를 통해 표현

## ^
 - 서컴플렉스;  Circumflex 




# 비트 연산자
- 컴퓨터 입장에서 인식이 빨라 정확도와 속도 모두 빠르다. 
- &,  |,  ^,  ~
- 시프트 연산자; <<, >>; C++ 에서 자주 사용
- 더블 레프트 앵글브래킷❷ 연산자로 만큼 이동한 비트의 연산을 하고 이동하여 비어있는 2 8 공간은 0으로 채운다
- 더블 라이트 앵글브래킷 연산자는 4>>2 4/2/2 4 2 누어 주면 되는 것 같이 이동한 숫자만큼 로 나누어준다 2 .
- 컴퓨터에는 마이너스 개념이 없어서 2의 보수를 통해 표현

# 보수
- 각 자리의 숫자의 합이 어느 일정한 수가 되게 하는 수이다.
- 2진수에는 1의 보수와 2의 보수가 있으며 의 보수와 의 보수를 구하면 다음과 같다. 결과를 비교해 보면은 2의 보수는 1의 보수에 1을 더한 것과 같으므로 1의 보수에서 1을 더해주면 의 보수를 구할 수 있다 
- 9의 보수와 10의 보수의 차이는 끝자리에 1을 더했느냐의 차이이다.
- 2의 보수는 그래서 1을 더하고 -을 붙여준다.
- 1의 보수: 모두 1로 맞추는 작업 -> 2의 보수: 1을 더해서 자리 올림을 만들어 그 1을 부호로 만든다. 

# 조건 연산자
int c = (a > b) ? a : b;  이렇게 값을 변수로 지정한다.


# 연결 연산자
- 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)


# +
- 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)


# StringBuffer 클래스
- StringBuffer bu  = new StringBuffer();
      - System.out.println(bu.append(s).append(t));

# 문자열
# StringBuffer 클래스
- StringBuffer bu  = new StringBuffer();
      - System.out.println(bu.append(s).append(t));

      2. - 연결 연산자를 사용할 때 앞에 문자열이 있으면 뒤에 정수도 안더해진다. ( +를 연결 연산자로 인식)
- System.out.println(“ “ + 정수 + 정수)
- 잘 쓰지 않고 StringBuffer를 사용한다.

# “”
- String number = ""; 
- ⎼String 클래스형인 numbe 변수에 아무 값도 할당받지 않은 상태인 빈 문자열 ""를 할당하여 문자열을 저장할 임시 공간을 설정한다. 
- String number = " "; // 공백문자라고 함. 


# 스트림
* ArrayList<Socket> roomNumber = new ArrayList<Socket>();
* 입력 스트림 : 키보드/ 파일/ 프로그램으로 입력받고 프로그램을 도착지로 향하는 것이 입력 스트림입니다.
* 출력 스트림 : 프로그램을 출발지로 모니터/ 파일/ 프로그램으로 향하는 것이 출력 스트림입니다. 
* 스트림 클래스는 그림,멀티미디어,문자등 모든 종류의 데이터를 주고 받는 바이트 기반 스트림과 문자만 주고받을 수 있도록 특화된 문자 기반 스트림 2종류로 나눌 수 있습니다. 
* Inputstream, Outputstream | Reader, Writer
* DataInputStream과 DataOutputStream 은 FilterInputStream과 FilterOutputStream을 상속하고 있어, 객체 생성시에 InputStream과 OutputStream을 매개변수 인자로 가진다.
* FileInputStream / FileOutputStream 과의 차이점은 자바 기본 자료형 데이터를 입/출력 할 수 있다는 것이다.
  FileInputStream / FileOutputStream 은 byte[] 단위의 데이터만 입/출력을 할 수 있었다. 
  하지만 DataStream Filter를 적용함으로써, 자바 기본 자료형(char, int, long, ...) 으로 데이터를 입력하고 출력할 수 있다.
* 생성자: DataInputStream(InputStream in),  DataOutputStream(OutputStream out)
* ArrayList<Socket> roomNumber = new ArrayList<Socket>();

# 클래스

## 내부 클래스
* Outer 클래스에서 Inner 클래스 멤버 사용 불가능
* Inner in = new Inner(); // 원형 : Exam03.Inner in = this.new Inner();
*  내부클래스 역시 외부클래스 입장에서 보면 멤버. 내부클래스도 나름의 속성과 기능을 가지고 있기 때문에 외부클래스를 new로 생성후 내부클래스도 다시 new로 생성해줘야한다.
  - 인스턴스 클래스
  	지역 변수와 같이 선언됨
  - 스태틱 클래스  
  	지역 변수와 같이 선언됨
  - 지역 클래스  
    지역 클래스: 메인 메소드 안에 들어있는 클래스.지역클래스는 컴파일러가 읽고나면 바로 변수가 사라지는 (지역변수의 특성) 특성을 가지고 있기 때문에 새로 생성되어 메인 내에서 사용되어야한다.
  - 익명 클래스 / 무명클래스 / Anonymous
    익명클래스(무명클래스, Anonymous) - 지역클래스의 일부 : 한방에 만들면서 쓴다.
    클래스명 정의를 안하는데 클래스인지 어떻게 식별하나? 메소드를 담는건 클래스밖에 없으니 메소드가 내부에 있는것을 보고안다. 







