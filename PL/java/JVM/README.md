# 기본기를 쌓는 정아마추어 JVM
* [출처]('https://jeong-pro.tistory.com/148?category=793347')

# 자바의 구동원리
1. 컴파일러를 통해 JAVA 코드 검증과 JVM이 이해할 수 있는 바이트코드(.CLASS)로 만듬
2. .CLASS를 찾아 JVM으로 가져옴
3. 바이트코드 검증
4. 인터프린트(재해석
5. 바이트코드를 바이너리코드로 변경(바이너리 코드는 JVM의 클래스 영역에 저장)
6. 런타임 과정에서는 클래스들의 static  변수를 자동 초기화
7. static 블록 수행
8. 인스턴스 블록 수행
9. 생성자 호출
10. main 함수 호출

# JVM의 특징 
1. 스택기반의 가상머신
2. 가바지 컬렉션
3. 플랫폼에 독립적
* JAVA Compiler 이 java코드를 byte Code로 변환 -> Class Loadder System 을 통해 Class파일들을 JVM으로 로딩* -> 로딩된 Class 파일들은 Execution Engine을 통해 해석됨 -> 해석된 프로그램은 Runtime Data Areas에 배치되어 실질적인 수행이 이루어짐 
* -> 실행과정속에서 JVM은 필요에 따라 Thread Synchronization 과 Garbage Collection 같은 관리 작업을 수행하게 됨

```java
1. static 변수 선언부 : 클래스가 로드 될 때 (메모리 모델상 Methd area 에 올라감) 변수가 제일 먼저 초기화 됨

2. 필드 변수 선언부 : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감) 생성자 block 보다 앞서 초기화 함

3. 생성자 block : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감)

JVM이 내부적으로 locking (thread safe 영역임)

필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하는 시점은) 생성자 block이 끝난 다음.

필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀


초기화 시점

    * 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다. 

    * 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.


초기화 순서

    * 클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭 

    * 인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자


```
