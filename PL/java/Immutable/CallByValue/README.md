# CallByVlue와 CallByReference 차이
* [EvanMoon](https://evan-moon.github.io/2020/01/05/what-is-immutable/)
```java
값에 의한 호출과 참조에 의한 호출
값에 의한 호출과 참조에 의한 호출은 특정 컨텍스트에서 다른 컨텍스트에게 변수를 넘길 때 어떤 방식으로 값을 넘겨줄 것인지에 대한 방법들이다.

이렇게 컨텍스트 간 변수를 넘기는 상황은 함수 외부의 스코프에서 함수에게 인자를 넘겨주는 상황으로 많이 표현되며, 또 실제로도 그런 상황이 대부분이다.

이에 대해서 조금 더 쉽게 알아보기 위해 간단한 함수를 선언해보도록 하겠다.

function foo (s) {
  return str.substring(0, 2);
};
foo 함수는 문자열을 인자로 받아서 가장 앞의 두 글자만 잘라내어 반환하는 순수 함수이다. 즉, foo 함수는 자신의 인자로 받은 값을 
재료로 하여 자신의 반환 값을 만들어내는 셈이다.

그럼 foo 함수를 한번 사용해보도록 하자.

const str = 'Hello, World!';
foo(str);
He
foo 함수는 자신의 인자로 받은 문자열을 잘라서 반환하기 때문에, 마치 인자로 받은 str 변수를 직접 수정하는 것처럼 보인다.

하지만 foo 함수의 인자로 사용했던 str 변수를 콘솔에 출력해보면 처음 필자가 할당했던 값인 Hello, World!가 그대로 
저장되어 있는 것을 확인할 수 있다.

console.log(foo(str));
console.log(str);
He
Hello, World!
이게 어떻게 된 것일까? 정답은 str 변수의 자료형인 string형의 호출 방식이 값에 의한 호출 방식을 사용하기 때문이다.

자바스크립트에서 string, number, boolean과 같이 원시 자료형을 사용하는 변수들은 모두 값에 의한 호출 방식을 사용한다.

값에 의한 호출 방식은 함수의 인자로 어떤 변수를 넘길 때 해당 변수가 가지고 있는 값을 그대로 복사하여 함수에게 
넘겨주는 방식을 의미하기 때문에, 기존에 str 변수가 가리키고 있는 메모리 공간에 있는 값을 함수에 인자로 넘기는 것이 
아니라 그 값을 복사하여 새로운 메모리 공간에 저장하고나서 넘겨준다는 뜻이다.

call by value
결국 foo(str)라는 코드로 함수를 호출하며 인자로 넘긴 str이라는 변수가 가지고 있는 값과, foo 함수 내부에서 s라는 
변수를 통해 접근하는 값은 전혀 다른 메모리 공간에 저장되어 있는 새로운 값이다.

그렇기 때문에 foo 함수가 아무리 자신의 인자로 받은 변수를 지지고 볶아도 원본 변수는 절대로 영향을 받지 않는다. 
심지어 foo 함수 내부에서 s 변수를 재할당하더라도 원본 변수에 담겨져 있는 값은 변하지 않는다.

const str = 'Hello, World!';

function foo (s) {
  s = '재할당합니다';
  return s.substring(0, 2);
}

foo(str);
console.log(str);
Hello, World!
foo 함수는 인자로 넘어온 변수에 값을 재할당했음에도 함수 외부에 있는 str 변수의 값은 변하지 않았다.

즉, 불변성을 유지한다는 것은 단순히 “함수의 인자를 변경하지 않는다”라던가 “변수를 재할당하지 않는다”는 개념이 
아닌 것이다. 포인트는 메모리에 이미 담겨있는 값을 변경하지 않는 것이다.

반면 값에 의한 호출 방식을 사용하지 않는 Array, Object와 같은 객체들은 조금 상황이 다르다.

이번에는 인자로 배열을 받은 후 그 배열에 hi라는 문자열 원소를 추가하는 간단한 함수를 선언하고, 어떤 결과가 
나오는지 살펴보도록 하겠다.

function bar (a) {
  a.push('hi');
  return arr;
};
원시 자료형이었던 str 변수는 값에 의한 호출 방식을 사용하지만, 객체인 Array는 참조에 의한 호출 방식을 사용한다.
그럼 함수를 사용해보고 원본 변수가 어떻게 되는지 확인해보자.

const array = [];
bar(array);

console.log(array);
['hi']
함수 내부에서 인자를 지지고 볶아도 원본 변수에는 전혀 영향이 없었던 foo 함수와 다르게, 이번에는 bar 함수의 인자로 
넘겼던 array 변수의 값이 변경된 것을 확인해볼 수 있다.

함수의 인자로 변수를 넘길 때 값을 복사하여 새로운 공간에 저장한 후 넘겨주는 값에 의한 호출 방식과 다르게, 참조에 의한 
호출 방식은 “변수가 가리키고 있는 메모리 공간의 주소”를 넘기는 방식이다.

즉, array 변수가 가리키고 있는 메모리 공간에 저장된 배열과 bar 함수가 인자로 받은 배열은 정확히 같은 메모리 공간에 
저장되어 있는, “같은 배열” 이라는 것이다.

call by reference
즉, bar 함수의 인자로 받은 배열은 참조에 의한 호출 방식을 사용하는 객체이기 때문에, 함수 내에서 이 배열을 지지고 볶아 
버린다면 원본 배열 자체가 지지고 볶아지는 것이다.

이 경우에는 메모리 공간에 저장되어있던 배열을 직접 변경해버리는 것이므로, 상태가 변경되었다고 말할 수 있고, 불변성이 깨져버린 것이다.

똑같이 함수의 내부에서 인자를 수정하는 행위지만 인자가 값에 의한 호출 방식을 사용하는 자료형인지 참조에 의한 
호출 방식을 사용하는 자료형인지에 따라 결과는 큰 차이가 나기 때문에, 불변성을 지키고 싶다면 항상 이 점을 염두에 
두고 코드를 작성해야한다.
```
