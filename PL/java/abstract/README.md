# 추상클래스와 인터페이스
```java
- 공통점

: 추상클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스다.

(자바8부터 인터페이스에 default method 구현이 가능해졌지만 일반적으로 인터페이스는 구현이 없다.)

따라서 인터페이스와 추상클래스를 가지고 새로운 인스턴스(객체)를 생성할 수 없다.

추상클래스를 extends로 상속받아 구현한 자식클래스나 인터페이스를 implements 하고 구현한 자식클래스만이 객체를 생성할 수 있다.

=> 결국 자식클래스가 무언가 반드시 구현하도록 위임해야할 때 사용해야 한다.

- 차이점

추상클래스

추상클래스는 추상메서드(abstract method)가 하나라도 존재하는 클래스를 말한다.

추상클래스는 추상메서드(abstract method)가 없어도 무방하다.

추상클래스와 인터페이스의 차이점에서 키워드는 목적이다.

추상클래스의 목적은 말 그대로 공통적인 기능을 하는 객체들의 추상화다.

예제들을 보면 사자 클래스, 원숭이 클래스, 고래 클래스 같은 구체적인 클래스가 있고, 
추상클래스로 공통기능을 가진 동물 클래스를 만드는 것이 나온다.

이번 포스트에서는 동물 클래스 대신 포유류 클래스를 만들었다고 가정하자.

위키백과에 따르면 포유류는 젖먹이 동물이라고 한다.

즉, 젖을 먹이는 공통적인 기능을 가지고 있고, 각 포유류에 속하는 동물인 사자, 원숭이, 고래에게 중복으로 구현할 필요가 없다.

그래서 추상 클래스인 포유류 클래스를 만드는 것이다.

처음에 말했듯 추상클래스에 "젖을 먹인다" 라는 행위(메서드)를 추상메서드가 없어도 무방하다.

그러면 일반클래스와 뭐가 다른가? 다시 한 번 말하지만 키워드는 "목적"이다.

객체 지향 관점에서 봤을 때 클래스는 어떤 객체를 만드는 틀에 비유한다.

즉, 클래스는 어떤 인스턴스를 생성할 수 있다는 것인데, 추상 클래스는 생성할 수 없다는 특징이 있다. 
왜? 추상화된 클래스니까. 형용할 수 없으니까.

포유류 클래스에서 포유류를 생성하면 그 인스턴스(객체)는 뭐라고 구체적으로 말할 수 있을까? 없다. 세상에 없는 객체다.

추상 클래스에 추상 메서드가 없어도 된다는 것에서 일반 클래스와 다른 점을 설명했지만, 인터페이스와 차이점도 일맥상통한다.

추상 클래스는 일반적인 추상화 및 상속에 더 초점을 맞춘다면, 인터페이스는 인터페이스 메서드를 구현하게 하는 것에 
초점을 맞춘다고 보면 된다.

포인트는 추상클래스를 언제 사용해야하는 지다.

인터페이스와 추상클래스를 단순하게 자식클래스에서 반드시 구현하게 위임시키는 것만 생각하면 비슷하지만 용도를 봤을 때 다르다.

추상클래스는 말그대로 추상화 시킬 때 사용하면 된다.

책에서 보는 is-a 관계가 핵심이다.

쉽게 말하면 만들어야할 여러 클래스들의 공통점을 찾아 추상화시켜서 사용하는 것이 개발에서 이득일 때!

예를들면 냉장고, TV, 커피머신, 전자렌지등의 클래스를 만들어야할 일이 있을 때 가전제품이라는 추상클래스로 추상화 시켜서 사용하면 좋을 때 사용한다.

가전제품은 공통적으로 (on(), off(), 전기소모(), 기타등) 사용되는 메서드들을 적고, 구체적인 가전제품별로 별도의 동작(메서드)을 나눠서 적는다. 냉장고는 차갑게하고 전자렌지는 물분자운동을 시키는 동작 말이다.

(냉장고 is a 가전제품, 커피머신 is a 가전제품, 전자렌지 is a 가전제품)

상속 받아서 기능을 확장시키는데 목적, 전형적인 상속의 목적

또한 자바특성상 다중상속이 불가한 점을 고려해서 사용해야한다.

요약하면 다중상속 불가, 멤버 변수 존재 가능, 구현된 메서드 존재 가능 이다.




인터페이스

인터페이스는 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할이다.

즉 구현 객체가 같은 동작을 한다는 것을 보장하기 위한 목적이다.

위의 추상 클래스에서 예제처럼 "젖을 먹인다"라는 행위(메서드)를 사자, 원숭이, 고래 클래스가 한다고 
보장하기 위한 목적으로 한다면 인터페이스로 "젖을 먹인다"라는 메서드를 만들어서 해당 객체들이 구현할 수 있다.

판단을 잘해서 써야한다.

또 다른 차이점은 클래스가 아니기 때문에 인터페이스는 다중 상속이 가능하다.

interface도 is-a관계다.

Thread는 runnable이다. 라고 했을 때 인터페이스도 상속이니 is-a관계로 볼 수 있다.

Inheritance (IS-A) vs. Composition (HAS-A) Relationship 으로 상속과 관련되면 is-a로보고 멤버 변수로 사용되면 has-a로 본다. 

* 차이점을 말할 때 다중 상속이 되냐 안되냐는 포인트가 아니다. 목적이 다르다는게 포인트다.

* 참고로 has-a 관계는 어떤 클래스의 멤버 변수로 가지고 있을 수 있으면 뭐든 has-a 관계인 것 같다.
```

# 익명 중첩 클래스
- 익명 중첩 클래스는 특정 메서드를 오버라이딩하여 원하는 형태로 재정의하여 사용한다. 
- 익명 중첩 클래스는 클래스의 이름을 가지지 않고 인스턴스 생성과 메소드만 정의한다. 
- 익명 중첩 클래스는 한번만 사용하기 위해서 선언하므로 일회성이다. 
- 익명 중첩 클래스는 일반적으로 추상 클래스와 인터페이스에서 자주 사용된다. 
- 대표적으로 화면에서 발생되는 이벤트 처리에서 사용한다 GUI . 

## 익명함수
- 익명함수는 함수가 정적 객체가 된다.  sum() 이 아닌 sum처럼 선언

## 예제
 * package jg.begin.start.jae_0307;
 * 
 * class Cot {
 * 
 *   public void change() {
 * 
 *   }
 * 
 * }
 * 
 * public class Outer {
 * 
 *   public static void main(String[] args) {
 * 
 *     Cot cot = new Cot() {
 * 
 *       @Override
 *       public void change() {
 * 
 *       }  // 상속, 오버라이드는 구상 클래스에서는 이해 안되고 추상 클래스, 인터페이스에서 사용된다.
 * 
 *     };
 * 
 *   }
 * 
 * }





## 구상 클래스 <> 추상 클래스와 반대 개념
- 구성요소:  인스턴스 맴버변수, 생성자, 메소드

## 구상 클래스의 재사용 
- ① 집합 관계 클래스는 클래스를 포함하고 있지만 클래스가 없어도 클래스는 독자적으로 존재한다 A B B A . 클래스 간의 라이프 사이클이 다른 경우에 해당된다. 
- ② 구성 관계 클래스는 클래스를 포함하고 있지만 클래스가 없으면 클래스는 존재할 수 없다 A B B A . 클래스 간의 라이프 사이클이 같은 경우에 해당된다. 
- 나. 비슷한 클래스 간의 관계 비슷한 속성과 동작을 가진 클래스들 간의 관계이다. 비슷한 속성 및 동작을 가지고 있는 클래스들은 공통점들이 중복되어 있으므로 공통점들을 추출해서 상위 개념의 클래스를 만들 수 있다. 하위 클래스들에게 상위 개념의 클래스를 상속받아서 사용한다면 중복이 제거되고 재사용성도 향상 될 수 있다.
- 집합 관계는 컬렉션과 보관할 개체의 생성과 소멸은 독립적입니다. 참고로 구성 관계는 사람과 눈처럼 소유 개체를 생성할 때 피 소유 개체가 만들어지고 소유 개체가 소멸할 때 피 소유 개체도 같이 해제하는 특징을 갖습니다. 다음은 집합 관계에 있는 Pencil과 PencilCase를 구현한 예제 코드입니다.


## 집합관계
- 상속하면 자식입장에서는 집합관계, 부모입장에서는 다른 클래스와 구성관계


# 중첩 클래스
- 레이아웃에 사용


# 추상 클래스
- 내부적으로 연동할 때 사용; 내부 라이브러리 연동
-  힙으로 데이터 관리할 수 있게 하는 것: new;  new는 클래스 기반
추상 클래스는 new로 힙 공간 못만듬; {} return 이 없는 완벽한 값이 아니다.
- 인터페이스와 달리 1:1 접근에 서용
- 추상 클래스는 미완성 클래스라 하고 구상 클래스는 완성된 설계라고 한다. 인터페이스는 설계도라고 한다.
- 목적: 1. 다형성(상속과 같이 사용) 2. 메소드의 강제성
- - protected 접근 제한자는 추상 클래스와 궁합이 잘 맞음

## 추상 클래스 <> 구상 클래스와 반대 개념
- 추상 클래스는 class 지정어 앞에 클래스 앞에 반드시 abstract 지정어를 지정해야 한다. 
- 추상 클래스 안의 추상 메소드를 선언할 때에도 abstract 지정어를 지정해야 한다. 
- 추상 클래스 안에 반드시 추상 메소드를 선언하지 않아도 되지만 추상 클래스를 선언하면 추상 메소드가 없어도 존재하는 것으로 인식한다. 
- 추상 클래스는 추상 메소드에 의해서 인스턴스 생성이 불가능하므로 추상 클래스를 사용하기 위해서는 구현체를 이용하여야 한다. 
- 구현체는 extends 키워드를 이용해서 추상 클래스를 상속받고 추상 메소드가 존재하면 반드시 구현한다. 
- 자식 클래스를 강제하는 특정 메소드의 역할을 한다. 
- 추상 메소드는 코드 블록과 함께 구현되지 않고 상속을 통해서 코드 블록을 구현한다.
- 메모리, 버퍼 등 사용 범위가 한정적이고 좁을 때 사용.
- 구현체가 완성되지 않아 new를 통해 힙으로 보낼 수 없다.
- 직접 접근: 1. 익명중첩클래스 + static 메소드(calender 함수)

### 장점
1. 부모클래스에서 공통 부분을 구현과 설계가 완료되면 자식 클래스에서 상속받아 기능을 확장 시 이롭다.
2. 자식 클래스에서 추상메서드를 반드시 구현하도록 강요한다. 이는 프로그램의 표준화 정도를 높인다.
3. 공통 사항이 한곳에서 관리되어 개발 및 유지보수에 용이하다.


## 추상 메소드
- 추상 메소드의 접근 지정자로 private는 사용할 수 없는데 이는 자식 클래스에서 받아서 구현되어야 하므로 당연하다. 다른 접근 지정자(public, protected)는 사용할 수 있고 생략되면 default (즉, 같은 패키지 안에서만 접근 가능)인 것은 일반 클래스와 동일하다.
-  블록이 없는 것


### 예제
 * package jg.begin.start.jae_0307_3;
 * 
 * public abstract class A {
 * 
 *   abstract void so();
 * 
 *   public static A go() {   // 추상 클래스엔 추상 메소드 속성만 사용 가능하니 A 자료형 사용
 *     return null;
 *   }
 * 
 * }

### 구현체 없이 인스턴스 생성 방법;  상속 없이도 직접 쓸 수 있는 방법
 * package jg.begin.start.jae_0307_3;
 * 
 * public abstract class A {
 * 
 *   static A a = new A() {          // 구현체를 통해 인스턴스를 생성할 필요가 없다.
 *           // static 메소드 이용해서 익명 중첩 클래스로 
 * 오버라이드해서 사용
 * 
 *     @Override
 *     void so() {
 * 
 *     }
 * 
 *   };
 * 
 *   abstract void so();
 * 
 *   public static A go() {
 *     return a;
 *   }
 * }
 * 
 * // 구현체
 * package jg.begin.start.jae_0307_3;
 * 
 * public class B extends A {
 * 
 *   @Override
 *   void so() {
 *     // TODO Auto-generated method stub
 * 
 *   }
 * 
 * }

 * // 출력
 * package jg.begin.start.jae_0307_3;
 * 
 * public class C {
 * 
 *   public static void main(String[] args) {
 *     A a = A.go();  // 추상 클래스
 *     a.so();
 * 
 *     B b = new B(); // 구현 클래스
 *     b.so();
 *   }
 * 
 * }
 * 

# 인터페이스
1. 다중 상속 가능
2. 선언한 변수는 자동으로 final static
3. 따로 abstract를 쓰지 않아도 모두 추상 메서드로 정의가 되구요
4.  팀 작업을 할 때 개발코드와 객체가 서로 통신하는 접점 역할을 지원합니다. 개발코드에서는 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알면 다른 팀의 작업을 기다리지 않아도 됩니다.

- 라이브러리와 연동하기 위해 사용: 프레임워크의 꽃
- 소스 코드가 직접 객체의 메소드를 호출하지 않고 인터페이스라는 중간 매개체를 쓰는 이유는 소스 코드를 수정하지 않고 사용하는 객체를 변경하는 것만으로 편리하게 실행 내용과 반환값을 다양화시킬 수 있기 때문이다: 다형성
 - 클래스보다 인터페이스가 자동으로 상수, 추상메소드가 선언되기에 더 편하다.
- 다중 상속 지원, 생성자 없음, 구상 메소드(추상 메소드 존재), 멤버변수(상수가 존재) 존재하지 않고, public만 존재
- 클래스는 확장 <> 인터페이스는 실행
- void라는 반환 타입과 상속이 없는 인터페이스를 어노테이션이라 한다.
- 저장될 땐 Class 파일로 저장된다; 클래스는 아니고 클래스로 인해 실행된다. Class 파일로 저장되기 때문이다. 클래스의 일종이라고 하면 안된다.
- 외부 라이브러리로 접근하기 위해 사용한다.
- (public static final) 생략 가능; set 사용 불가
- (public abstract) void te();
- 인터페이스에 static 메소드(오버라이드 할 수 없음)와 default method도 가능함(오버라이드 선택 가능)



```java
팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데,
이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의

메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 
해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의


 
작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.

또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, 
Collections.sort()를 하기 위해서 Comparable 인터페이스를 

상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.



```

## 구성요소
 * public interface 인터페이스명 { 
 * [public] [static] [final] 자료형 상수 
 * [public] [abstract] 반환형 추상 메소드;   // 메소드 앞에 static 사용 불가
 * }

 * public class InterfaceImp implements InterfaceCreate  // 여기서 클래스는 인터페이스를 구현해야 하는 구현체라고 부른다.

## 인터페이스와 어노테이션의 차이
- 인터페이스는 독립적인 메소드 사용하고 어노테이션은 메타데이터를 이용한다.
- 인터페이스는 라이브러리로 구현하고 어노테이션은 설정파일로 구현한다  
- 설정파일: xml, 프로퍼티 파일


## 인터페이스 예제
 * //구현체의 인스턴스를 생성한다. InterfaceImp interfaceImp = new InterfaceImp( );

 * //구현체를 통하여 인터페이스를 인스턴스화로 인스턴스를 생성한다.
 *  InterfaceCreate interfaceCreate = new InterfaceImp( );  // interfaceImp는 클래스, InterfaceCreate는 인터페이스
 
## 인터페이스 다형성
 * package jg.begin.start.jae_0311;
 * 
 * public class AiCall {
 * 
 *   public static void main(String[] args) {
 *     Aia aia = new Aia(); // aia 라는 클래스를 직접 상속받으면 부모의 메소드 모두 사용 가능.
 *     Aib aib = new Aib(); 
 * 
 *     Ai ai = new Aia(); // ai는 인터페이스, Aia는 클래스; 위처럼 부모가 아닌 것들도 상속받는 게 아니라 아래처럼 부모에게만 상속받은 것을 사용할 수 있게 하는 것이 인터페이스(다형성)을 사용하는 이유; 즉 인터페이스에 있는 메소드만 사용 가능하다.
 * - 수정과 변동이 가능하게 하는 인터페이스는 스택에 담아 수정할 수 있게 한다. 구현체는 호출의 역할.
 *     
 *   }
 * 
 * }


### 추상 클래스와의 공통점
- 추상 메소드를 가지고, 강제하고, 다형성 기능을 가진다. + 외부 접근
- 실행하면 구현체로 넘어간다.

### 차이점
- 추상클래스는 일부만 모르고 인터페이스는 다 모른다.
- 예시: 버전업을 하는 데이스베이스는 지속적인 업데이트가 필요하여 인터페이스가 적합. 이유: 추상 클래스로 하려면 extend를 계속 해주어야 하는데 클래스는 다중상속이 안된다. 아예 모르는 곳에 사용하기 적합하다. 여러개의 추상 메소드를 사용할 때 사용.
- 추상클래스는 내부에서 알고있는 라이브러리에 사용하기 적합하다. 추상 메소드도 1개만 사용할 때 사용.


## 실체 클래스
 * package min.k.interfaceclass.move;
 * // 클래스를 통해서 인터페이스의 구현체를 생성한다
 *  Bird Flyable ImpBird . 
 * public class ImpBird extends Bird implements Flyable { 
 * @Override 
 * public void fly( ) { 
 * System.out.print( 나는 것은 " "); 
 * } 
 * }

## 인터페이스 진행 방향
 * public class InterfaceAB implements InterfaceB, Interface A;  // A에서 B로 진행방향
 * 
 * public class ImpBird extends Bird implements Flyable  // 인터페이스가 먼저 진행, 다음 extend 클래스

## 객체 이름이 같은 경우, 팩토리 만들기
 * package jg.begin.start.jae_0311_test;
 * 
 * public class MessageCall {
 * 
 *   public static void main(String[] args) {
 * 
 *     Message message = null;
 *     message = new MessageKr();
 *     System.out.println(message);
 *     message = new MessageEn();
 *     System.err.println(message);
 *     message.call("홍길동");
 *   }
 * 
 * }

- 두 개의 message는 다른 주소를 가지고 있긴 하다.

 * package jg.begin.start.jae_0311_test;
 * 
 * public class Factory {
 * 
 *   public static Message create(String name) {
 * 
 *     if (name.equals("messsagekr")) {
 *       return new MessageKr();
 *     }
 * 
 *     else if (name.equals("messsageen")) {
 *       return new MessageEn();
 *     }
 * 
 *     else {
 *       return null;
 *     }
 * 
 *   }
 * 
 * }
 * //팩토리로 반환해 주어야 할 인터페이스 지정
 * 
 * package jg.begin.start.jae_0311_test;
 * 
 * public class MessageCall {
 * 
 *   public static void main(String[] args) {
 * 
 *     Message message = null;
 * 
 *     message = Factory.create("messageKr");  // create를 사용해서 객체 지정, 
 *     message.call(“홍길동”);
 *   }
 * 
 * }
- new 가 아니라 스택에만 있어 홍길동을 호출하자마자 소멸됨.

## 1. 부모가 가진 추상 메소드를 받아 조정하는 것; 더 자주 사용
 * package min.k.interfaceclass.move;
 * // 클래스를 통해서 인터페이스의 구현체를 생성한다
 *  Bird Flyable ImpBird . 
 * public class ImpBird extends Bird implements Flyable { 
 * @Override 
 * public void fly( ) { 
 * System.out.print( 나는 것은 " "); 
 * } 
 * }


## 인터페이스 사용 2.  구현체가 가지고 있는 구상 메소드를 리턴해서 결과 보여주기
 * package jg.begin.start.jae_0311_test_2;
 * 
 * public class MountBody implements Mounting {
 * 
 *   @Override
 *   public int sum(int i) {
 *     return process(i);
 *   }
 * 
 *   public int process(int j) {
 *     int result = 0;
 *     for (int i = 0; i <= j; i++) {
 * 
 *       result = result + j;
 *     }
 *     return result;
 * 
 *   }
 * 
 * }


## 인터페이스 추상 클래스 사용
- 인터페이스는 데이터베이스 연동 위해 사용, 추상 클래스는 저장 안하고 메모장에 저장하려면 사용

## 마커 인터페이스
- 메소드가 있으면 오버라이드 해버려야 하기 때문에 이런 것을 안하기 위해 사용.
- 자바의 마커 인터페이스란 일반적인 인터페이스와 동일하지만 사실상 아무 메서드도 선언하지 않은 그런 인터페이스를 말한다. 예를들어 다음과 같다.
- 얼핏 보기엔 조금 난해한 코드이다. 인터페이스만 있고 메서드가 없으니 어디에다 쓸지도 난해하다. 자바로 코딩을 하다보면 저런 인터페이스가 종종 있긴하다. 자바의 대표적인 마커 인터페이스로는 우리가 흔히 아는 Serializable, Cloneable 와 흔히 알지는 못하지만 Spring에서 event리스너를 사용한다면 종종 보이는 EventListener 라는 인터페이스도 있다. 참고로 Spring의 ApplicationListener 인터페이스가 상속받고 있다. 아무튼 이런 인터페이스는 어떻게 무엇을 위해 만들어 졌나..
- 뭔가 대단한거 처럼 보일 수 도 있지만 실질적으로는 아주 간단하다. 대부분의 경우에는 단순한 타입체크라고 할 수 있다. (물론 아닌 인터페이스도 있을 수도 있다. 확실하지 않아서… 그래서 대부분이라고 표기를 했다. )
자바의 대표적인 마커 인터페이스인 Serializable 를 살펴볼까 한다. Serializable 인터페이스는 다음과 같다.

## 마커 인터페이스 설명 2
- 자바에서 객체 직렬화는 Serializable 이라는 인터페이스를 implements 하면 된다. 그런데 이 인터페이스는 구현해야 할 메소드가 하나도 없다. 단지, 객체가 직렬화 대상임을 알려주는 일종의 마커(Marker) 역할을 한다. 그래서 이렇게 메소드를 하나도 가지지 않는 인터페이스를 마커인터페이스(Marker Interface)라 부른다. - 혹자는 태그(tag)인터페이스라고 부르기도 한다 
- 마커 인터페이스에는 이 외에도 Cloneable, EventListener 등이 있다. 그럼 왜 이런 인터페이스를 만드는 걸까? 아니, 이런 인터페이스를 만들면 어떻게 하겠다는 뜻일까?
- 대부분의 경우 특정 작업을 하기 전에 해당 타입을 체크하는 용도로 사용된다. 
- 이를 테면 객체를 복제하는 작업을 하려면 Cloneable인터페이스를 마커인터페이스로 지정해 놓아야 한다. 실제 클론 메소드가 호출되는건 Object 클래스내에 들어 있다. 해당 인터페이스의 타입이 아닐경우 예외가 발생한다.

## 마커 인터페이스와 어노테이션 인터페이스 차이 1
- annotation 이 이를 대체할 수도 있겠지만, marker interface 는 annotation 에 비해 두 가지 장점이 있다.
    1. marker interface 는 표시된 클래스의 인스턴스에 의해 구현되는 타입을 정의한다.
    2. 더 정확한 목표를 가질 수 있다. ( annotation 은 class 한정이 아니다. )
- annotation 도 장점이 있다. 
    1. 주요 장점은 이미 발표되어 사용 중이라도 기본적으로 하나 이상의 주석 타입 요소들을 추가함으로써 더 많은 정보를 주석 타입에 추가할 수 있다.
즉 점점 진화하기가 수월하고 더 많은 정보를 가질 수 있지만 marker interface 는 그렇지 않다.
    2. annotation 은 더 큰 주석 관리시스템의 일부이다.
- marker 를 클래스나 인터페이스가 아닌 다른 프로그램 요소에 적용할 때는 annotation 을 사용해야 한다.
클래스와 인터페이스만이 인터페이스를 implements 하거나 extends 할 수 있기 때문이다.

## 마커 인터페이스와 마커 어노테이션 차이 2
- 마커 인터페이스 같은 경우에는 컴파일 시점에 발견할 수 있다는 큰 장점이 있다. 그리고 또한 적용범위를 좀 더 세밀하게 지정 할 수 있다.
- 만약 어노테이션 자료형을 선언할 때 target 에 ElementType.TYPE 이라고 지정해서 사용한다고 하면 ElementType.TYPE 은 클래스 뿐만 아니라 인터페이스에도 적용 가능하다. 그런데 특정한 인터페이스를 구현한 클래스에만 적용할 수 있어야 하는 마커가 필요하다가 해보자. 마커 인터페이스를 쓴다면 그 특정 인터페이스를 상속 하도록 선언만 하면 된다. 그럼 마커를 상속한 모든 자료형은 자동으로 그 특정 인터페이스의 하휘 자료형이 된다.
- 그렇다면 마커 어노테이션의 장점은 뭘까? 마커 아노테이션은 유연하게 확장이 가능하다. 어노테이션을 만들어 사용한 뒤에도 계속적으로 더 많은 정보를 추가 할 수 있는 것이 큰 장점이다. 예를들어 어떤 어노테이션을 만들고 배포를 한 뒤에 뭔가 더 정보를 추가 하고 싶다면 새로 추가 된 요소들에 대해 default 값을 갖게 하면 하위 호환성도 지킬 수 있으며 처음에는 마커 어노테이션으로 시작했다가 나중에는 기능이 많은 어노테이션으로 진화 가능하다.
- 하지만 인터페이스 경우에는 메서드를 만드는 순간 하위 호환성이 깨지므로 마커 어노테이션처럼 지속적인 진화는 불가능하다.
- 마커 어노테이션과 마커 인터페이스 중 둘 중 어느게 낫다고 할 수 없을 거 같다. 각각의 쓰임새가 다르기 때문이다. 위에서 말했듯이 새로운 메서드가 없는 자료형을 정의하고 싶다면 마커 인터페이스를 이용해야 하고 클래스나 인터페이스 이외의 마커를 달아야 하고 앞으로도 더 많은 추가 정보가 있다고 생각하면 마커 어노테이션을 사용하면 된다. 어떤 쓰임인지 잘 판단하고 만들어야 할 듯 싶다.
- 참고로 Spring의 대표적인 마커 인터페이스는 AwareSpring data에 대표적인 마커 인터페이스는 Repository등이 있다. 좀 더 찾아 볼라고 했는데 귀찮.. 개발하다가 나오겠지 뭐..


### Serializable
- public interface Serializable { }

