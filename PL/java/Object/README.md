# 객체
```java
객체지향 프로그래밍

간단히 설명하면 프로그램을 만들 때, 상태와 행위로 이루어진 객체들을 만들어서 그 객체들간의 조립, 

의사소통을 통해 하나의 프로그램을 만드는 것이다.


 객체 참조

C++같은 프로그래밍 언어에서는 변수에 객체를 담을 수 있다. 하지만 자바는 변수에 오직 객체에 대한 참조만 담을 수 있다. 

***** 아주 중요 ******

객체 참조를 담고 있는 변수를 다른 변수에 할당하면 같은 객체에 대한 참조를 갖게 된다.

즉, 같은 객체를 가리키고 조작함.

null 값은 예상하지 못한 상황에서 위험할 수 있으니 옵션값에는 null사용을 권장하지 않는다.

date = LocalDate.of(year, month, 1); // 지정한 월의 1일을 가리킴

date = date.plusDays(1); // 1일 후

첫 번째 객체 date는 지정한 월의 1일을 가리키고 있다가

두 번째 문장에서 +1일을 하면서 새로운 객체를 참조한다.

그러면 첫 번째에 가리키고 있던 객체는 그에 대한 참조를 가진 변수가 없으므로 가비지 컬렉션에 의해 메모리를 정리하게 된다.*****
```

# 클래스
```java

public class Employee{

private String name;

private double salary;

}

Employee클래스를 선언하고 그 안의 인스턴스 변수를 만들었다.

인스턴스 변수는 객체의 인스턴스가 생성되었을 때 가질 수 있는 상태(변수)들이다. 인스턴스 변수는 보통 private로 선언하는데 

이것이 바람직한 이유는 프로그램의 어느 부분이 변수를 변경할 수 있는지 제어하고, 언제든지 내부 표현을 변경할 수 있다는 것이다.

메서드는 대부분 public 으로 선언한다. 때로는 헬퍼메서드를 같은 클래스에 속한 다른 메서드에서만 사용하도록 제한하는 

private으로 선언한다. 또 클래스 사용자와 관련이 없는 메서드는 특히 세부 구현에 의존할 때 private으로 선언해야한다.

this 참조

객체에 있는 메서드를 호출 할 때는 해당 객체를 this로 접근할 수 있다.

* 일부는 지역 변수와 인스턴스 변수를 명확히 구별하기 위해 사용하기도 함

public void raiseSalary(double byPercent){} 라는 함수가 있으면 엄격하게는 파라미터를 하나가 아니라 객체에 대한 참조도 같이 있는 것이다.

값을 이용한 호출

***** 아주중요 *****

메서드에 객체를 전달하면 해당 메서드가 객체 참조의 사본을 얻는다. 

그리고 이 참조를 통해 메서드는 파라미터객체에 접근하거나 파라미터 객체를 변경할 수 있다.

하지만 자바에서 기본 타입 파라미터를 업데이트하는 메서드를 작성할 수 없다. (*8가지 기본타입)

public void increaseRandomly(double x){

double amount = x * generator.nextDouble();

x += amout; // 안된다.

}

이유는 메서드에서 복사된 값이 증가하고 줄어들긴 하지만 변수의 유효범위를 벗어나고나면 해당 연산의 효력을 잃는다.

마찬가지로 객체 참조를 다른것으로 변경하는 메서드도 작성할 수 없다.

public void replaceWithZombie(Employee e){

e = new Employee("",0); // 안된다.

}

***** 자바가 객체에 '참조를 이용한 호출'로 알고 있는 사람들이 많은데 틀렸다.

참조를 이용한 호출을 지원하는 프로그래밍언어들은 파라미터 변수의 내용을 바꿀 수 있다.

자바에서는 기본타입은 물론 객체 참조까지 모두 파라미터가 값으로 전달된다.

생성자

생성자는 해당 클래스의 이름으로 구현하고 생성했을 때 필요한 작업을 하면 된다.

public 으로 생성하는 경우도 있고 private으로 생성하는 경우도 있다.

private으로 하는 경우는 '팩토리 메서드'를 이용해서 객체를 얻는다.

*생성자는 오버로딩이 가능하다 즉, 두 가지 이상 다른 버전의 생성자를 제공할 수 있다. 생성자 이름은 같지만 파라미터 

개수, 종류가 다른 경우에 사용한다.

*생성자를 안쓰면 인자가 없는 디폴트생성자를 자동으로 만들어 주는데 파라미터가 있는 생성자를 프로그래머가 만들면 

디폴트생성자는 생기지 않는다.

*생성자 안에서 인스턴스 변수를 명시적으로 설정하지 않으면 자동으로 기본값이 설정된다.

- 숫자는 0, boolean값은 false, 객체 참조는 null이 기본값이다.

*자바에 소멸자는 없다. 다만 가비지콜렉션이 메모리는 해제할 때 finalize()라는 메서드를 호출하므로 거기다가 

유언(?)을 작성하면 된다. 하지만 이 메커니즘이 언제 일어날지 모르기 때문에 사용하지 말아야한다.
```

# 메소드
```java
접근자 메서드와 변경자 메서드

호출 대상 객체를 변경하는 메서드를 변경자, 객체를 변경하지 않는 메서드를 접근자라고 한다.

ArrayList 클래스의 add메서드가 변경자의 예다. add를 호출하면 배열리스트 객체가 변경된다.

* 이슈는 대부분의 컴퓨터는 CPU가 여러개라서 어떻게 안전하게 동시 접근하느냐다. 이 문제를 해결하는 방법은 

접근자 메서드만 제공해서 객체를 변경할 수 없게하는 것인데 여전히 객체 변경이 필요할 때가 많다.
```

# 정적 메서드
```java
정적변수

클래스 안에 있는 변수를 static으로 선언하면 해당 변수는 클래스당 "하나"만 있게 된다.

사실 더 적절한 용어는 '클래스 변수' 라고 할 수 있다.

정적상수

변경 가능한 정적 변수는 드물지만, 정적 상수는 아주 일반적이다.

public static final double PI = 3.14159265358979323846;

정적메서드

public class Math{

public static double pow(double base ,  double exponent){...}

}

Math클래스의 pow메서드는 정적 메서드다. 왜 인스턴스 메서드로 만들지 않았을까?

자바에서 기본 타입(8가지)은 클래스가 아니므로 double의 인스턴스 메서드가 될 수 없다.

정적메서드를 사용하는 또 다른 이유는 다른 사람이 만든 클래스에 부가 기능을 제공하는 것이다.

예를 들어 주어진 범위에 속한 임의의 정수를 돌려준 메서드를 만든다면 어떨까?

표준 라이브러리의 Random클래스에 메서드를 추가 할 수 없다. 그러나 정적메서드를 이용하면 위의 메서드를 만들 수 있다.

public class RandomNumbers{

public static int nextInt(Random generator, int low , int high){

return low + generator.nextInt(high - low +1);

}

}

팩토리 메서드

정적 메서드는 팩토리메서드를 만드는 데 사용한다.

팩토리메서드는 부모클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며, 자식 클래스가 어떤 객체를 생성할지 결정하도록 하는 패턴 
```
