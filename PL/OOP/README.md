# OOP
[evan](https://evan-moon.github.io/2019/08/24/what-is-object-oriented-programming/)

## 클래스와 추상화와 # 객체
* Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념
```java
아이폰7 -> 아이폰 -> 스마트폰 -> 휴대전화 -> 무선 전화기 -> 전화기 -> 통신 기기 -> 기계…

결국 이렇게 상위 개념을 추적해나가면서 설계하는 것이 OOP의 기초이고, 이때 아이폰7, 아이폰과 같은 개념들을 
클래스(Class)라고 부르는 것이다. 그리고 방금 했던 것처럼 상위 개념을 만들어나가는 행위 자체를 추상화(Abstraction)라고 한다. 
추상화는 밑에서 다시 한번 설명할테니 일단 지금은 클래스라는 개념만 기억하도록 하자.

그럼 객체(Object)는 무엇일까? 필자는 방금 클래스를 설명하면서 개념이라는 단어를 굉장히 많이 사용했다. 
말 그대로 클래스의 역할은 어떠한 개념을 의미하는 것이다. 하지만 개념이라는 것 그 자체 만으로는 현실의 물건이 될 수는 없는 법이다.

잘 생각해보면 아이폰7이라는 것 또한 그냥 어떠한 제품 라인의 이름이다. 어떤 고유한 물건의 이름이 아니라는 것이다.
여기서 필자가 말하는 고유하다라는 의미는 전 세계에 단 한개만 존재하는 수준의 고유함이다. 당장 내 아이폰7과 
친구의 아이폰7만 봐도 실제로는 다른 아이폰7이지 않은가?

즉, 아이폰7이라는 클래스는 어떠한 실체가 있는 게 아니라는 것이다. 아이폰7 클래스에는 CPU, 디스플레이 해상도, 
메모리와 같은 사양이 정의되어 있을 것이고 이를 기반으로 공장에서 실제 아이폰7을 찍어내고 일련번호를 부여한 후 
출고하고나면 그제서야 우리 손에 잡을 수 있는 물건인 아이폰7이 되는 것이다. 이때 생산된 아이폰7에는 고유한 ID인 
일련번호가 부여되었기 때문에 우리는 전 세계에 일련번호가 1234인 아이폰7은 단 하나밖에 없다는 사실을 알 수 있다.

이때 이렇게 생산된 아이폰7들을 객체라고 할 수 있다.

즉, 클래스는 일종의 설계도이고 이것을 사용하여 우리가 사용할 수 있는 실제 물건으로 만들어내는 행위가 반드시 필요하다. 
그리고 객체는 클래스를 사용하여 생성한 실제 물건이다.

이러한 OOP의 설계 접근 방식으로 우리의 일상 속에 보이는 대부분의 개념들을 추상화할 수 있는데, 
그냥 평소에 보이는 모든 것들을 이렇게 추상화해보는 연습을 하면 나름 재미도 있다. 몇가지 예를 들어보겠다.
```

## 인스턴스
```java
클래스(Class) VS 객체(Object)
클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
객체(Object) VS 인스턴스(Instance)
클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
객체는 ‘실체’, 인스턴스는 ‘관계’에 초점을 맞춘다.
객체를 ‘클래스의 인스턴스’라고도 부른다.
https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
```

## 추상화
```java
추상이라는 단어의 뜻부터 한번 생각해보자. 추상은 어떠한 존재가 가지고 있는 여러가지의 속성 중에서 
특정한 속성을 가려내어 포착하는 것을 의미한다. 대표적인 추상파 화가 중 한명인 피카소가 소를 점점 추상화하며 
그려가는 과정을 한번 살펴보면 추상화가 어떤 것인지 조금 더 이해가 된다.

렇듯, 추상화라는 것은 그 존재가 가지고 있는 가장 특징적인 속성들을 파악해나가는 것을 의미한다.

우리가 방금 전 아이폰7의 상위 개념인 아이폰을 떠올리게 되는 과정은 꽤나 직관적으로 진행되었지만 
사실 추상화를 그렇게 직관적으로 접근하려고 하면 더 방향을 잡기가 힘들다. 원래대로라면 아이폰이라는 
상위 개념을 만들고자 했을 때 아이폰7 뿐만이 아니라 다른 아이폰 시리즈들까지 모두 포함할 수 있는 아이폰들의 
공통된 특성을 먼저 찾는 것이 올바른 순서이다. 이렇게 만들어진 올바른 상위 개념의 속성은 그 개념의
하위 개념들에게 공통적으로 적용할 수 있는 속성이 된다.
```

## 상속
* 추상화가 잘 된 클래스를 만들어 놓으면 속성이 필요한 다른 클래스를 생성할 때 그대로 재사용할 수 있다는 말이다
```java
즉, 추상화가 잘된 클래스를 하나만 만들어놓는다면 그와 비슷한 속성이 필요한 다른 클래스를 생성할 때 
그대로 재사용할 수 있다는 말이다. 그리고 만약 아이폰 시리즈 전체에 걸친 변경사항이 생겼을 때도 
IPhone7, IPhoneX와 같은 클래스는 건드릴 필요없이 IPhone 클래스 하나만 고치면 이 클래스를 상속받은 
모든 하위 클래스에도 자동으로 적용되므로 개발 기간도 단축시킬 수 있고 휴먼 에러가 발생할 확률도 줄일 수 있다.

하지만 여기서 만약 요구사항이 변경되어서 갤럭시 시리즈를 만들어야한다면 어떻게 될까? 갤럭시 시리즈는 
iOS가 아니라 Android를 사용하고, 제조사도 애플이 아니라 삼성이기 때문에 우리가 방금 만든 IPhone 클래스를 
사용할 수는 없다. 이때 우리는 IPhone 클래스를 그대로 냅두고 그냥 Galaxy 클래스를 새로 만들 수도 있지만 
SmartPhone이라는 한단계 더 상위 개념을 만드는 방향으로 가닥을 잡을 수도 있다.

위의 코드에서 super 메소드는 부모 클래스의 생성자를 호출하는 메소드이다. 부모 클래스를 Super Class, 
자식 클래스를 Sub Class라고 부르기도 하기 때문에 부모와 관련된 키워드 역시 super를 사용하는 것이다.

그리고 이때 자식 클래스인 IPhone7이나 GalaxyS10 클래스가 부모 클래스의 manufacturer나 os 속성을 덮어쓰게 
할 수도 있는데, 이러한 작업을 오버라이딩(Overriding)이라고 한다. 안드로이드 개발을 하다보면 밥먹듯이 쓰는
@Override 데코레이터도 부모 클래스의 메소드를 덮어쓰는 방식으로 세부 구현을 진행하는 것이다.

이러한 OOP의 클래스 의존관계는 클래스의 재사용성을 높혀주는 방법이기도 하지만, 너무 클래스의 상속 관계가 
복잡해지게 되면 개발자가 전체 구조를 파악하기가 힘들다는 단점도 가지고 있으므로 개발자가 확실한 의도를 
가지고 적당한 선에서 상속 관계를 설계하는 것이 중요하다.(근데 이 적당한 선의 기준이 개발자마다 다 다르다는 게 함정)
```

## 캡슐화
```java
캡슐화(Encapsulation)는 어떠한 클래스를 사용할 때 내부 동작이 어떻게 돌아가는지 모르더라도 사용법만 
알면 쓸 수 있도록 클래스 내부를 감추는 기법이다. 클래스를 캡슐화 함으로써 클래스를 사용하는 쪽에서는 
머리 아프게 해당 클래스의 내부 로직을 파악할 필요가 없어진다. 또한 클래스 내에서 사용되는 변수나 메소드를
원하는 대로 감출 수 있기 때문에 필요 이상의 변수나 메소드가 클래스 외부로 노출되는 것을 방어햐여 보안도 챙길 수 있다.

이렇게 클래스 내부의 데이터를 감추는 것을 정보 은닉(Information Hiding)이라고 하며, 
보통 public, private, protected 같은 접근제한자를 사용하여 원하는 정보를 감추거나 노출시킬 수 있다.

접근제한자는 Java 뿐만 아니라 TypeScript, Ruby, C++ 등과 같이 OOP를 지원하는 많은 프로그래밍 
언어들도 가지고 있는 기능이므로 이 개념을 잘 알아두면 클래스를 설계할 때 원하는 정보만 노출시키고 
원하지 않는 정보는 감추는 방법을 사용하여 보안도 지킬 수 있고 클래스를 가져다 쓰는 사용자로 하여금 
쓸데없는 고민을 안하게 해줄 수도 있다.
```

## 다형성
* 다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
```java
다형성(Polymorphism)은 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것을 의미한다. 
다형성은 어떤 한가지 기능을 의미하는 것이 아니라 개념이기 때문에 여러가지 방법으로 표현할 수 있다.

Java에서 다형성을 위한 대표적인 기능은 바로 추상 클래스(Abstract Class)와 인터페이스(Interface), 
그리고 Overloading이 있다. 추상 클래스와 인터페이스는 사실 그 용도가 조금 다르지만 필자가 예로 들 
간단한 예시에서는 그 차이를 크게 느끼기 힘들기도 하고 무엇보다 이 포스팅은 Java 포스팅이 아니라 단순히 
다형성을 설명하기 위함이므로 필자는 이 중 추상 클래스만을 사용할 것이다.

그럼 이 기능들이 어떤 역할을 하는 지 살펴보면서 다형성이 무엇인가를 좀 더 자세히 알아보도록 하자. 
먼저, 추상 클래스를 사용하여 다형성을 만족시키는 예시를 먼저 설명할텐데, 사실 다형성이라는 단어를 
모르고 있던 분들이라도 자신도 모르게 이런 설계 패턴을 사용하고 있었을 수도 있을 정도로 기본적인 예시이다.

추상 클래스를 사용한 다형성 구현
추상 클래스는 Java에서 다형성을 만족시키기 위해 자주 사용되는 대표적인 기능이다. 말로만 설명하면 
재미가 없으니 한번 코드를 직접 눈으로 보는 것이 좋은데, 필자는 오버워치를 좋아하기 때문에 추상 클래스에
대한 예시도 오버워치를 가져와서 설명하겠다.

자, 필자는 이제 오버워치의 여러 영웅들을 클래스로 만드려고 한다. 오버워치의 영웅들은 공통적으로 
궁극기 게이지가 찼을 때 Q 버튼을 누르면 궁극기가 발동된다라는 기능을 가지고 있다. 하지만 오버워치의 
영웅들은 각자 특색에 맞게 다른 궁극기를 가지고 있는데, 라인하르트는 망치를 내리치며 다른 영웅들을 
기절시키고 맥크리는 시야에 보이는 여러 영웅에게 동시에 헤드샷을 날릴 수 있으며 메이는 로봇을 던져서 일정 범위 안의 영웅들을 얼린다.

이런 경우 다형성을 가지지 않은 오버워치 영웅 클래스는 다음과 같은 모습을 보일 것이다.
이때 만약 우리가 Hero 클래스를 상속받은 영웅 클래스들의 궁극기를 발동시키고 싶다면 어떻게 해야할까? 
안봐도 뻔하겠지만 눈물나는 if문 또는 switch문의 향연이 펼쳐질 것이다.

모든 영웅들의 궁극기 발동 메소드의 이름이 다르기 때문에 달리 방도가 없다. 그리고 추가적으로 
Hero 클래스에는 궁극기 발동 메소드가 없기 때문에 객체를 해당 영웅의 클래스로 형변환 해줘야하는 불편한 작업도 해야한다.

그래도 혹시 이 두 기능이 뭐가 다른지 궁금하신 분이 있을 것 같으니 최대한 간단히만 설명하고 넘어가자면, 
추상 클래스는 어떤 클래스의 기능을 그대로 사용하면서 그 기능을 확장하고 싶을 때 사용하는 것이고 인터페이스는
아무런 구현체가 없는 그냥 껍데기만 구현하는 것이다. 그렇기 때문에 인터페이스에는 자세한 메소드의 구현체가 
들어갈 수 없지만 추상 클래스는 자체적인 메소드의 구현체를 가질 수도 있다.(Java 8부터는 default 키워드를 
사용하여 인터페이스에도 메소드 구현체를 넣을 수 있게 변경되긴했다. 덕분에 구분이 더 애매해짐.)

이 예제의 Hero 클래스는 name 멤버 변수를 생성자로부터 받아서 자신의 멤버 변수로 추가하는 기능을 가지고 
있기 때문에 추상 클래스를 사용하는 것이 더 적절하다. 그럼 이제 추상 클래스를 사용하여 ultimate 메소드의 구현을 강제해보도록 하자.
```
