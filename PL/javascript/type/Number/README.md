# [number](https://ko.javascript.info/types)
* Javascript 에서 숫자는 number 타입으로 구분되며, 메모리에 IEEE-754 형식을 이용해서 저장한다.
* IEEE-754 형태는 부호, 지수, 가수로 이루어 져 있으며, Javascript 에서는 32비트까지 표현이 가능하다.
* -(2⁵³-1) 부터 2⁵³ -1 까지는 정확히 IEEE-754로 표현될 수 있지만, 그 초과와 이하 는 IEEE-754로 직접 표현될 수 없으며 가까운 수나 0으로 반올림 한다.

```javascript
let n = 123;
n = 12.345;
숫자형(number type) 은 정수 및 부동소수점 숫자(floating point number)를 나타냅니다.

숫자형과 관련된 연산은 다양한데, 곱셈 *, 나눗셈 /, 덧셈 +, 뺄셈 - 등이 대표적입니다.

숫자형엔 일반적인 숫자 외에 Infinity, -Infinity, NaN같은 '특수 숫자 값(special numeric value)'이 포함됩니다.

Infinity는 어떤 숫자보다 더 큰 특수 값, 무한대(∞)를 나타냅니다.

어느 숫자든 0으로 나누면 무한대를 얻을 수 있습니다.

alert( 1 / 0 ); // 무한대
Infinity를 직접 참조할 수도 있습니다.

alert( Infinity ); // 무한대
NaN은 계산 중에 에러가 발생했다는 것을 나타내주는 값입니다. 
부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 NaN이 반환됩니다.

alert( "숫자가 아님" / 2 ); // NaN, 문자열을 숫자로 나누면 오류가 발생합니다.
NaN은 여간해선 바뀌지 않습니다. NaN에 어떤 추가 연산을 해도 결국 NaN이 반환됩니다.

alert( "숫자가 아님" / 2 + 5 ); // NaN
연산 과정 어디에선가 NaN이 반환되었다면, 이는 모든 결과에 영향을 미칩니다.

수학 연산은 안전합니다.
자바스크립트에서 행해지는 수학 연산은 '안전’하다고 볼 수 있습니다.
0으로 나눈다거나 숫자가 아닌 문자열을 숫자로 취급하는 등의 이례적인 연산이 자바스크립트에선 가능합니다.

말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽지 않습니다. 
NaN을 반환하며 연산이 종료될 뿐입니다.

현실에선 특수 숫자 값을 숫자로 취급하진 않습니다. 
하지만 자바스크립트에선 특수 숫자 값을 숫자형으로 분류합니다.

숫자를 다루는 방법에 대해선 숫자형 챕터에서 자세히 알아보도록 하겠습니다.
```

## 숫자 범위
```javascript
CMAScript로 표현할 수 있는 최솟값은 Number 객체의 MIN_VALUE 프로퍼티(Number.MIN_VALUE)에 저장된다. 
이 값은 브라우저마다 다르지만 보통 5e-324이다. 최댓값은 MAX_VALUE 프로퍼티에 저장되며, 
보통 1.7976931348623157e+308이다. 계산 결과가 범위를 벗어날 때에는 양수는 Infinity로, 음수는 -Infinity로 변환된다.

만약, 특정 변수가 유한한 숫자임을 확인하고 싶다면 다음과 같이 사용하면 된다.


var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result));		// false
```

## 소수
### 부동 소수점
* 부동소수점 숫자를 저장할 때에는 정수 저장에 비해 메모리를 두 배로 소모한다. 
* 만약 소수점 뒤에 숫자가 없다면 해당 숫자는 정수로 변환된다.
* 굉장히 크거나 작은 숫자를 표기할 때에는 'e-표기법[2]’을 쓴다. 이 표기법은 e 앞의 숫자에 10을 e 뒤의 숫자만큼 곱하는 것이다. 31,250,000은 var floatNum = 3.125e7;로 표기할 수 있으며, 0.0000003은 var floatnum = 3e-7;로 표기할 수 있다.
* 그러나 부동소수점 숫자는 사칙 연산에 있어 부정확하다. 예를 들어, 0.1과 0.2를 더하면 0.30000000000000004를 반환한다. 고로 다음의 코드와 같은 형식을 사용해서는 안 된다.

```javascript
Javascript 에서 소수를 정의하기 위해서는 
. 뒤에 숫자만 존재하면 가능하지만, 숫자가 없다면 무시되고 정수로 표현된다.
소수는 정수를 포함한 32비트 까지 표현이 가능하다. 그 이상은 반올림 처리된다.

console.log( 1.0 );
// 1

console.log( 1. );
// 1

console.log( .1 );
// 1

console.log( 1.11111111111111111111111111111111111 );
// 1.1111111111111112

console.log( 1111111.11111111111111111111111 );
// 1111111.111111111

console.log( 0.1 + 0.2 );
// 0.30000000000000004
```

### 지수 표기법
```javascript
너무 큰 숫자는 exponent 표기법을 사용하여 표현할 수 있다.
이때 e 는 대소문자를 가리지 않는다.
e 앞의 숫자를 뒤에 있는 숫자 만큼 10으로 곱한다.
앞의 숫자를 소수로 작성 할 수도 있다.
소수는 e 뒤에 -를 붙힘으로 표현할 수 있다.
```

## BigInt
```javascript
BigInt
내부 표현 방식 때문에 자바스크립트에선 
(253-1)(9007199254740991) 보다 큰 값 혹은 -(253-1) 보다 작은 정수는 '숫자형’을 사용해 나타낼 수 없습니다.

사실 대부분의 상황에서 이런 제약사항은 문제가 되지 않습니다. 
그렇지만 암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 
아주 높은 정밀도로 작업을 해야 할 때는 이런 큰 숫자가 필요합니다.

BigInt형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.

BigInt형 값은 정수 리터럴 끝에 n을 붙이면 만들 수 있습니다.

// 끝에 'n'이 붙으면 BigInt형 자료입니다.
const bigInt = 1234567890123456789012345678901234567890n;
BigInt형 숫자는 자주 쓰이지 않기 때문에 여기서 자세히 다루지 않고 별도의 챕터, 
BigInt에서 설명드리겠습니다. 아주 큰 숫자를 사용해야하는 경우라면 해당 챕터를 참고해 주시기바랍니다.

호환성 이슈
이 글이 작성된 시점엔 Firefox, Chrome, Edge, Safari에서만 BigInt를 지원합니다. 
IE에선 지원하지 않습니다.
```

## [0.1+0.2](https://velog.io/@coin46/0.1-0.2-0.3)

## 단항 연산자 +와 숫자형으로의 변환
```javascript
덧셈 연산자 +는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있습니다.

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않습니다. 
그러나 피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어납니다.

예시:

// 숫자에는 아무런 영향을 미치지 않습니다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0
단항 덧셈 연산자는 짧은 문법으로도 Number(...)와 동일한 일을 할 수 있게 해줍니다.

개발을 하다 보면 문자열을 숫자로 변환해야 하는 경우가 자주 생깁니다. 
HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때 같이 말이죠. 
실제로 폼에서 가지고 온 값은 대개 문자열 형태입니다.

이항 덧셈 연산자를 사용하면 아래와 같이 값이 문자열로 변해서 연결될 겁니다.

let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.
원하는 대로 값을 더해주려면, 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변화시키면 됩니다.

let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
// alert( Number(apples) + Number(oranges) ); // 5
```

## 숫자 관련 함수
```javascript
parseInt()
첫 문자가 숫자라면 10, 8, 16진수를 인식하고 그에 맞게 변환한다. 만약 숫자+문자의 형태라면, 앞의 숫자만 반환한다.


var num1 = parseInt("7BTOB");		// 7
var num2 = parseInt("");			// NaN
var num3 = parseInt("0xA");			// 16진수 10
var num4 = parseInt(22.5);			// 22
var num5 = parseInt("70");			// 70
var num6 = parseInt("0xf");			// 16진수 15
숫자형의 형식이 다양해 혼란을 야기할 수 있으므로 parseInt()에는 
진법을 나타내는 두 번째 매개변수를 넘길 수 있다. 만약 파싱하려는 값이 16진수임을 알고 있다면 
var num = parseInt("0xAF", 16)[5]과 같이 16진수임을 명확하게 알릴 수 있다.


parseFloat()
이 함수는 문자열에서 잘못된 부동소수점 숫자를 만날 때까지 파싱한다. 
예를 들어, "12.3.21"을 넘길 경우 12.3만 반환한다. 예시는 다음과 같다.


var num1 = parseFloat("7BTOB");			// 7
var num2 = parseFloat("0xA");			// 0
var num3 = parseFloat("22.5");			// 22.5
var num4 = parseFloat("12.3.21");		// 12.3
var num5 = parseFloat("03.21");			// 3.21
var num6 = parseFloat("3.125e7");		// 31250000
```
