# 절차지향
1. 루틴 서브루틴, 함수(프로시져) 등을 이용한 프로그래밍
2. 절차적으로 실행되는 것(X) -> 프로시져 콜, 즉 함수 호출을 통해서 재사용성을 얻어내는 것이 본질!
3. 장점 : 함수를 통한 코드의 재활용성 , 모듈화와 구조화에 용이함
4. 단점 : 프로시저 호출에 자원 낭비(최근 컴파일러, 하드웨어 성능향상으로 거의 상관없음)

# 객체지향
1. 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용ㅇ으로 서술하는 방식
2. 캡슐화, 상속, 다형성, 추상화 의 특징을 가짐
3. 장단점 : 상속(편리하지만 구조가 이상하게 변할 수있음), 인스턴스에 데이터 접근 불가, 새로운 데이터 형식을 정의할 수 있게 해줌




# C언어들 차이
## C언어
* C는 자바, 자바스크립트, 파이썬, PHP, GO와 같은 많은 언어들에 영향을 끼쳤다
* 컴퓨터가 빠르지 않은 시대에 만들어진 C는 리소스가 많이 없는 기계에서 작동할 때 유용하다
* 하드웨어와 매우 밀접하게 작동한다
	* Mars Rovers Curiosity(화성 탐사선): 화성 지면에 착지해서 나사에 사진을 보내는 역할; 250만줄의 C언어로 작성
 		* 탐사선이 메모리가 충분하지 않고 프로세싱 파워도 약하기 때문에 적게 공간을 쓰면서 빠른 언어가 필요했다.

## C++
* C언어에서 class를 가지고 있다.
* C의 superset; 확장 버전
* C와 속도와 하드웨어 밀접성은 차이가 없고 객체지향 언어라는 차이밖에 없다.
* C#은 개발 스피드가 빠르고 c는 컴퓨터 스피드가 빠르다.

## C#
* C#은 JAVA와 비슷하다. 마이크로소프트가 만든 JAVA라고 생각하면 된다.
* 기업용으로 만들었는데 엄청난 시간과 돈을 들였다. 닷넷 생태계를 위한 언어다.
* 백엔드, 프론트엔드, IOS앱, unity 3D(엑스박스, 플레이스테이션, ios,  Android 웹 용 게임 만들 수 있다.)

## C와 C#의 차이
* c#은 컴파일러의 도움을 받아 느리고 C는 수동으로 이루어지기 때문에 기계에 가까운 언어(로우 레벨)에서 빠르다.
* c#은 C++처럼 수동으로 작업할 것이 많아 없기 때문에 개발속도가 더 빠르다.

# Go 언어
1. 똑똑한 사람들이 만든 언어
2. 빠르고 아름답다.
	* 개발 스피드와 실행속도 모두 빠르다.
 	* 컴파일 언어라서 코딩이 끝나고 나면 0.1로 변환시키고 기계와 가까워서 실행속도도 빠르다.
 	* 파이썬, 자바스크립트보다 빠르고 때로는 자바보다 속도가 빠르거나 같다.
3. 배우기 싶다
	* for이 전부
4. 멀티 코어 컴퓨터에서도 사용할 수 있따.
	* 구글 다운로드 서버, 유튜브, 구글 크롬 다운로드
	* 트위치의 변환 프로세스
5. concurrency, parallelism

# annottion
* 이 어노테이션으로 인해 데이터의 유효성 검사 등을 쉽게 알 수 있고, 이와 관련한 코드가 깔끔해지게 됩니다.
* 일단 어노테이션의 용도는 다양한 목적이 있지만 메타 데이터의 비중이 가장 크다 할 수 있습니다.
* 메타-테이터(Meta-Data) : 데이터를 위한 데이터를 의미하며, 풀어 이야기하면 한 데이터에 대한 설명을 의미하는 데이터. (자신의 정보를 담고 있는 데이터)
* @ <-- 요놈은 기본적으로 컴파일러에게 이게 어노테이션이다라고 알린다. 

```java
 어노테이션의 용도 
 ⎼어노테이션은 크게 컴파일러 체크와 코드 분석을 위한 용도로 사용된다     .
 ⎼어노테이션의 컴파일러 체크는 컴파일 타임에 에러를 발생시켜 주어 개발자에서 위험 요소를 경고 해주거나 확인하는 목적으로도 사용된다. 
 ⎼어노테이션의 코드 분석은 메타데이터로서의 용도이며 메타데이터는 데이터에 대해 설명하는 데이터를 의미한다. 
 ⎼메타데이터로서 어노테이션의 효용을 가장 잘 느낄 수 있는 부분은 설정과 유효성 검사 부분이다 JEE .  


 ⎼어노테이션은 크게 다음과 같은 기능을 구현 할 수 있다. 
 ① 컴파일러를 위한 정보 ⎼주석이 오류를 감지 또는 경고를 억제하기 위해
 
1. 컴파일러에 의해 사용할 수 있다. ⎼컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공한다. 
 	예) @Override 어노테이션 ② 컴파일 시간 및 배포 시간 처리 
⎼소프트웨어 툴 등의 코드 파일 및 주석을 생성하기 위해 정보를 처리 할 수 있다 , 

2. XML . ⎼소프트웨어 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보를 제공한다. 
	예 설정 파일을 자동 생성 ) XML 
3. ③ 런타임 처리 ⎼일부 주석 런타임에 검사 할 수 있으며 실행시 특정 기능을 실행하도록 정보를 제공한다. 
	예 객체가 어플리케이션 내부에서 해야 할 역할 지정 등 ) (Servlet, Controller... ) 

(4) 어노테이션의 장점 
⎼어노테이션은 데이터에 대한 유효성 검사 조건을 어노테이션을 사용하여 클래스에 직접 명시함으로써 해당 데이터들에 대한 
유효 조건을 쉽게 파악할 수 있다. ⎼어노테이션은 코드의 코드가 깔끔해지고 어노테이션의 재사용도 가능해진다. 
① 코드의 가독성 증대 ⎼관련 코드 곁에 메타 데이터를 설정할 수 있으므로 코드의 가독성이 증대 된다. 
② 개발 효율성 증대 ⎼복잡한 스키마를 파악하지 않아도 되며 개발을 할 때 개발 툴과 컴파일러의 도움을 받을 수 있으므로 
XML 개발 효율성이 증대 된다. ⎼별도의 파서를 적용하지 않고도 간단히 런타임 시에 활용할 수 있는 편리함이 있다. 


(5) 어노테이션의 단점 
⎼어노테이션 처리 시 리플렉션을 통해 해당 클래스를 분석해야 하는 오버헤드가 있다. 
⎼어노테이션은 모듈이나 어플리케이션 전반적인 메타 데이터를 설정할 수 없다. 
⎼어노테이션의 범위는 클래스나 패키지 레벨로 한정되기 때문에 여러 클래스에 걸친 공통적인 설정이나 모듈 레벨 설정이 어렵다.
```

## Java에서 기본적으로 제공하는 어노테이션 종류
* Override
	* 선언한 메서드가 오버라이드 되었다는 것을 나타냅니다.
	* 만약 상위(부모) 클래스(또는 인터페이스)에서 해당 메서드를 찾을 수 없다면 컴파일 에러를 발생 시킵니다.
	* 따라서 만약 메서드가 슈퍼클래스와 매칭되지 않았으면 에러를 날려주지
* @Deprecated
	* 해당 메서드가 더 이상 사용되지 않음을 표시합니다.
	* 만약 사용할 경우 컴파일 경고를 발생 키십니다.
	* 해당 클래스/메소드 등은 더이상 지원하지 않으니 or  만들고 나니깐 별로 안좋은 부분이 많거나, 더 좋은 해결법이 생겼으니 사용하지 마시라는 의미야. 그럼에도 불구하고 네가 그걸 

* @SuppressWarnings
	* 선언한 곳의 컴파일 경고를 무시하도록 합니다.
* @SafeVarargs
	* Java7 부터 지원하며, 제너릭 같은 가변인자의 매개변수를 사용할 때의 경고를 무시합니다.
* @FunctionalInterface
	* Java8 부터 지원하며, 함수형 인터페이스를 지정하는 어노테이션입니다.
	* 만약 메서드가 존재하지 않거나, 1개 이상의 메서드(default 메서드 제외)가 존재할 경우 컴파일 오류를 발생 시킵니다.


## Annotation 선언위치(Placement)
* 어노테이션은 클래스, 인터페이스, 메소드, 메소드 파라미터, 필드, 지역변수 위에 위치할수있어.

## annotation 요소
```java
Annotation 요소 (Element)
자바 어노테이션은 값을 세팅할수있는 요소들을 가질수있는데  속성이나 파라미터 쯤이라고 볼수있지.
@Entity(tableName = "vehicles")
위에서는 tableName 이라는 이름의 요소를 하나 가지고있다는뜻이야. 값은 "vehicles" 이군. 

물론 아래와 같이 여러개의 요소를 가질수도있어.

@Entity(tableName = "vehicles", primaryKey = "id")
하나만 요소로 가질 경우 다음과 같이 짧게 줄여 쓸수도있지.

@InsertNew("yes")


```

## 메타 어노테이션
* 먼저 어노테이션의 구조를 보기 위해서 아래의 코드를 참고해 봅니다. (예를 위해 작성된 커스텀 어노테이션입니다.)
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
	boolean isCheck() default true;
}
```
* 먼저 1번, 2번의 어노테이션 선언에 쓰인 어노테이션은 메타 어노테이션(Meta Annotation)이라 하며 이를 이용해 커스텀 어노테이션을 작성할 수 있게 됩니다.

## 메타 어노테이션의 종류
```java
@Retention
자바 컴파일러가 어노테이션을 다루는 방법을 기술하며, 특정 시점까지 영향을 미치는지를 결정합니다.
종류는 다음과 같습니다.
RetentionPolicy.SOURCE : 컴파일 전까지만 유효. (컴파일 이후에는 사라짐)
RetentionPolicy.CLASS : 컴파일러가 클래스를 참조할 때까지 유효.
RetentionPolicy.RUNTIME : 컴파일 이후에도 JVM에 의해 계속 참조가 가능. (리플렉션 사용)


@Target
어노테이션이 적용할 위치를 선택합니다.
종류는 다음과 같습니다.
ElementType.PACKAGE : 패키지 선언
ElementType.TYPE : 타입 선언
ElementType.ANNOTATION_TYPE : 어노테이션 타입 선언
ElementType.CONSTRUCTOR : 생성자 선언
ElementType.FIELD : 멤버 변수 선언
ElementType.LOCAL_VARIABLE : 지역 변수 선언
ElementType.METHOD : 메서드 선언
ElementType.PARAMETER : 전달인자 선언
ElementType.TYPE_PARAMETER : 전달인자 타입 선언
ElementType.TYPE_USE : 타입 선언


@Documented
해당 어노테이션을 Javadoc에 포함시킵니다.


@Inherited
어노테이션의 상속을 가능하게 합니다.


@Repeatable
Java8 부터 지원하며, 연속적으로 어노테이션을 선언할 수 있게 해줍니다.


어노테이션은 기본적으로 인터페이스 형태를 취하고 있으며, 단지 interface 앞에 @ 표시를 해줍니다.
어노테이션의 필드에서는 enum, String이나 기본 자료형, 기본 자료형의 배열을 사용할 수 있습니다.
```

# OOP
[evan](https://evan-moon.github.io/2019/08/24/what-is-object-oriented-programming/)

## 클래스와 추상화와 # 객체
* Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념
```java
아이폰7 -> 아이폰 -> 스마트폰 -> 휴대전화 -> 무선 전화기 -> 전화기 -> 통신 기기 -> 기계…

결국 이렇게 상위 개념을 추적해나가면서 설계하는 것이 OOP의 기초이고, 이때 아이폰7, 아이폰과 같은 개념들을 
클래스(Class)라고 부르는 것이다. 그리고 방금 했던 것처럼 상위 개념을 만들어나가는 행위 자체를 추상화(Abstraction)라고 한다. 
추상화는 밑에서 다시 한번 설명할테니 일단 지금은 클래스라는 개념만 기억하도록 하자.

그럼 객체(Object)는 무엇일까? 필자는 방금 클래스를 설명하면서 개념이라는 단어를 굉장히 많이 사용했다. 
말 그대로 클래스의 역할은 어떠한 개념을 의미하는 것이다. 하지만 개념이라는 것 그 자체 만으로는 현실의 물건이 될 수는 없는 법이다.

잘 생각해보면 아이폰7이라는 것 또한 그냥 어떠한 제품 라인의 이름이다. 어떤 고유한 물건의 이름이 아니라는 것이다.
여기서 필자가 말하는 고유하다라는 의미는 전 세계에 단 한개만 존재하는 수준의 고유함이다. 당장 내 아이폰7과 
친구의 아이폰7만 봐도 실제로는 다른 아이폰7이지 않은가?

즉, 아이폰7이라는 클래스는 어떠한 실체가 있는 게 아니라는 것이다. 아이폰7 클래스에는 CPU, 디스플레이 해상도, 
메모리와 같은 사양이 정의되어 있을 것이고 이를 기반으로 공장에서 실제 아이폰7을 찍어내고 일련번호를 부여한 후 
출고하고나면 그제서야 우리 손에 잡을 수 있는 물건인 아이폰7이 되는 것이다. 이때 생산된 아이폰7에는 고유한 ID인 
일련번호가 부여되었기 때문에 우리는 전 세계에 일련번호가 1234인 아이폰7은 단 하나밖에 없다는 사실을 알 수 있다.

이때 이렇게 생산된 아이폰7들을 객체라고 할 수 있다.

즉, 클래스는 일종의 설계도이고 이것을 사용하여 우리가 사용할 수 있는 실제 물건으로 만들어내는 행위가 반드시 필요하다. 
그리고 객체는 클래스를 사용하여 생성한 실제 물건이다.

이러한 OOP의 설계 접근 방식으로 우리의 일상 속에 보이는 대부분의 개념들을 추상화할 수 있는데, 
그냥 평소에 보이는 모든 것들을 이렇게 추상화해보는 연습을 하면 나름 재미도 있다. 몇가지 예를 들어보겠다.
```

## 인스턴스
```java
클래스(Class) VS 객체(Object)
클래스는 ‘설계도’, 객체는 ‘설계도로 구현한 모든 대상’을 의미한다.
객체(Object) VS 인스턴스(Instance)
클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
객체는 ‘실체’, 인스턴스는 ‘관계’에 초점을 맞춘다.
객체를 ‘클래스의 인스턴스’라고도 부른다.
https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
```

## 추상화
```java
추상이라는 단어의 뜻부터 한번 생각해보자. 추상은 어떠한 존재가 가지고 있는 여러가지의 속성 중에서 
특정한 속성을 가려내어 포착하는 것을 의미한다. 대표적인 추상파 화가 중 한명인 피카소가 소를 점점 추상화하며 
그려가는 과정을 한번 살펴보면 추상화가 어떤 것인지 조금 더 이해가 된다.

렇듯, 추상화라는 것은 그 존재가 가지고 있는 가장 특징적인 속성들을 파악해나가는 것을 의미한다.

우리가 방금 전 아이폰7의 상위 개념인 아이폰을 떠올리게 되는 과정은 꽤나 직관적으로 진행되었지만 
사실 추상화를 그렇게 직관적으로 접근하려고 하면 더 방향을 잡기가 힘들다. 원래대로라면 아이폰이라는 
상위 개념을 만들고자 했을 때 아이폰7 뿐만이 아니라 다른 아이폰 시리즈들까지 모두 포함할 수 있는 아이폰들의 
공통된 특성을 먼저 찾는 것이 올바른 순서이다. 이렇게 만들어진 올바른 상위 개념의 속성은 그 개념의
하위 개념들에게 공통적으로 적용할 수 있는 속성이 된다.
```

## 상속
* 추상화가 잘 된 클래스를 만들어 놓으면 속성이 필요한 다른 클래스를 생성할 때 그대로 재사용할 수 있다는 말이다
```java
즉, 추상화가 잘된 클래스를 하나만 만들어놓는다면 그와 비슷한 속성이 필요한 다른 클래스를 생성할 때 
그대로 재사용할 수 있다는 말이다. 그리고 만약 아이폰 시리즈 전체에 걸친 변경사항이 생겼을 때도 
IPhone7, IPhoneX와 같은 클래스는 건드릴 필요없이 IPhone 클래스 하나만 고치면 이 클래스를 상속받은 
모든 하위 클래스에도 자동으로 적용되므로 개발 기간도 단축시킬 수 있고 휴먼 에러가 발생할 확률도 줄일 수 있다.

하지만 여기서 만약 요구사항이 변경되어서 갤럭시 시리즈를 만들어야한다면 어떻게 될까? 갤럭시 시리즈는 
iOS가 아니라 Android를 사용하고, 제조사도 애플이 아니라 삼성이기 때문에 우리가 방금 만든 IPhone 클래스를 
사용할 수는 없다. 이때 우리는 IPhone 클래스를 그대로 냅두고 그냥 Galaxy 클래스를 새로 만들 수도 있지만 
SmartPhone이라는 한단계 더 상위 개념을 만드는 방향으로 가닥을 잡을 수도 있다.

위의 코드에서 super 메소드는 부모 클래스의 생성자를 호출하는 메소드이다. 부모 클래스를 Super Class, 
자식 클래스를 Sub Class라고 부르기도 하기 때문에 부모와 관련된 키워드 역시 super를 사용하는 것이다.

그리고 이때 자식 클래스인 IPhone7이나 GalaxyS10 클래스가 부모 클래스의 manufacturer나 os 속성을 덮어쓰게 
할 수도 있는데, 이러한 작업을 오버라이딩(Overriding)이라고 한다. 안드로이드 개발을 하다보면 밥먹듯이 쓰는
@Override 데코레이터도 부모 클래스의 메소드를 덮어쓰는 방식으로 세부 구현을 진행하는 것이다.

이러한 OOP의 클래스 의존관계는 클래스의 재사용성을 높혀주는 방법이기도 하지만, 너무 클래스의 상속 관계가 
복잡해지게 되면 개발자가 전체 구조를 파악하기가 힘들다는 단점도 가지고 있으므로 개발자가 확실한 의도를 
가지고 적당한 선에서 상속 관계를 설계하는 것이 중요하다.(근데 이 적당한 선의 기준이 개발자마다 다 다르다는 게 함정)
```

## 캡슐화
```java
캡슐화(Encapsulation)는 어떠한 클래스를 사용할 때 내부 동작이 어떻게 돌아가는지 모르더라도 사용법만 
알면 쓸 수 있도록 클래스 내부를 감추는 기법이다. 클래스를 캡슐화 함으로써 클래스를 사용하는 쪽에서는 
머리 아프게 해당 클래스의 내부 로직을 파악할 필요가 없어진다. 또한 클래스 내에서 사용되는 변수나 메소드를
원하는 대로 감출 수 있기 때문에 필요 이상의 변수나 메소드가 클래스 외부로 노출되는 것을 방어햐여 보안도 챙길 수 있다.

이렇게 클래스 내부의 데이터를 감추는 것을 정보 은닉(Information Hiding)이라고 하며, 
보통 public, private, protected 같은 접근제한자를 사용하여 원하는 정보를 감추거나 노출시킬 수 있다.

접근제한자는 Java 뿐만 아니라 TypeScript, Ruby, C++ 등과 같이 OOP를 지원하는 많은 프로그래밍 
언어들도 가지고 있는 기능이므로 이 개념을 잘 알아두면 클래스를 설계할 때 원하는 정보만 노출시키고 
원하지 않는 정보는 감추는 방법을 사용하여 보안도 지킬 수 있고 클래스를 가져다 쓰는 사용자로 하여금 
쓸데없는 고민을 안하게 해줄 수도 있다.
```

## 다형성
```java
다형성(Polymorphism)은 어떤 하나의 변수명이나 함수명이 상황에 따라서 다르게 해석될 수 있는 것을 의미한다. 
다형성은 어떤 한가지 기능을 의미하는 것이 아니라 개념이기 때문에 여러가지 방법으로 표현할 수 있다.

Java에서 다형성을 위한 대표적인 기능은 바로 추상 클래스(Abstract Class)와 인터페이스(Interface), 
그리고 Overloading이 있다. 추상 클래스와 인터페이스는 사실 그 용도가 조금 다르지만 필자가 예로 들 
간단한 예시에서는 그 차이를 크게 느끼기 힘들기도 하고 무엇보다 이 포스팅은 Java 포스팅이 아니라 단순히 
다형성을 설명하기 위함이므로 필자는 이 중 추상 클래스만을 사용할 것이다.

그럼 이 기능들이 어떤 역할을 하는 지 살펴보면서 다형성이 무엇인가를 좀 더 자세히 알아보도록 하자. 
먼저, 추상 클래스를 사용하여 다형성을 만족시키는 예시를 먼저 설명할텐데, 사실 다형성이라는 단어를 
모르고 있던 분들이라도 자신도 모르게 이런 설계 패턴을 사용하고 있었을 수도 있을 정도로 기본적인 예시이다.

추상 클래스를 사용한 다형성 구현
추상 클래스는 Java에서 다형성을 만족시키기 위해 자주 사용되는 대표적인 기능이다. 말로만 설명하면 
재미가 없으니 한번 코드를 직접 눈으로 보는 것이 좋은데, 필자는 오버워치를 좋아하기 때문에 추상 클래스에
대한 예시도 오버워치를 가져와서 설명하겠다.

자, 필자는 이제 오버워치의 여러 영웅들을 클래스로 만드려고 한다. 오버워치의 영웅들은 공통적으로 
궁극기 게이지가 찼을 때 Q 버튼을 누르면 궁극기가 발동된다라는 기능을 가지고 있다. 하지만 오버워치의 
영웅들은 각자 특색에 맞게 다른 궁극기를 가지고 있는데, 라인하르트는 망치를 내리치며 다른 영웅들을 
기절시키고 맥크리는 시야에 보이는 여러 영웅에게 동시에 헤드샷을 날릴 수 있으며 메이는 로봇을 던져서 일정 범위 안의 영웅들을 얼린다.

이런 경우 다형성을 가지지 않은 오버워치 영웅 클래스는 다음과 같은 모습을 보일 것이다.
이때 만약 우리가 Hero 클래스를 상속받은 영웅 클래스들의 궁극기를 발동시키고 싶다면 어떻게 해야할까? 
안봐도 뻔하겠지만 눈물나는 if문 또는 switch문의 향연이 펼쳐질 것이다.

모든 영웅들의 궁극기 발동 메소드의 이름이 다르기 때문에 달리 방도가 없다. 그리고 추가적으로 
Hero 클래스에는 궁극기 발동 메소드가 없기 때문에 객체를 해당 영웅의 클래스로 형변환 해줘야하는 불편한 작업도 해야한다.

그래도 혹시 이 두 기능이 뭐가 다른지 궁금하신 분이 있을 것 같으니 최대한 간단히만 설명하고 넘어가자면, 
추상 클래스는 어떤 클래스의 기능을 그대로 사용하면서 그 기능을 확장하고 싶을 때 사용하는 것이고 인터페이스는
아무런 구현체가 없는 그냥 껍데기만 구현하는 것이다. 그렇기 때문에 인터페이스에는 자세한 메소드의 구현체가 
들어갈 수 없지만 추상 클래스는 자체적인 메소드의 구현체를 가질 수도 있다.(Java 8부터는 default 키워드를 
사용하여 인터페이스에도 메소드 구현체를 넣을 수 있게 변경되긴했다. 덕분에 구분이 더 애매해짐.)

이 예제의 Hero 클래스는 name 멤버 변수를 생성자로부터 받아서 자신의 멤버 변수로 추가하는 기능을 가지고 
있기 때문에 추상 클래스를 사용하는 것이 더 적절하다. 그럼 이제 추상 클래스를 사용하여 ultimate 메소드의 구현을 강제해보도록 하자.
```

# 프레임워크, 라이브러리, api
## 플랫폼
- 이 사용자들에 의해서 서드파티(플랫폼 개발을 담당하는 자/기관이 아닌 자/기관)에 의해 개발된 것이 사용/유통될 수 있는 환경/기술을 의미한 다고 생각합니다.
- 온라인으로 옮겨가면서 이 서드파티도 별도의 그룹이 아닌 플랫폼 내에서 활동하는 사용자들 중의 하나인 상태이며, 플랫폼은 사용자들 사이에서 공급과 수요를 이끌어내어 사용자들간의 비지니스가 가능한 형태를 말하는 것 같습니다.

## 프레임워크
- 특정 형태의 프로그램 설계에 대한 청사진으로써, 완성된 프로그램이나 기능을 목표로 하는 것 보다는 일관된 방법론이나 설계를 제공하여, 프레임워크 사용자(개발자)가 구현하고자 하는 목표를 달성할 수 있도록 하는 것이라고 생각합니다.
- 이를 위해서 대체로, 설계에 필요한 기능(클래스, 함수)과 다양한 개발방법론들을 제공합니다.
- 완성된 도구가 아니라는 점에서 라이브러리와 차별된다고 생각합니다.
- 현실에서 보면 요즘 많이 나오는 DIY 제품에 해당하지 않을까 싶네요.
- 자바의 스프링, 마이크로소프트의 닷넷 프레임워크

### 프레임워크 종류
- 기존의 언어를 기반으로 생성하지 않고 라이브러리를 이용하겠다.
	 - 스프링 프레임워크, 장고 프레임워크, 스칼라 프레임워크, 마이플랫폼 프레임워크, 애니 프레임워크
	 - 패턴을 만들어서 사용한다.

## 라이브러리
- 어떤 목표를 달성하거나 도와주기위한 기능의 집합(모음집)이라고 생각됩니다.
- 이는 프레임워크와 달리 완성된 형태이며, 라이브러리를 사용하는 사용자(개발자)에 의해서 라이브러리가 제공하는 기능들을 수정하거나 변경할 수 없습니다.(혹은 매우 어렵습니다.)
- 현실에서 보면 스패너, 스크류 드라이버와 같은 연장들에 해당하지 않을까요?
- 라이브러리와 API는 다른 말이긴 하지만, 보통 라이브러리를 획득하면 해당 라이브러리의 API가 따라옵니다. 그래야 라이브러리를 쉽게 사용할 수 있기 때문입니다. 하지만 API가 라이브러리를 의미하지는 않습니다.

## API
- API는 Application Program Interface의 약자로 말 그대로 인터페이스를 의미합니다. 앞의 라이브러리도 이러한 API를 제공합니다. 서로 다른 목적으로 개발된 프로그램/라이브러리들의 특정 기능을 호출하기 위해서, 혹은 외부의 다른 프로그램이 개발된(하고있는) 프로그램/라이브러리의 기능을 사용할 수 있게 하기 위해서는 기능을 호출해야 하는 사용자를 위한 배려가 필요한 데, 이것이 API라고 생각합니다.
- 일종의 약속인 것으로, 같은 개발 환경을 사용할 경우 쉽게 사용할 수 있게 됩니다.
- 기능을 (온라인)서비스하거나 라이브러리로 제공하기 위해서는 기능을 호출할 수 있는 명세(API)도 같이 제공해야 사용할 수 있겠습니다.


# 클래스 기반 (new)
- C++, 자바, C#, 파이썬, 루비

# 프로토타입 기반
- R, 자바 스크립트

# DB 언어
- SQL: 오라클, ms-sql, my-sql
- No-SQL: 몽고디비, 카산드라

# 스크립트 기반
- 파이썬, 루비, 자바스크립트, 몽고디비, 카산드라 : 인터프리터 식, 함수형 언어

# 전역 변수
## 프로토 타입: 원형
- {}, [], 문자열은 아님(‘’와 “” 둘다 존재)

## 자바: static


# 프로그래밍 언어의 단위
* 가. 문자열 
- 영어 단어인 의 사전적 의미는 줄 끈 일련 등과 같이 여러 가지가 있다 
- string , , . 프로그래밍 언어에서는 문자열이라는 의미가 되며 문자열은 문자 등을 차원적으로 나열한 것을 1 가리킨다. 
* 나. 문장 
- 영어 단어인 의 사전적 의미는 문장 등과 같이 여러 가지가 있다 sentence . 프로그래밍 언어에서는 문장이라는 의미가 된다.
- 문장은 마침표인 도트 기호 등으로 끝나는 문을 의미하며 프로그래밍 언어에서는 일반적으로 .( ) 세미콜론 으로 끝난다 ;( ) .
* 다. 어휘항목 
- 영어 단어인 의 사전적 의미는 어휘소이다 lexeme . 
- 프로그래밍 언어에서는 어휘항목이라는 의미가 된다. 
- 어휘소는 하나의 의미를 갖는 하나의 단어이거나 여러 개의 단어를 가리킨다. 어휘항목에 속한 요소에는 식별자 리터럴 연산자 특수어 등이 있으며 어휘항목의 종류를 , , , 통틀어 토큰이라 한다.

# 프로그래밍 언어 구성
* 객체 프로그래밍 언어에서는 선생이라는 단어를 오브젝트라고 하고 선택적인 자바와 파이썬이라는 단어를 인스턴스라고 한다. 오브젝트는 사용자가 수정하지 못하는 단어이고 인스턴스를 사용자가 수정할 수 있는 단어이다. 가르친다는 단어는 동적인 객체인 메소드 또는 함수라고 한다. 만약에 가르친다면이라는 문장은 프로그래밍 언어에서는 제어문이라고 한다 ~ . 조건문에 의해서 자바 선생이 될수도 있고 파이썬 선생이 될수도 있는 것이다. 프로그래밍 언어는 오브젝트 인스턴스 메서드 함수 제어문으로 구성되어 있다 
	* 정적: 1. 오브젝트(접근 불가) 2. 인스턴스(오브젝트의 접근화) 
	* 동적: 메소드
	* 접근이 가능하다 = 수정이 가능하다라는 의미.

# 언어의 역사
 * ASP -> PHP -> JAVA
 * JAVA -> Python(앱, 네트워크 프로그래밍 약점) -> Django
 * Python 2.(수학에 강함)  python3(머신러닝에 강함, 반올림: 오사오입)



## 변수명
* 변수명은 대문자와 소문자를 섞어서 알아보기 쉬운 형태로 작성하되 소문자로 시작한다.(ex. xCnt, yCnt, nameImg)
* 변수들 중 상수처럼 한 번 정한 후 변경할 필요가 없는 변수는 대문자를 사용할 수 있다.
(ex. Width, Height)
* 동사와 명사가 섞인 변수명을 작성할 때에는 동사를 먼저 적는다.
(ex. saveGame, loadGame)
* 되도록 변수명 앞에는 그 변수의 타입을 나타내는 접두어를 적는다.
(ex. imgBack, imgForward)
* Boolean형의 변수는 접두어로 is나 can을 붙인다.
(ex. isValid, canMove)
* 순환문 내부에서 사용하는 인덱스 변수는 i, j, k를 사용한다.
(ex. for(i=0; i<MAX; i++))
* 클래스 전체에 통용되는 클래스형의 변수는 접두어로 m이나 g를 붙인다.
(ex. mContext, mThread)
* 변수명에는 반드시 주석을 달아주어 변수에 대한 설명을 첨부한다.
(ex. int xCnt, yCnt; //이미지의 가로, 세로 조각 수)

## 자료형
* char: 1바이트  String: "asd": 1개당 2바이트; 총 6바이트,  int: 무조건 4바이트; 메모리 효율성 좋다.

# 절차적 언어
- 객체 언어와 달리 강제적 지정


## 컴파일 언어 compiler language
* 컴파일 될 때 오휴를 내는 것에 집중했다.  
    ^focus on making errors while compiling

## 인터프리터 언어 Interpreter Language
* 자바는 인터프리터 언어이지만 컴파일 해서 class 파일을 받은 후 Interpreter에 넣는 언어
* 파이썬은 컴파일 없이 바로 인터피르터에 값을 넣음


# MVC
- Model은 무엇을 할지 정의합니다. 비지니스 로직에서의 알고리즘, 데이터 등의 기능을 처합니다.
- Controller는 어떻게 할지를 정의합니다. 화면의 처리기능과 Model과 View를 연결시켜주는 연활을 하지요.
- View는 화면을 보여주는 역활을 하지요. 웹이라면 웹페이지, 모바일이라면 어플의 화면의 보여지는 부분입니다.


- Model은 어플리케이션이 “무엇”을 할 것인지를 정의 합니다. 내부 비지니스 로직을 처리하기 위한 역활을 할 것입니다.
- 처리되는 알고리즘, DB, 데이터 등등.
- Controller는 모델이 “어떻게” 처리할 지를 알려주는 역활을 할 것이고, 모바일에서는 화면의 로직처리 부분입니다.
- View는 화면에 무엇인가를 보여주기 위한 역활을 합니다. 컨트롤러 하위에 종속되어, 모델이나 컨트롤러가 보여주려고 하는 모든 필요한 것들을 보여줄 것입니다. 그리고 사용자의 입력을 받아서 모델의 데이터를 업데이트를 합니다.
- 그리고 Controller는 Model과 View가 각각 무엇을 해야 할 지를 알고 있고, 통제합니다. 비지니스 로직을 처리하는 Model과 완전히 UI에 의존적인 View가 서로 직접 이야기 할 수 없게 합니다.

## MVC 단점
- 뷰와 모델이 서로 의존성을 띄게 됩니다.
- 즉, 화면에 복잡한 화면과 데이터의 구성 필요한 구성이라면, Controller에 다수의 Model과 View가 복잡하게 연결되어 있는 상황이 생길 수 있습니다.
- MVC가 너무 복잡하고 비대해져서, 새 기능을 추가할때마다 크고 작은 문제점을 가지고 소드 분석이나 테스트도 어렵죠. 이런 형태의 MVC를 Massive ViewController (대규모 MVC 어플리케이션) 라고 부릅니다. MVC의 한계를 표현한 용어 인 것 같습니다.


# c++
* 다중 상속을 지원한다.

# xml
* SGML -> xml
* xml은 docx, 엑셀 등 거의 모든 문서에 반영됨 

# HTML
* Document에 문법 정의 되어 있음.
