# 구조체에 포인터변수
```java
참고로 구조체에 포인터변수가 있을경우 전송시 포인터변수 값을 복사해서 보내지지 않으므로 
(String 형태의 변수도 마찬가지) 하나의 구조체에 몰아서 전송하든가
아니면 따로 데이터를 복사해서 전송을 해야 할 것이다
```

```c
struct SEND_INFO{
    int Size_data; //4byte 
    char Name[50]; //50byte
};

struct SEND_INFO info

scanf("%s",p_name);
strcpy(info.Name,p_name);

info.Size_data = sizeof(int)+strlen(p_name)+1;

send(c_socket,(struct SEND_INFO*)&info,sizeof(int) +strlen(p_name),0) > 0 )
```


# 구조체 저장방식
```java
32비트 CPU를 기준으로 4byte씩 할당

4byte씩 끊어서 저장 자료형을 통일하지 않으면 중간중간 빈 공간이 생겨서 메모리 누수 발생

바이트패딩이란?

멤버 변수를 메모리에서 CPU로 읽을 때 한번에 읽을 수 있도록, 
컴파일러가 레지스터의 블록에 맞춰 바이트를 패딩해주는 최적화 작업

ex) struct x

{           char a;           int b;           char c;      }
; 의 경우 sizeof(x)를 하면 6이 나올 것 가지만 12가 나옴. 컴파일러는 구조체를 구성하는 멤버들을 
가장 크기가 큰 멤버 자료형의 배수가 되도록 정렬

#pragma pack(1) = 1바이트 단위로 저장하겠다. 

1바이트로 해서 메모리의 낭비가 없도록 하지 않고 왜 4바이트로 나누나?

->32비트 CPU에서 4바이트의 단위로 데이터를 처리하는 것이 가장 빠르기 때문

네트워크를 통해서 구조체 자체를 전송하려고 하면 패딩비트가 굉장히 중요한 변수가 된다. 
왜냐하면 구조체가 메모리에 정의되는 형태는 OS와 컴파일러에 따라 달라지기 때문이다. 동일한 구조체를 서로 다르게 메모리에 정의하고 있는 
시스템끼리 메모리에 있는 구조체 내용을 그대로 주고 받는다면 구조체의 각 멤버는 서로 다른 값을 가지게 된다.
```
