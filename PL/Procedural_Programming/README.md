# [절차지향 vs 객체지향](https://jamie95.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-VS-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5)
```java
프로그래밍
 소프트웨어를 구성하는 데이터와 데이터를 조작하는 코드를 작성하는 것,  
 데이터를 조작하는 코드를 별도로 분리하여 함수나 프로시저와 같은 형태로 만듦

절차 지향 - Procedural Oriented
절차 지향이란?
 절차 지향(Procedural Oriented) 프로그래밍 : 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성. 
 프로시저는 다른 프로시저를 사용할 수도 있고, 각각의 프로시저가 같은 데이터를 사용할 수 있음. 프로시저(procedure)로 프로그램을 구성하는 기법


 각 프로시저는 데이터를 사용해서 기능을 구현하며, 필요에 따라 다른 프로시저를 사용하기도 함. 또한 여러 프로시저가 동일한 데이터를 공유함


데이터를 중심으로 한 프로시저로 구성
예시 - 시험 성적 관리 프로그램
 성적 평균을 계산하고 출력하기 위한 프로그램

- 평균 계산 프로시저 : 각 과목의 점수가 보관된 데이터를 읽어서 합을 구한 후, 평균 값을 계산. 계산된 평균값은 다른 데이터로 생성

- 화면 출력 프로시저 : 평균 계산 프로시저가 생성한 평균 값 데이터와 과목 점수 데이터를 이용하여 성적을 출력

장점
 예제의 '평균 계산 프로시저'와 '화면 출력 프로시저'는 데이터를 공유하여 사용, 다수의 프로시저들이 데이터를 
 공유하는 방식으로 만들어지기 때문에,, 절차 지향 프로그램은 자연스럽게 데이터를 중심으로 구현하게 됨


 데이터와 그 데이터를 사용하는 프로시저를 작성하는 것은 자연스러운 과정이므로, 최초에 절차 지향적으로 코드를 구현하는 것이 쉬움

단점
 프로그램 규모가 커져 데이터의 종류가 증가하고, 사용하는 프로시저가 증가하게 된다면 문제들이 발생할 수 있음(생각보다 흔하게 발생). 
 이로 인해 새로운 요구사항이 생겨서 프로그램의 한 곳을 수정하면 다른 곳에서 문제가 발생하고, 
 다시 그 곳을 수정하면 또 다른 곳에서 문제가 발생하는 악순환이 발생하기도 함. 이는 결국 코드의 수정을 어렵게 만들고,
 새로운 기능을 추가하는데 많은 구현 시간(즉, 개발 비용)을 투입하게 만듦

 

1. 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 프로시저가 증가

 한 데이터를 사용하는 프로시저가 많아질수록 그 데이터의 타입을 변경하기 어려워짐

 - 예시) On Off 관리 - boolean 타입의 isOn 데이터

  > 이 데이터를 사용하는 프로시저는 모두 isOn을 boolean으로 저장함

  > 요구사항이 변경되어 On Off에 Wait를 추가해야 함 => boolean에서 열거타입으로 변경

  > 해당 데이터를 사용하는 모든 프로시저의 저장 타입을 boolean에서 열거타입으로 변경해야 함

 

2. (더 안좋은 경우) 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생

 프로그램 규모가 커질수록 같은 데이터를 서로 다른 의미로 사용하는 경우가 발생할 가능성이 높음

 - 예시) 서비스 만료일 데이터

  > 만료 확인 프로시저 : 서비스 만료일 데이터가 null인 경우 이를 오류로 처리하도록 생성

  > 회원 정보 프로시저 : 서비스를 무한정 사용한다는 의미로 서비스 만료일을 설정

  > 만료 확인 프로시저 - null이 들어가면 오류를 발생

객체 지향
 절차 지향과 달리 데이터 및 데이터와 관련된 프로시저를 객체(object)라고 불리는 단위로 묶음, 객체 지향 기법으로 작성된 프로그램은 객체들로 구성

 객체 : 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성, 자신만의 기능을 제공하며, 
 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있게 됨. 다른 객체에 기능을 제공하기 위해 프로시저(자바 : 메서드)를 사용

 객체의 프로시저 : 자신이 속한 객체의 데이터에만 접근 가능하며 다른 객체에 속한 데이터에는 접근할 수 없음


데이터와 프로시저를 함께 갖는 객체들의 네트워크로 구성
단점
 데이터를 공유하는 절차지향과 달리 객체별로 데이터와 프로시저를 알맞게 정의해야하고, 프로그램의 규모가 작을 떄에는 절차 지향 방식보다 복잡한 구조를 갖게 됨

 즉, 설계시 더 많은 노력이 들어갈 수 있음

장점
 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는 영향을 주지 않기 때문에, 요구 사항의 변화가 
 발생했을 때 절자 지향 방식보다 프로그램을 더 쉽게 변경할 수 있음

 프로그램을 상대적으로 쉽게 수정할 수 있는 유연함을 제공하기 때문에, 변화된 요구 사항을 빠르게 반영할 수 있음
```

# 절차지향
*  이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리합니다. 옛날에는 하드웨어와 소프트웨어의 개발 속도차이가 크지 않았습니다. 하지만 소프트웨어 언어의 발달과 컴파일러의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못하는 상황이 발생했습니다. 이는 객체지향 언어가 등장하게 되는 계기로 작용했습니다. 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고, 모듈을 재활용하기 때문에 하드웨어의 처리양을 획기적으로 줄여주었습니다.
* 객체지향 언어는 어떤 모듈에 있는 하나의 기능만 필요하더라도 모듈 전체를 가져와야 하기 때문에 절차지향 프로그래밍보다 프로그램 사이즈가 더 커질 수도 있습니다. 또한 데이터에 대한 접근도 상대적으로 절차지향식보다 느려질 가능성이 많습니다. 메소드를 통해서만 접근이 가능하기 때문에 절차지향식처럼 특정 함수에 접근할 수 없고, 식으로만 접근이 가능해 속도적인 측면에서 불이익이 있습니다.
1. 루틴 서브루틴, 함수(프로시져) 등을 이용한 프로그래밍
2. 절차적으로 실행되는 것(X) -> 프로시져 콜, 즉 함수 호출을 통해서 재사용성을 얻어내는 것이 본질!
3. 장점 : 함수를 통한 코드의 재활용성 , 모듈화와 구조화에 용이함
4. 단점 : 프로시저 호출에 자원 낭비(최근 컴파일러, 하드웨어 성능향상으로 거의 상관없음)
* 자동차를 만들기 위해서는 엔진, 핸들, 바퀴, 의자, 엑셀, 브레이크 등등… 많은 부품들이 있어야 합니다. 기존 방식 절차지향적 관점으로 본다면 자동차를 만들기 위해서는 어느 한 곳을 기점으로 순서대로 만들어가야 합니다. 엔진 -> 차체 -> 핸들 -> 의자 -> 바퀴 이런 식으로 만들어가며 이들은 서로 분리되면 안되고 순서가 틀려서도 안되며 하나가 고장 나면 전체 기능이 마비되도록 설계되었다고 가정해봅시다. 또한 이들은 처음에 조립될 때의 부품을 다른 종류의 것으로 대체할수도 없다는 전제도 있다고 한다면! 얼마나 비효율적이고 비생산적일까요? 허나 여기에 객체지향 개념의 방식이 도입되면 상황은 달라집니다. 그러면 일단 제작에 있어서 이들은 순서적이지 않아도 됩니다. 핸들을 먼저 만들든, 바퀴를 먼저 만들든, 엔진을 먼저 만들든 상관이 없어집니다. 이들은 각각 따로 독립적으로 개발되어 나중에 한곳에 모여 자신의 기능만 제대로 발휘하면 되니까요. 실제 자동차를 만드는 과정과 똑같은 원리입니다. 부품들이 결합되어 움직이다 어느 하나가 고장이 나더라도 전체 부품들에 영향을 미치지는 않습니다. 고장난 부품만 고쳐주면 될 뿐, 다른 부품들은 아무 영향을 받지 않습니다. 그리고 필요하면 어느 때든 마음에 안드는 부품을 다른 것으로 교체할 수 있고 더 좋은 것으로 바꿀수도 있습니다.

# 객체지향
* 절차지향 프로그래밍이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 대표적인 절차지향 언어에는 C언어가 있습니다. 이는 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리합니다. 그러나 기술이 발전하고 소프트웨어와 하드웨어가 발전함에 따라 상황은 달라졌는데요. 옛날에는 하드웨어와 소프트웨어의 개발 속도차이가 크지 않았습니다. 하지만 소프트웨어 언어의 발달과 컴파일러의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못하는 상황이 발생했습니다. 이는 객체지향 언어가 등장하게 되는 계기로 작용했습니다. 객체지향 프로그래밍은 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고, 모듈을 재활용하기 때문에 하드웨어의 처리량을 획기적으로 줄여주었습니다.
1. 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용ㅇ으로 서술하는 방식
2. 캡슐화, 상속, 다형성, 추상화 의 특징을 가짐
3. 장단점 : 상속(편리하지만 구조가 이상하게 변할 수있음), 인스턴스에 데이터 접근 불가, 새로운 데이터 형식을 정의할 수 있게 해줌
