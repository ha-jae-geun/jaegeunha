# 메모리 영역
## 텍스트 세그먼트(코드 세그먼트)
* 함수, 제어문, 상수
- 이 영역은 작성한 코드가 기계어로 바뀌어 저장 됩니다. EIP는 이 코드의 흐름을 읽는 EIP레지스터입니다. 이 곳에는 변수가 아닌 순수 코드만 있는 영역입니다.(함수, 제어문 등등..)
- 코드영역에는 실제 프로그램 동작을 수행하는 명령어(Instruction)와 전역 상수가 저장됩니다. 
- 명령어는 CPU에서 순차적으로 실행되는 함수와 연산 구문 등이 해당되고, 전역 상수는 “ “ 로 선언된 문자열 상수나 const 접두어가 붙은 변수 등이 해당됩니다.
- 메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부른다.
- 실행할 프로그램의 코드는 프로그래머가 작성한 소스 코드이다. 또한 상수도 여기에 들어간다.
- 물론 컴파일 된 기계어가 들어간다.
- CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.
- 프로그램의 시작하고 끝날 때까지 메모리에 계속 남아있는다.

# 데이터 영역
- 메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(Static) 변수가 저장되는 영역이다.
- 프로그램의 시작하고 끝날 때까지 메모리에 계속 남아있는다.

# 스택(Stack) 영역
* 힙 영영의 Object를 가리키는 참조 변수는 Stack에 할당된다.
- 메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
- 스택 영역은 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다.
- 이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(Stack frame)이라고 한다.
- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 프로그램이 자동으로 사용하는 임시 메모리 영역이다.
- Stack 영역이 크면 클 수록 Heap 영역이 작아지고 Heap 영역이 크면 클 수록 Stack 영역이 작아진다.
- 컴파일 시에 크기가 결정된다.

## 스택 장점
- 낭비되는 공간이 없다.
- 하나의 명령만으로 메모리 조작과 어드레스 조작이 가능하다.

## 스택 단점
- 한계가 있어 한계를 초과하도록 삽입할 수 없다.
- 유연성이 부족하다.

# 힙(Heap) 영역
- 메모리의 힙(Heap) 영역은 사용자가 직접 관리할 수 있고 해야만하는 영역이다.
- 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.
- malloc() 또는 new 연산자를 통해 할당하고 free() 또는 delete 연산자를 통해서 해제가 가능하다.
- Java에서는 가비지 컬렉터가 자동으로 해제하는 곳이다.
- Stack 영역이 크면 클 수록 Heap 영역이 작아지고, Heap 영역이 크면 클 수록 Stack 영역이 작아진다.
- 런타임 시에 크기가 결정된다.


## 힙 장점
- 프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우 사용 가능하다.
- 개체가 너무 커서 스택 할당자에 맞지 않는 경우 사용 가능하다.

## 힙 단점
- 할당 작업으로 인한 속도 저하 
	- 단지 할당하는 데 시간이 많이 소요될 수 있다.
- 해제 작업으로 인한 속도 저하 
	- 주로 병합을 사용할 때 해제 작업에 더 많은 주기가 소요된다.
	- 병합하는 동안 각 해제 작업에서는 해당 인접 항목을 “찾아내어” 더 큰 블록을 만들고 그 블록을 해제 목록에 다시 삽입한다.
	- 그러한 찾기가 수행되는 동안에는 메모리가 임의의 순서로 액세스되어 캐시 누락이 발생하고 성능이 저하될 수 있다.
- 힙 손상으로 인한 속도 저하 
	- 응용 프로그램에서 힙 블록을 적절하게 사용하지 않을 경우 힙이 손상된다.
	- 가장 많이 발생할 수 있는 힙 손상 문제로는 이중 해제, 해제 후 블록 사용, 블록 경계를 벗어나 덮어쓰기 등이 있다.
- 힙 경합으로 인한 속도 저하

	- 두 개 이상의 쓰레드에서 동시에 데이터에 액세스하려고 하면 경합이 발생하여 한 쪽 쓰레드의 작업이 완료되어야 다른 쪽 쓰레드의 작업이 진행될 수 있다.
	- 경합으로 인해 항상 문제가 발생하며, 이 문제는 현재 다중 프로세서 시스템에서 일어나는 문제 중 가장 큰 문제다.

	-  메모리 블록을 아주 많이 사용하는 응용 프로그램이나 DLL이 여러 개의 쓰레드로 실행되거나 다중 프로세서 시스템에서 실행되면 속도가 느려진다.

	-  이 문제를 해결하려면 일반적으로 단일 잠금 방법을 사용하여 해당 힙을 사용하는 모든 작업을 Serialize한다.
  	- 이러한 Serialization으로 인해 쓰레드에서는 잠금을 기다리는 동안 컨텍스트를 전환 할 수 있다.
	- 경합은 일반적으로 쓰레드와 프로세스의 컨텍스트 전환을 가져온다.
	- 컨텍스트 전환에도 리소스가 많이 소모되지만,
	- 프로세서 캐시에서 데이터가 손실되어 나중에 해당 쓰레드가 다시 살아날 때 이 데이터를 다시 작성하는 데에 리소스가 훨씬 많이 소모된다.

## 그럼 Heap 영역, 동적 할당은 왜 필요한 것일까?
- 메모리를 효율적으로 관리할 수 있기 때문이다.
- 임베디드 시스템을 개발하다보면 하드웨어 크기가 매우 작은 경우가 많다.
- 하드웨어 크기가 작다는 것은 메모리의 용량도 작음을 의미한다.
- 메모리 용량이 클 수도 있지만 가격이 매우 비싸질 것이다.
- 그러한 작은 메모리 공간에 프로그래머가 메모리 관리의 달인이라면 컴파일러가 자동으로 할당해주는 것보다 더 효율적인 관리가 가능하다.

## 스택 힙 차이
- 스택이 훨씬 더 빠르다. 스택은 이미 할당 되어 있는 공간을 사용하는 것이고 힙은 따로 할당해서 사용하는 공간이다. 다만 스택은 공간이 매우 적기 때문에 모든 응용에서 스택을 사용할 수는 없다. 좀 더 자세히 알아보자.
- 스택에서 할당의 의미는 단순히 스택 내에서 가리키고 있는 포인터의 위치를 바꾼다라는 매우 단순한 CPU Instruction(단순히 덧셈과 뺄셈 연산, 일반적으로 단일 Instruction)이다.
- 반면 힙에서의 할당은 요청된 chunk의 크기, 현재 메모리의 fragmentation 상황 등 다양한 요소를 고려하기 때문에 더 많은 CPU Instruction이 필요하다.


# [콜스택](https://boycoding.tistory.com/235)
```java
- The call stack in action
콜 스택이 어떻게 작동하는지 좀 더 자세히 살펴보자. 함수를 호출할 때 발생하는 단계는 다음과 같다.

1. 프로그램에 함수 호출이 발생한다.
2. 스택 프레임이 생성되고 콜 스택에 푸시된다. 스택 프레임은 다음과 같이 구성된다:
	함수가 종료되면 복귀할 주소
	함수의 모든 매개 변수
	지역 변수
	함수가 반환할 때 복원해야 하는 수정된 레지스터의 복사본
3. CPU가 함수의 시작점으로 점프한다.
4. 함수 내부의 명령어를 실행한다.
5. 함수가 종료되면 다음 단계가 수행된다:
6. 레지스터가 콜 스택에서 복원된다.
7. 스택 프레임이 콜 스택에서 튀어나온다. 이렇게 하면 모든 지역 변수와 매개 변수에 대한 메모리가 해제된다.
8. 반환 값이 처리된다.
9. CPU는 반환 주소에서 실행을 재개한다.
반환 값은 시스템 아키텍처에 따라 여러 가지 방법으로 처리한다. 반환 값이 스택 프레임의 일부로 포함되기도 하며, CPU 레지스터를 사용하기도 한다.

일반적으로 콜 스택이 어떻게 동작하는지에 대한 모든 세부 사항이 중요하지는 않다. 그러나 함수가 호출될 때와 종료될 때 함수가 
콜 스택에서 효과적으로 작동한다는 것을 이해하면 재귀를 이해할 때와 디버깅할 때 유용하다.



출처: https://boycoding.tistory.com/235 [소년코딩]
```

## PC 레지스터
```java
스택을 쓰레드마다 독립적으로 할당하는 이유

쓰레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.
스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을
저장하기 위해 사용되는 메모리 공간이므로
스택 메모리 공간이 독립적이라는 것은
독립적인 함수 호출이 가능하다는 것이고
이는 독립적인 실행 흐름이 가능하게 한다.


PC Resister를 쓰레드마다 독립적으로 할당하는 이유

PC 값은 쓰레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.
쓰레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다.
그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.
```

## OVerflow
- Stack의 지역변수는 사용하고 소멸하므로 데이터 용량의 불확실성을 가지므로 밑에서부터 채워 올리고 Heap은 위에서 부터 채워 내려진다.
- Stack 영역에서의 주소값은 시작 주소는 밑에서부터(먼저선언된 순서) 그 다음 주소는 순서대로 정해진다.

# 메모리 영역 정리
1. code(text), data, stack 영역은 컴파일러가 알아서 메모리영역을 결정한다. 즉 컴파일 할 때 data영역과 stack영역의 크기를 계산해서 필요한 메모리 공간을 가지고 된다.  heap 영역은 개발자에 의해 프로그램 동작시 결정된다.
-  DATA 에는 초기화 된 전역변수, 배열, static BSS (Block Stated Symbol) 에는 초기화 값이 없는 전역변수, 배열, static 저장
ex) C언어에서 배열 선언시 incomplete type으로 사용하면 컴파일 할 때 에러가 발생하게 된다.   
2. code, data, heap 영역은 하위 메모리부터 할당되고, stack 영역은 상위 메모리부터 할당 된다.
3. SMA (Static Memory Allocation) : 정적 메모리, 메모리의 data 영역, stack 영역을 사용한다.
	 - Data 영역 : 프로그램 시작과 동시에 할당된 영역이 잡히고 끝나면 OS 에 반환한다.
     - Stack 영역 : 함수 시작과 동시에 할당된 영역이 잡히고 끝나면 OS에 반환한다.
   
4. DMA (Dynamic Memory Allocation) : 동적 메모리, 메모리의 heap 영역을 사용한다.
     - Heap 영역 : stack에서 pointer 변수를 할당하고, 그 pointer가 가리키는 heap 영역의 임의의 공간부터 원하는
- →stack의 지역변수는 사용하고 소멸하므로 데이터 용량의 불확실성을 가지므로 밑에서부터 채워 올리고 heap은 위에서 부터 채워 내려진다. 용량의 불확실성은 컴파일러가 알아서 메모리영역을 선택(랜덤적) 
- stack영역에서의 주소값은 시작주소는 밑에서부터(먼저선언된 순서) 그다음 주소는 순서대로 정해진다.
- HEAP overflow-heap이 위에서부터 주소값을 채워져 내려오다가 stack영역을 침범하는 경우.
- STACK overflow-stack영역이 heap을 침범.



## 프로토타입  원형 저장
- {}, [], 문자열은 아님(‘’와 “” 둘다 존재)
- 스택 구조에 저장됨

## Context switching
- 지금까지 언급한 메모리 저장 구조는 프로세스와 쓰레드의 컨텍스트 스위칭과 연결지어 생각해볼 수 있다. 이미지에서처럼, 프로세스는 각 프로세스 별로 독립적인 [ Code, Data, Heap, Stack ]  영역을 소유하게 된다. 따라서 프로세스 전환 시, 메모리의 전 영역에 대해 컨텍스트 스위칭 비용이 발생하게 된다.
- 이에 비해 쓰레드는 [ Code, Data, Heap ] 영역은  서로 공유하고, Stack 영역만 별도로 소유한다. 이런 차이로 스위칭 비용이 프로세스에 비해 훨씬 적게 드는 것이다.

# 클래스 기반 (new)
- C++, 자바, C#, 파이썬, 루비
- 상속 기능 담보
- 메소드 1. 완전 상속(오버라이드) 2. 부분상속(오버로딩)
