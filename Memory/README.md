# 메모리 영역
## 텍스트 세그먼트(코드 세그먼트)
- 이 영역은 작성한 코드가 기계어로 바뀌어 저장 됩니다. EIP는 이 코드의 흐름을 읽는 EIP레지스터입니다. 이 곳에는 변수가 아닌 순수 코드만 있는 영역입니다.(함수, 제어문 등등..)
- 코드영역에는 실제 프로그램 동작을 수행하는 명령어(Instruction)와 전역 상수가 저장됩니다. 
- 명령어는 CPU에서 순차적으로 실행되는 함수와 연산 구문 등이 해당되고, 전역 상수는 “ “ 로 선언된 문자열 상수나 const 접두어가 붙은 변수 등이 해당됩니다.
 
## 전체
1. code(text), data, stack 영역은 컴파일러가 알아서 메모리영역을 결정한다. 즉 컴파일 할 때 data영역과 stack영역의 크기를 계산해서 필요한 메모리 공간을 가지고 된다.  heap 영역은 개발자에 의해 프로그램 동작시 결정된다.
-  DATA 에는 초기화 된 전역변수, 배열, static BSS (Block Stated Symbol) 에는 초기화 값이 없는 전역변수, 배열, static 저장
ex) C언어에서 배열 선언시 incomplete type으로 사용하면 컴파일 할 때 에러가 발생하게 된다.   
2. code, data, heap 영역은 하위 메모리부터 할당되고, stack 영역은 상위 메모리부터 할당 된다.
3. SMA (Static Memory Allocation) : 정적 메모리, 메모리의 data 영역, stack 영역을 사용한다.
	 - Data 영역 : 프로그램 시작과 동시에 할당된 영역이 잡히고 끝나면 OS 에 반환한다.
     - Stack 영역 : 함수 시작과 동시에 할당된 영역이 잡히고 끝나면 OS에 반환한다.
   
4. DMA (Dynamic Memory Allocation) : 동적 메모리, 메모리의 heap 영역을 사용한다.
     - Heap 영역 : stack에서 pointer 변수를 할당하고, 그 pointer가 가리키는 heap 영역의 임의의 공간부터 원하는
- →stack의 지역변수는 사용하고 소멸하므로 데이터 용량의 불확실성을 가지므로 밑에서부터 채워 올리고 heap은 위에서 부터 채워 내려진다. 용량의 불확실성은 컴파일러가 알아서 메모리영역을 선택(랜덤적) 
- stack영역에서의 주소값은 시작주소는 밑에서부터(먼저선언된 순서) 그다음 주소는 순서대로 정해진다.
- HEAP overflow-heap이 위에서부터 주소값을 채워져 내려오다가 stack영역을 침범하는 경우.
- STACK overflow-stack영역이 heap을 침범.



## 프로토타입  원형 저장
- {}, [], 문자열은 아님(‘’와 “” 둘다 존재)
- 스택 구조에 저장됨

## Context switching
- 지금까지 언급한 메모리 저장 구조는 프로세스와 쓰레드의 컨텍스트 스위칭과 연결지어 생각해볼 수 있다. 이미지에서처럼, 프로세스는 각 프로세스 별로 독립적인 [ Code, Data, Heap, Stack ]  영역을 소유하게 된다. 따라서 프로세스 전환 시, 메모리의 전 영역에 대해 컨텍스트 스위칭 비용이 발생하게 된다.
- 이에 비해 쓰레드는 [ Code, Data, Heap ] 영역은  서로 공유하고, Stack 영역만 별도로 소유한다. 이런 차이로 스위칭 비용이 프로세스에 비해 훨씬 적게 드는 것이다.

# 클래스 기반 (new)
- C++, 자바, C#, 파이썬, 루비
- 상속 기능 담보
- 메소드 1. 완전 상속(오버라이드) 2. 부분상속(오버로딩)
