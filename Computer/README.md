# 컴퓨터의 발전
```java
문 5. 10 진수 -11 을 5 비트 2 진수로 표현한 것은? (단,
부호 있는(signed) 2 진수는 2 의 보수로 표현된다)
1 10101
2 11101
3 01101
4 10100

답 1
11을 다섯 자리 2진수를 바꾸면 01011 이 된다.
각 비트를 반전시키면 1의 보수 음수값이 되므로,
1의 보수 -11은 '10100' 이 된다.
1의 보수 음수값에 1을 더하면 2의 보수 음수값이 되므로,
2의 보수 -11은 '10101' 이 된다.


문 14. 2의 보수로 표현된 n비트의 부호 있는(signed) 2
진 정수가 표현할 수 있는 최댓값과 최솟값의 합은?
1 -1
2 0
3 1
4 2
n-1

답 1
n비트의 2의 보수로 표현 가능한 수의 범위는
- (2^(n-1)) ~ 2^(n-1)- 1
최댓값 - 2
n-1
최솟값 2n-1 - 1
따라서 최댓값과 최솟값의 합은 -1이다.


문 5. 정보량의 크기가 작은 것에서 큰 순서대로 바르게
나열한 것은?(단, PB, TB, ZB, EB 는 각각 petabyte,
terabyte, zettabyte, exabyte 이다)
1 1 PB, 1 TB, 1 ZB, 1 EB
2 1 PB, 1 TB, 1 EB, 1 ZB
3 1 TB, 1 PB, 1 ZB, 1 EB
4 1 TB, 1 PB, 1 EB, 1 ZB

답 4
◈ 데이터 용량
10^24 요타 (yotta) 1YB
10^21 제타 (zetta) 1ZB
10^18 엑사 (exa) 1EB
10^15 페타 (peta) 1PB
10^12 테라 (tera) 1TB
10^9 기가 (giga) 1GB
10^6 메가 (mega) 1MB
10^3 킬로 (kilo) 1KB
1바이트 1Byte
◈ 실행시간
1초 1second
10^-3 밀리 (milli) 1ms
10^-6 마이크로 (micro) 1μs
10^-9 나노 (nano) 1ns
10^-12 피코 (pico) 1ps
10^-15 펨토 (femto) 1fs
10^-18 아토 (atto) 1as
10^-21 젭토 (zepto) 1zs
10^-24 욕토 (yocto) 1ys


4-비트 2의 보수(2’s complement)로 표현된 2진수
1110과 1010의 덧셈 결과를 10진수로 올바르게 표현한
것은?
1 -8 2 -4
3 0 4 8

답 1
2의 보수의 계산은 덧셈을 한 뒤 오버플로우를 확인한 뒤 최상위
비트 캐리값을 버리기만 하면 된다.
1 1 0
1 1 1 0
+ 1 0 1 0
1 1 0 0 0
오버플로우는 최상위 비트의 자리올림수(파란색)와 캐리값(빨간색)
을 비교해서 다르면 오버플로우로 판단한다.(XOR 회로 이용)
1110 + 1010 = 11000 에서
오버플로우가 발생하지 않으므로, 캐리값 1을 버린
1000이 계산 결과가 된다.
2의 보수 1000은 1의 보수 0111에 해당하며,
1의 보수 0111은 1000(8)의 반전이므로 -8이다.
검증)
2의 보수 1110 = 1의 보수 1101 = -2
( 1의 보수 1101은 0010(2)의 반전이므로 -2 )
2의 보수 1010 = 1의 보수 1001 = -6
( 1의 보수 1001은 0110(6)의 반전이므로 -6 )
-2 + ( -6 ) = -8



문 2. 비트열(bit string) A 를 2 의 보수로 표현된 부호
있는(signed) 2 진 정수로 해석한 값은 -5 이다. 비트열
A 를 1 의 보수로 표현된 부호 있는 2 진 정수로 해석
한 값은?
1 -4
2 -5
3 -6
4 -7

답 1
양수 5 = 이진수 0101 (4비트라고 가정)
1의 보수 -5 : 1010
2의 보수 -5 : 1011
즉 비트열 A는 1011이다.
A를 1의 보수로 해석하면,
1011은 0100(4)의 반전값이므로
1의 보수 1011은 -4이다.


문 12. 0 ~ (6410-1)에 해당하는 정수를 이진코드로 표현하기 위해 필요한 최소 비트 수는? 2
1 16비트 2 60비트
3 63비트 4 64비트

[해설]
- 0 ~ (6410-1)에서 6410 = (26)
10 = 2
60 이므로 표현하기 위해 필요한 최소 비트 수는 60비트이다.


문 7. 아날로그 컴퓨터에 대한 설명으로 옳지 않은 것은? 1
1 입력형식은 부호, 코드화된 숫자, 문자, 기호이다.
2 출력형식은 곡선, 그래프 등이다.
3 미적분 연산방식을 가지며, 정보처리속도가 빠르다.
4 증폭회로 등으로 회로 구성을 한다.


[해설] - 디지털 컴퓨터와 아날로그 컴퓨터의 비교
항목 디지털 컴퓨터 아날로그 컴퓨터
입력 형태 숫자, 문자 전류, 전압, 온도
출력 형태 숫자, 문자 곡선, 그래프
연산 형식 산술.논리 연산 미.적분 연산
구성 회로 논리회로 증폭 회로
프로그래밍 필요 불필요
정밀도 필요한 한도까지 제한적임
기억 기능 있음 없음
적용분야 범용 특수 목적용

컴퓨터의 발전 과정에 대한 설명으로 옳지 않은 것은? 1번
① 포트란, 코볼같은 고급 언어는 집적회로(IC)가 적용된 제3세대 컴퓨터부터 사용되었다.
② 애플사는 1970년대에 개인용 컴퓨터를 출시하였다.
③ IBM PC라고 불리는 컴퓨터는 1980년대에 출시되었다.
④ 1990년대에는 월드와이드웹 기술이 적용되면서 인터넷에 연결되는 컴퓨터의 사용자가 폭발적으로 증가하였다.

∙ 1세대 : 저급 언어(기계어, 어셈블리어)
∙ 2세대 : 고급 언어(FORTRAN, COBOL) 등장


컴퓨터 구조에 대한 설명으로 옳지 않은 것은? 3번
① 폰노이만이 제안한 프로그램 내장방식은 프로그램 코드와 데이터를 내부기억장치에 저장하는 방식이다.
② 병렬처리방식 중 하나인 SIMD는 하나의 명령어를 처리하기 위해 다수의 처리장치가 동시에 동작하는 다중처리기 방식이다.
③ CISC 구조는 RISC 구조에 비해 명령어의 종류가 적고 고정 명령어 형식을 취한다.
④ 파이프라인 기법은 하나의 작업을 다수의 단계로 분할하여 시간적으로 중첩되게 실행함으로써 처리율을 높인다.
```

# '컴퓨터'의 구조는 어떻게 되어있을까? CPU와 메모리! [안될과학 - 랩미팅 15화]
* [영상]('https://www.youtube.com/watch?v=SiC74U8aJbM&list=PLPBTs1IJBEyiIu3L_kAOoaEadO0TY_DJ0&index=4&t=0s')
* 전기 스위치를 통해 계산할 수 있는 형태: CPU의 기본적인 형태
```java
- computer: 수학을 계산하는 직업
- 1946년 애니악; 30톤의 컴퓨터(프로그래밍이 가능한 최초의 컴퓨터)
 애니악의 문제: 연산 처리를 위한 소프트웨어가 없어 전선으로 물리적 연산
- 폰 노이만
 소프트웨어(코딩): 컴퓨터 구성의 체계를 잡아줌
- 논리 구조를 전기적 스위칭으로 표현, 계산(컴퓨터는 0과 1만 표현 가능)
 우리가 아는 논리 회로(AND, OR, NOT, XOR, NAND, NOR, XNOR)
  CPU는 이런 논리회로들로 가득 차 있음
- 진공관보다 훨씬 작은 트랜지스터가 만들어지는 시기
- Jack Kilby(1958)
 텍사스 인스투르먼트에서 근무
 반도체 공정으로 작은 부품들을(전선, 저항, 다이오드, 커패시터)를 한 번에 만들자
 집적회로; Integrated Circuit(IC): 회로를 한곳에 몰아 넣었다(머리카락보다 얇은 전선)
- 최초의 cpu: INTEL 4004(1971년)
- 컴퓨터의 기본 구조: INPUT -> CPU(Control Unit(정보 처리), Logic Unit(계산이나 연산)) -> Output
 기억을 할 수 없는 메모리가 없었음
- RAM: 하나의 비트를 기억하기 위해 회로를 제작
  블랙 라이트를 키면 보이고 끄면 안 보이는 글씨 -> 회로를 구성해서 스스로 블랙 라이트를 킬 수 있게 만듬
  회로가 64개 = 64개의 숫자를 기억
   사진 한개 1KB: 8000개의 숫자
- DRAM: 훨씬 작은 부품으로 숫자 하나를 기억할 수 있게 만들어 진 것
 더 많은 기억이 가능, 하지만 속도가 느림
- 현재의 컴퓨터
 * 초기의 작고 빠른 RAM은 CPU안에 내장(캐시 메모리라고 불림)
 * DRAM은 우리가 흔히 말하는 램
- HDD/SSD의 등장
 * 전원이 꺼지면 모두 소멸되는 램의 위험성 때문에 HDD 등장
 * 램은 켜져있는 창들만 기억
- # 클락: CPU의 역할은 기억을 꺼냄 > 계산 > 기억을 넣음
 * 코어를 늘릴 수록 전기 소모와 발열의 증가, 발열 때문에 쿨링 하는데 전기 소모
 * 병렬 작업 떄문에 검산의 작업이 필요해지면서 속도 향상의 한계
```

