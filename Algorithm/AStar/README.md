# [AStar](https://itmining.tistory.com/66)
# [AStar2](http://www.gisdeveloper.co.kr/?p=3897)
```java
길찾기 알고리즘이라고 하면 보통 가장 먼저 떠오르는 알고리즘은 기초적으로 배우는 다익스트라 
알고리즘(Dijkstra algorithm)이라고 생각합니다. 최단거리를 찾아주는 대표적인 알고리즘이지만, 
실제 프로그램에 적용하기에 문제가 되는 부분이 있습니다. 다익스트라 알고리즘은 경로를 찾을 때 
각 노드에서 목적지 까지의 모든 경로에 대한 실제 비용을 계산하여 비교하기 때문에 알고리즘 수행 시간이 많이 든다는 것입니다.1

이러한 문제를 해결하기 위해서 다음 노드로의 분기를 모든 노드가 아닌 가장 적은 추정 비용을 갖는 
노드로 이동할 수 있게 휴리스틱 함수(Heuristic Function)2를 적용한다면 각 노드에서 분기를 줄일 수 있습니다. 
이를 대표하는 탐색 알고리즘인 A*A Star에 대해 알아보겠습니다.
```

## 다익스트라 단점
```java
지금까지 가장 최소의 비용으로 도달한 지점부터 탐색하는 다익스트라 알고리즘의 원리를 차용한 것으로, A* 알고리즘은 현재 상태의 비용을 g(x)g(x), 
현재 상태에서 다음 상태로 이동할 때의 휴리스틱 함수를 h(x)h(x)라고 할 때, 둘을 더한 f(x) = g(x) + h(x)f(x)=g(x)+h(x)가 최소가 되는 지점을 우선적으로 
탐색하는 방법이다. 이 f(x)f(x)가 작은 값부터 탐색하는 특성상 우선순위 큐가 사용된다. 휴리스틱 함수 h(x)h(x)에 따라 성능이 극명하게 갈리며,
f(x) = g(x)f(x)=g(x)일 때는 다익스트라 알고리즘과 동일하다.

다만 사용된 휴리스틱에 따라서 최단거리를 도출할 수 없기도 하기 때문에 개량하여 사용하는 경우가 많다. 따라서 IDA*, Jump Point Search 등 A*의 파생형 또한 많은 편이다.

A*를 사용하는 이유는 다익스트라의 현실 적용이 매우 어렵기 때문이다. 당장에 네트워크 같은 디지털적인 공간이 아닌, 현실의, 사람이 사는 공간을 생각해보자. 
사람이 다닐 수 있는 "거리"는 명백히 아날로그하다. 이것들을 전부 노드화시키기에는 그 수가 엄청나게 많아질 수 있다. 그렇다면 탐색해야 하는 공간도 
그만큼 커지게 되고, 시간 복잡도 역시 아득히 커질 것이다. 또한 어찌어찌 잘 노드화시켜서 다익스트라를 사용할 수 있는 상황을 만들어서 경로를 
발견했다고 치자. 그렇게 탐색한 경로가 자동차 정체 구간, 출근길 등 다양한 변수로 인해 오히려 더 느려질 수 있는 경우도 발생하기 마련이다. 
이러한 변수 때문에 A* 알고리즘을 사용하는 것이다. 그리고 A*를 발전시킨 형태가 D*(Dynamic A*)알고리즘인데, 현세대의 대부분의 차량 내비게이션은 이를 활용한다고 보면 된다.
```

```java
시작 노드만을 지정해 다른 모든 노드에 대한 최단 경로를 파악하는 다익스트라 알고리즘과 다르게 시작 노드와 목적지 노드를 
분명하게 지정해 이 두 노드 간의 최단 경로를 파악할 수 있습니다.

A* 알고리즘은 휴리스틱 추정값을 통해 알고리즘을 개선할 수 있는데요. 이러한 휴리스틱 추정값을 어떤 방식으로 제공하느냐에 
따라 얼마나 빨리 최단 경로를 파악할 수 있느냐가 결정됩니다.
```

## 경로 채점
```java
경로 채점 (Path Scoring)
 자 어떤 사각형을 골라야할 까요? 그 키 포인트는 바로 다음 공식입니다.


F = G + H

G - 시작점 A로부터 현재 사각형까지의 경로를 따라 이동하는데 소요되는 비용입니다.

H - 현재 사각형에서 목적지 B까지의 예상 이동 비용입니다. 사이에 벽, 물 등으로 인해 실제 거리는 알지 못합
니다. 
그들을 무시하고 예상 거리를 산출합니다. 여러 방법이 있지만, 이 포스팅에서는 대각선 이동을 생각하지 않고, 
가로 또는 세로로 이동하는 비용만 계산합니다.

F - 현재까지 이동하는데 걸린 비용과 예상 비용을 합친 총 비용입니다.
```
