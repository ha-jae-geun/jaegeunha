# BFS
* 큐를 이용해서 메모리를 힙에 넣고 빼고 크기 조정 없기 때문에 유리
* 어떤 대상을 조건에 맞게 동작하도록 코드 구현

# DFS
* 스택 이용해서 사용; 크기 조정 필요하기 때문에 BFS에 비해 복잡
* 모든 경우를 만들어 보는 경우

# 백준
## 완전 탐색(Brute-force Search)  [bruːt]  
* 비트 마스크, 순열
* 큐, 

## 예제
* 9095, 1107, 1476
* 차이를 최대로: 10819
* 외판원순회: 10971
* 로또: 6603
* 큐(BFS): 1697, 1963(소수경로), 9019(DSLR), 1525(퍼즐), 물통(2251)
* 재귀호출, 비트마스크: 9095, 암호만들기(1759), N-Queen(9663), 스도쿠(2580), 알파벳(1987), 부분집합의 합(1182)
* 수들의 합 2(2003), 소수의 연속합(1644)
* 덱사용 알고스팟(1261), 중간에서 만나기(1208), 합이 0인 네정수(7453)


## DP
* O(높이 제곱) 을 O(n)으로 낮춰줌

# 순서도
## 증감문
* 증감문이 위면 < 아래면 <=

# for문
- for( 식1 ; 조건1 ; 식2)
{
   코드 1
}

## 정답
- 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 …

## 오답
- 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 .



-- 
# 정렬
## 버블 정렬
 * N * (N + 1) / 2  여서 O(N2) 이지만 가운데 스왑을 계속 해주어야 해서 삽입정렬보다도 실질적으로 안좋은 제일 안좋은 정렬


## 삽입 정렬
 * 자신보다 앞의 원소가 큰지 작은지 비교를 하여서 자신의 위치를 찾아서 '삽입' 하는 정렬입니다.
 * 앞의 원소를 비교해야 하기 때문에 arr[1]~arr[n] 까지 진행합니다. (두번째 원소인 arr[1] 부터 시작.)
 * 삽입을 하면 데이터가 하나씩 밀려야 하기 때문에 배열이 길어질수록 효율이 떨어집니다.


## 퀵 정렬
 - 장점
 * 속도가 빠르다.
 * 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
 * 추가 메모리 공간을 필요로 하지 않는다.
 * 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
 - 단점
 * 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
 * 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
 * EX) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다.


## 힙 정렬
 * - 사실 선택 정렬과 거의 같은 알고리즘으로. 단지 가장 큰 원소를 뒤로 보내는 데에 단순히 매번 쭉 돌면서 알아내느냐 힙을 사용하여 알아내느냐가 유일한 차이점이다.
 * 힙정렬은 추가적인 메모리를 전혀 필요로 하지 않는다는 점과, 최악의 경우에 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(nlgn) 정렬의 성능을 발휘하는 장점이 있다. 하지만 실제 코드를 짜서 비교를 해 보면 퀵정렬이 힙정렬보다 일반적인 경우에 빠르게 동작한다.
 * 그러나 아래 퀵정렬의 경우 피벗을 잡는 전략에 어느 정도의 휴리스틱이 들어가야 최악의 경우를 회피할 수 있으나 힙정렬은 휴리스틱이 필요없이 항상 일정한 성능을 보이는 장점이 있다. 즉 알고리즘에 꼼수를 쓰지 않고, 각종 하드웨어 가속도 전혀 고려하지 않고 알고리즘이 정의하는 최소한만 구현할 경우 힙정렬이 가장 안정적인 성능을 보인다.
 
# 재귀함수
```C
#include <stdio.h>
#include<math.h>
int recursive(int n) {
   int i;
   if (n < 1) { return 2; }
   else
   {
      i = (2 * recursive(n - 1)) + 1;
      printf("%d\n", i);
      return i;
   }
}




void main() {
   int i;
   printf("숫자를 입력하시오");
   scanf_s("%d", &i);
   recursive(i);


}
//5 11 23 47 95
``` 
