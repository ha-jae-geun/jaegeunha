# 함수형 프로그램
1. 인풋과 아웃풋이 있다.
2. 외부 환경으로부터 철저히 독립적이다.
3. 가튼 인풋에 있어서 언제나 동일한 아웃풋을 생산한다.

## 특징
1. 함수형 프로그래밍은 선언형이다.
2. 함수도 값이다; 
   * 자바 스크립트에서 함수값을 변수에 넣음
3. 고계함수
4. 커링
5. 함수 

# 순서도
## 증감문
* 증감문이 위면 < 아래면 <=

# for문
- for( 식1 ; 조건1 ; 식2)
{
   코드 1
}

## 정답
- 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 --> 코드1 수행 --> 식2 수행 --> 조건1 검사 …

## 오답
- 식1 수행 --> 조건1 검사 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 --> 코드1 수행 --> 조건1 검사 --> 식2 수행 .



-- 
# 정렬
* 버블(쓰레기), 선택정렬  -> 삽입(best n) -> 셀정렬(보완)
* 분할정복: 병합정렬, 퀵정렬(합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다, 배열의 병합정렬과 달리 추가 메모리 공간을 필요로 하지 않는다)
* 기타: 힙(가장 큰 값 몇개 필요할 때)


```java
몇 가지 항목 만 –> 삽입(INSERTION) 정렬

아이템은 대부분 이미 정렬되어 있습니다. –> 삽입(INSERTION) 정렬

최악의 시나리오에 대해 걱정 –> 힙(HEAP) 정렬

훌륭한 평균 결과 –> 퀵(QUICK) 정렬

아이템은 조밀 한 우주에서 가져옵니다 –> 버켓 정렬

가능한 한 적은 코드로 작성하고자하는 욕구 –> 삽입(INSERTION) 정렬
```

## 내부정렬
* 주기억 장치에서 이루어짐: 위의 정렬들 모두
* 외부정렬: 보조기억장치에서 이루어짐; 밸런스 병합 정렬, 캐스케이드 병합 정렬, 폴리파즈 병합 정렬, 오실레이팅 병합 정렬

## 버블 정렬  n2 n2 n2
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
 * N * (N + 1) / 2  여서 O(N2) 이지만 가운데 스왑을 계속 해주어야 해서 삽입정렬보다도 실질적으로 안좋은 제일 안좋은 정렬
* https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html


### 장점
* 구현이 매우 간단하다.

### 단점
* 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
* 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
* 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
* 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.


## 삽입 정렬  n n2 n2
 * 자신보다 앞의 원소가 큰지 작은지 비교를 하여서 자신의 위치를 찾아서 '삽입' 하는 정렬입니다.
 * 앞의 원소를 비교해야 하기 때문에 arr[1]~arr[n] 까지 진행합니다. (두번째 원소인 arr[1] 부터 시작.)
 * 삽입을 하면 데이터가 하나씩 밀려야 하기 때문에 배열이 길어질수록 효율이 떨어집니다.

### 장점
* 안정한 정렬 방법
* 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
* 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

### 단점
* 비교적 많은 레코드들의 이동을 포함한다.
* 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.
* https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html

## 선택정렬  n2 n2 n2
 * 제자리 정렬(in-place sorting) 알고리즘의 하나
 * 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
 * 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
 * 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
 * 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
 * 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
* 1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.
 
### 과정 설명
 * 주어진 배열 중에서 최솟값을 찾는다.
 * 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
 * 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
 * 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.
 * https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html


### 장점
* 자료 이동 횟수가 미리 결정된다.

### 단점
* 안정성을 만족하지 않는다.
* 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.
* https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html

## 퀵 정렬  nlogn, nlogn n2
* 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
* 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.

 - 장점
 * 속도가 빠르다.
 * 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
 * 추가 메모리 공간을 필요로 하지 않는다.
 * 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
 - 단점
 * 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
 * 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
 * EX) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다.


### 퀵정렬 과정
 * 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
 * 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
 * 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
 * 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
 * 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
 * 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
 * 리스트의 크기가 0이나 1이 될 때까지 반복한다.
 * 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
 * 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
 * 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
 * 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
 * https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html

### 퀵 정렬 단계


### 장점
* 속도가 빠르다.
* 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
* 추가 메모리 공간을 필요로 하지 않는다.
* 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.

### 단점
* 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
* https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html

## 힙 정렬  nlogn nlogn nlogn
 * - 사실 선택 정렬과 거의 같은 알고리즘으로. 단지 가장 큰 원소를 뒤로 보내는 데에 단순히 매번 쭉 돌면서 알아내느냐 힙을 사용하여 알아내느냐가 유일한 차이점이다.
 * 힙정렬은 추가적인 메모리를 전혀 필요로 하지 않는다는 점과, 최악의 경우에 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(nlgn) 정렬의 성능을 발휘하는 장점이 있다. 하지만 실제 코드를 짜서 비교를 해 보면 퀵정렬이 힙정렬보다 일반적인 경우에 빠르게 동작한다.
 * 그러나 아래 퀵정렬의 경우 피벗을 잡는 전략에 어느 정도의 휴리스틱이 들어가야 최악의 경우를 회피할 수 있으나 힙정렬은 휴리스틱이 필요없이 항상 일정한 성능을 보이는 장점이 있다. 즉 알고리즘에 꼼수를 쓰지 않고, 각종 하드웨어 가속도 전혀 고려하지 않고 알고리즘이 정의하는 최소한만 구현할 경우 힙정렬이 가장 안정적인 성능을 보인다.

## 삽입(n, n2, n2), 힙(nlogn), 선택정렬(n2)
* 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.


## 쉘정렬  n n1.5  n2
* 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 ‘간격(gap)’ 이라고 한다.
* 간격의 초깃값: (정렬할 값의 수)/2
* 생성된 부분 리스트의 개수는 gap과 같다.
* 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
* 간격은 홀수로 하는 것이 좋다.
* 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
* 간격 k가 1이 될 때까지 반복한다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html

### 쉘 정렬이 나온 이유
* 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안
* 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동
* 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있다.
* 삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html


### 장점
* 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.
* 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬보다 더욱 빠르게 수행된다.
* 알고리즘이 간단하여 프로그램으로 쉽게 구현할 수 있다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html

## 병합정렬  nlogn, nlogn nlogn
* ‘존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법
* 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
* 분할 정복(divide and conquer) 방법
* 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
* 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.

### 과정 설명
* 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
* 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
* 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
* 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.


### 과정
* 2개의 정렬된 리스트를 합병(merge)하는 과정
* 2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮긴다.
* 둘 중에서 하나가 끝날 때까지 이 과정을 되풀이한다.
* 만약 둘 중에서 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 값들을 전부 새로운 리스트(sorted)로 복사한다.
* 새로운 리스트(sorted)를 원래의 리스트(list)로 옮긴다.
https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


### 단점
* 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
* 제자리 정렬(in-place sorting)이 아니다.
* 레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

### 장점
* 안정적인 정렬 방법
* 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
* 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
* 제자리 정렬(in-place sorting)로 구현할 수 있다.
* 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


## 힙정렬
* 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
* 최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조
* 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
* 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.

### 과정 설명
* 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
* 내림차순을 기준으로 정렬
* 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
* 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.


1. 내림차순 정렬을 위한 최대 힙(max heap)의 구현
* 힙(heap)은 1차원 배열로 쉽게 구현될 수 있다.
* 정렬해야 할 n개의 요소들을 1차원 배열에 기억한 후 최대 힙 삽입을 통해 차례대로 삽입한다.
* 최대 힙으로 구성된 배열에서 최댓값부터 삭제한다.

2. 최대 힙(max heap)의 삭제
* 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
* 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
* 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
* 힙을 재구성한다.
* 아래의 최대 힙(max heap)에서 최댓값을 삭제해보자. 

### 장점
* 시간 복잡도가 좋은편
* 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.
 
 
# 해싱
* 데이터 -> 해싱함수 -> 해시 테이블(인덱스, 값으로 이루어져 있음)
* 같은 값이 해싱되면 같은 값으로 
 
# 재귀함수
```C
#include <stdio.h>
#include<math.h>
int recursive(int n) {
   int i;
   if (n < 1) { return 2; }
   else
   {
      i = (2 * recursive(n - 1)) + 1;
      printf("%d\n", i);
      return i;
   }
}




void main() {
   int i;
   printf("숫자를 입력하시오");
   scanf_s("%d", &i);
   recursive(i);


}
//5 11 23 47 95
``` 


# 트리
## 이진트리 그림
* B트리의 단점 -> B+(링크드 리스트가 구성되어 순차탐색의 효율을 높임); 인덱스 세트와 순차세트로 이루어짐
   * -> B트리는 1/2이면 분열할 수 있으나 B* 트리는 최소 2/3가 되어야 노드 분열
      * 노드가 가득차면 분열하지 않고 인접 노드로 재배치하며 인접 노드가 가득찰 때까지 지연
      * 노드 분리는 인접노드가 가득찬 ㄱㅇ우에 분열하며, 새로운 노드가 

## 이진트리
* 이진트리검색의 문제점은 좌우 균형이 맞지 않으면 비효율적이다.

```java
검색을 위한 자료구조 중에서 이진 트리는 비록 하나의 부모가 두 개의 자식밖에 가지질 못하고 자칫 균형이 맞지 않으면 검색 효율이 선형검색 급으로 떨어지지만 잠재력이 가장 크다. 그렇지만 이진 트리는 구조의 간결함과 균형만 맞다면 검색, 삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있어서 이를 바탕으로 개선하고자 하는 노력이 많이 있어 왔다.



그 중에서도 B-Tree는 이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화하였다. B-트리는 자식 수에 대한 일반화를 하면서 하나의 레벨에 더 많이 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞추는 로직까지 갖추었다. 게다가 이 균형 로직은 단순하면서도 효율적이다. 그래서 B-트리는 레벨로만 따지면 완전히 균형을 맞춘 트리이다.



대량의 데이터를 처리해야 하는 검색 구조인 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 큰 장점이다.

대량의 데이터는 메모리 보다는 하드디스크 혹은 SSD에 저장되어야 하는데 이들 외부 기억 장치들은 블럭 단위로 입출력을 하기 때문이다.



예를 들어 한 블럭이 1024 바이트라면 2바이트를 읽으나 1024 바이트를 읽으나 입출력에 대한 비용은 동일하다. 그렇다면 하나의 노드를 1024바이트가 되도록 조절한다면 입출력 면에서 매우 효율적인 구성이 된다. 이런 장점으로 실제 B-Tree는 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용되고 있다.

출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

## Balanced Tree
* 삽입과 삭제 시 필요하면 스스로 균형을 유지한다.
* 항상 O(로그N)의 검색 성능

### B 트리
```java
B-트리란 하나의 노드에 여러자료가 배치되는 트리 구조이다. 한 노드에 M개의 자료가 배치되면 M차 B-Tree라고 한다.

5차 B-트리 인 경우 자식노드가 최대 5개인 것을 의미한다. B-트리는 스스로 균형을 맞추는 트리이다 .그래서 최악의 경우에도 O(logN)의 검색 성능을 보인다. 또한 B-트리는 하나의 노드에 많은 수의 데이터를 저장할 수 있다. 


규칙
노드의 자료수가 N이라면 자식의 수는 N+1이어야 한다. 
각 노드의 자료는 정렬된 상태여야 한다.
노드의 자료Dk의 왼쪽 서브트리는 Dk보다 작은 값들이고 오른쪽 서브트리는 Dk보다 큰 값들이어야 한다.
Root 노드는 적어도 2개이상의 자식을 가져야 한다.
Root 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고 있어야 한다.
외부 노드로 가는 경로의 길이는 모두 같다. - 외부노드는 모두 같은 레벨에 있다
입력자료는 중복될 수 없다. 


출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B+ 트리
```java
B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다. (Wedekind, 1974) B-트리에서는 특정 key 값이 하나의 노드에서만 존재할 수 있지만 B+ 트리에서는 leaf 노드와 leaf의 부모 노드에서 공존할 수 있다. B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할만 하기 때문이다. (index set 이라 불린다) 그리고 leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다. 고로 B+ 트리는 (기존의 B-트리 + 데이터의 연결 리스트)로 구현된 색인구조라고 할 수 있다. 

1. 정리 : B-트리의 변형 구조로 index 부분과 leaf 노드로 구성된 순차 data 부분으로 이루어진다. Index 부분의 key 값은 leaf에 있는 key 값을 직접 찾아 가는데 사용하고 모든 key 값은 leaf 노드에 나열된다. 즉, index 부분의 key 값도 leaf 노드에 다시 한 번 나열된다. Leaf 노드는 순차적으로 linked list를 구성하고 있어서 순차적 처리가 가능하다.

2. 삽입
1) B-tree와 거의 동일하게 이루어진다.
2) 노드의 분열이 일어나면 중간 key 값이 부모 노드로 올라갈 뿐 아니라 새로 분열된 노드에도 포함되어야 한다.
3) 새 노드는 leaf 노드끼리의 linked list에도 삽입되어야 한다.

3. 삭제
1) 재배치와 합병이 필요하지 않을 때는 leaf 노드에서만 삭제된다.
2) Index 부분은 다른 key 값을 찾는데 사용될 수 있기 때문에 leaf node의 값이 삭제되어도 삭제하지 않는다.
3) 재배치할 경우 index 부분의 node의 key 값은 변하지만 tree 구조는 변하지 않는다.
4) 합병을 할 경우 index 부분에서도 key 값을 삭제한다.



http://egloos.zum.com/sweeper/v/899699



예시)

b트리와 달리 트리의 최하위 레벨의 리프노드에만 데이터 들이 정렬되어있음. 
나머지 노드들은 키값만 가지고 있다.
파일시스템 같은 블록기반 스토리지에서 저장데이터의 효율적인 검색에 유용함

58
1234/567/89 10


이와같이 인덱스에 사용되던 키값마저 리프노드에 중복되어있다.
또한 1->2->3->4->5->.,...->10순으로 각 리프로드가 링크되어 linked list를 구성하고 있기 때문에
데이터의 순차적 처리가 가능하다.


출처: http://lssang.tistory.com/entry/알고리즘-B트리-B트리 [쩡자의 개발노트]
출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B* 트리
```java
1. 정의
B-Tree의 각 노드는 디스크의 블록과 같기 때문에 노드 하나를 접근하는 것은 디스크를 한번 더 접근하는 것을 의미한다. 그러므로 보다 적은 수의 노드를 생성하는 것이 색인구조의 성능을 높일 수 있다. 생성되는 노드의 수를 줄이기 위해 B-Tree의 변형으로 B* 트리가 나오게 되었다.

B-Tree는 특성을 유지하기 위해 삽입과정에서의 분열과 삭제 과정에서의 합병 등의 보조 연산이 필요하다. B* Tree에서는 이런 보조 연산을 가급적 지연시켜 회수를 감소시키려 헸다.

2. 조건
1) Root 노드를 제외한 모든 노드는 2/3 이상 채워져야 된다. (B-Tree는 1/2 이상)
2) B* Tree는 노드의 분열을 줄여서 보조 연산을 줄이려고 한다. 따라서 노드가 가득차면 분열하는 대신 이웃한 형제 노드로 재배치를 한다.
---> 재배치 작업은 부모노드+해당노드+형제노드의 key들을 나열한 뒤, 중간 key 값을 부모 노드로 보내고 남은 key들을 반분하여 해당노드와 형제노드에 배치하는 행동이다. 중요한 것으므로 이해 필요;
3) 한 노드가 가득차고 인접 노드까지 모두 가득찰 때까지 분열을 지연한다.

이러한 노력으로 B* 트리의 평균 저장공간 사용률은 81%에 달한다. (Leung, 1984)

3. 삽입
1) B-Tree에서와 같은 방법으로 삽입을 한다.
2) 노드가 가득차면 이웃한 형제 노드를 살펴 빈 자리가 있으면 정렬하여 재배치한다.
3) 인접 노드에도 key 넘침 현상(overflow)이 일어나서 더 이상 빈 자리가 없을 경우, 가득찬 두 노드를 분열하여 2/3 정도 채워진 3개의 노드로 만든다. 이 과정에서 재배치 동작은 2번 발생한다. (가득찬 두 노드를 분열하여 3개의 노드로 만들 때 첫번째 노드와 두번째 노드간의 재배치 그리고 두번째 노드와 세번째 노드간의 재배치)

4. 삭제
B-Tree와 똑같이 삭제 후 key 값의 개수가 모자라면 이웃한 형제 노드로부터 재배치하고 재배치도 할 수 없는 경우 합병한다. 합병할 때는 세 개의 노드를 두 개의 노드로 합병한다.

출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B-tree 와 B+tree
 * B-tree와 각 노드에 데이터가 저장이 되지만 B+tree의 경우엔 인덱스노드와 리프노드가 분리되어서 존재한다. 
 * 그리고, 리프노드는 서로 연결되어 있어서 임의접근과 순차접근모드 성능이 우수하다. 

#### 공통점
1. 모든 leaf의 depth가 같다
2. 각 node에는 k/2 ~ k 개의 item이 들어있어야 한다.
3. search가 비슷하다.
4. add시 overflow가 발생하면 split 한다
5. delete 시 underflow가 발생하면 redistribution하거나 merge 한다.

#### 차이점
1. B-tree의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다. 여기서 data는 disk block으로의 포인터가 될 수 있다.
  B+tree는 각 node에서는 key만 들어가야 한다. 그러므로 B+tree에서는 data는 오직 leaf에만 존재한다.
2. B+tree는 B-tree와는 달리 add, delete가 leaf에서만 이루어진다.
3. B+ tree는 leaf node 끼리 linked list로 연결되어 있다.

#### B+tree의 장점
- 블럭사이즈(노드사이즈) 를 더 많이 이용할수잇다 ( 키값에 대한 harddisk 엑세스 주소가 없기 때문에 )
- leaf node 끼리 linked list로 연결되어있어서 시퀀셜한 레인지 탐색에 매우 유리하다 


#### B + Tree 의 단점
- B Tree의 경우 best case에는 루트에서 끝날수 있지만, B+ Tree의 경우 무조껀 leaf노드까지 가야한다.
