# [BST가 Balanced 되어있는게 왜 중요한지 설명해주세요](https://www.notion.so/Tree-b5cdac1f2aa04b42be58b1d221f60006)

- 답변

    BST 조회 / 삽입 / 삭제 연산의 worst case 성능은 Tree의 높이에 비례한다. 리프노드까지의 비교연산횟수가 트리의 높이와 같기 때문이다. 만약 트리가 치우쳐 있다면, 높이는 n에 근접해 조회성능이 O(n) 에 가까워지게 된다.

    하지만, 트리가 최대로 밸런스되어있다면 full binary tree의 모양을 형성하게 된다. 이때 수학적으로 데이터갯수가 총 N개라면 트리의 높이는 logN이 되고, 결국 조회성능은 O(log n)이 된다.  

    정리하자면, 트리가 치우쳐있을수록 조회성능은 O(n), 밸런스되어있을 수록 O(log n)에 근접하게 된다.

### AVL 트리가 밸런스를 맞추는 과정을 설명해 주세요

- 답변

    일반적인 BST 삽입 과정과 같이, 처음엔 생성할 노드를 리프노드까지 비교하며 내려간 후, 새로운 노드를 삽입한다.

    이후엔 재귀적으로 상위노드로 올라가며, Balance Factor를 조사해 절대값이 2이상인 경우 케이스별로 rotation을 수행한다. rotation을 수행하게되면 해당 노드에서 balance factor 초과를 해소할 수 있다.

    unbalance 상황은 LL, RR, LR, RL로 4가지 케이스가 있다

    회전 이후, 마찬가지로 재귀적으로 상위노드를 올라가며 balance를 맞추는 과정을 반복하게 된다. 

### Red-Black Tree에 대해 설명해 주세요

- 답변

    BST조건을 만족하며, 다음의 4가지 조건을 항상 유지하는 트리가 래드블랙트리 이다.(1개는 생략)

    1. 모든 노드는 블랙/레드 색상중 하나
    2. 루트노드는 블랙
    3. 모든 노드에서, 본인의 서브트리에 속한 리프노드에 이르는 모든경로는 블랙노드 개수가 같다
    4. 레드노드는 연속할 수 없다(부모,자식 관계에서)

    특히 3번과 4번조건을 만족하게 되면, 가장짧은 경로와 가장 긴경로의 길이가 2배이하로만 차이난다는 조건을 만족하게 된다. 왜냐하면 가장 짧은 경로는 블랙노드만 존재할 수 밖에 없고, 가장 긴 경로는 블랙노드와 레드노드가 번갈아 존재할 수 밖에 없기 때문이다(레드노드는 연속 불가)

    bf를 1 이하로 관리하는 AVL 트리와 비교해서는 roughly blanced 된 트리라고 할 수 있다.

### Red-Black 트리의 insert 과정에 대해 설명해 주세요(미완, Hard)

- 답변

    우선 관심이 있으신분들은 다음의 참고자료를 먼저 읽어주시기 바랍니다. 

    더 직관적이고 쉬운 자료로 재작성될 계획입니다. 결론적으로, 레드블랙트리의 insert 과정에서 rotation 횟수는 O(1) 입니다. AVL 트리에서는 O(log n) 입니다. 

    [https://lsh424.tistory.com/72?category=914327](https://lsh424.tistory.com/72?category=914327)

### Red-Black 트리와 AVL 트리를 선택하는 기준이 무엇일까요?

- 답변
    - AVL 트리가 훨씬 타이트하게 balanced 되어있는 트리이다. 조회성능은 결국 트리의 높이에 의해 결정되기 때문에, 조회가 주된 용도인 상황인 경우, AVL 트리를 선택하는 것이 좋다.
    - insert intensive 한 상황인 경우, 레드블랙트리를 사용하는 것이 좋다. 레드블랙트리는 삽입 연산이 O(1)의 rotation을 보장한다. 그러나, AVL 트리는 O(logn)의 rotation이 일어날 수 있다.

    참고자료: [https://ko.wikipedia.org/wiki/레드-블랙_트리#세_번째_경우](https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC#%EC%84%B8_%EB%B2%88%EC%A7%B8_%EA%B2%BD%EC%9A%B0)

### AVL 트리와 B-tree 의 다른점이 무엇일까요?

- 답변

    AVL 트리와 B트리 모두 모든 연산성능이 O(log n) 이라는 점에서 같다. 왜냐하면 트리의 높이가 조회시 비교연산횟수에 가장 큰 영향을 주기 때문이고, 두 트리모두 높이가 logn을 보장하기 때문이다.

    그러나 **AVL 트리의 경우** in-memory(프로그램이 돌아갈때(런타임)만 사용되고 저장하지 않는 것을 의미. 메인메모리,캐시에서 일시적으로 저장해 잠깐 사용하는 용도) 용도로 사용되는 데이터구조이다. 데이터 1개당 동적할당 1번을 일으켜 노드를 생성하기 때문에, 메모리 access 횟수가 많다. 그러나 모든 메모리 access가 최대 메인메모리까지만 요청되기 때문에 빠르다(데이터 갯수가 적기 때문에 가능)

    **B-tree의 경우** 데이터갯수가 매우 많은 경우 사용되는 트리구조이다. 하나의 노드에서 매우 많은 데이터를 배열의 형태로 보관한다. 따라서, disk 로부터 노드 조회시 한번의 read로 노드 안에 배열데이터들을 한번에 fetching 할 수 있다. 노드를 처음 방문할 때만 disk에 접근하고, 한번의 fetching을 통해 내부 배열데이터를 모두 메인메모리에 적재하기 때문에, 배열데이터를 일렬로 조회할때는 메인메모리까지만 접근하게 되는 것이다. 또한, 노드 안에서 여러데이터를 배열로 보관하는 덕분에 전체 트리의 높이가 낮아져 disk 접근횟수가 적어지게 된다.

**이제부터는 B-tree와 데이터베이스 인덱스를 함께 묻는 질문 입니다.**

B-tree 자료구조에 대한 질문은 보통 데이터베이스의 index 성능과 관련되어 함게 물어봅니다(B-tree가 index 생성시 내부적으로 사용되는 자료구조이기 때문입니다) 

따라서, B-tree의 성능과 원리를 빠삭하게 알더라도, 데이터베이스의 인덱스와 관련된 지식이 없으면 매끄러운답변은 불가능 합니다.

아래 참고자료를 추가적으로 꼭 공부하시기 바랍니다(이미 배우신 분들은 가볍게 읽어보시기 바랍니다)

‣ 

### 데이터베이스 index가 어떻게 성능을 향상시키나요? 내부동작에대해 아는만큼 답해주세요.

- 답변

    데이터베이스 테이블에서 특정 컬럼으로 인덱스를 생성한 경우, 해당 컬럼값을 key로 하는 B-tree(혹은 해시테이블)을 생성하게 된다. 

    인덱스 생성 이후부터는, 해당 컬럼 값이 where 조건절에 등장하는 경우, B-tree 조회를 이용할 수 있게 된다. 따라서, O(log N) 비교 횟수안에서 원하는 row를 찾을 수 있게 된다. 

    예를 들어, SELECT * FROM dnial_table WHERE person_number = 30; 쿼리를 생각해보자.

    person_number 이라는 컬럼으로 인덱스를 생성해놓았을 경우 키값이 person_number이고 노드내부에 해당 데이터의 row address 포인터를 갖는 B-tree를 생성해 놓는다. 따라서 위 쿼리의 where 조건절인 person_number = 30 에 해당하는 노드를 O(log n) 에 찾을 수 있고, 해당 노드안에 있는 row_address를 통해 테이블의 row에 바로 접근할 수 있게된다.

    만약, person_number 라는 column으로 인덱스를 생성해놓지 않았을 경우, 위 쿼리는 모든테이블을 순차적으로 돌며 조건에 맞는 row을 모두 찾아 반환하게 될 것이다. 이 경우, 성능은 O(N)이다.

### 데이터베이스에서 B-tree 인덱스는 어떻게 동작하나요? 아는만큼 답해주세요.

- 답변

    데이터베이스 테이블에서 특정 컬럼으로 인덱스를 생성하면(B-tree 인덱스 생성으로 가정) 이 컬럼을 key값으로 하고 해당 데이터의 row를 포인터로 갖는 노드로 구성된 B-tree를 만들게 된다. 다음부터 인덱스를 만든 컬럼값과 관련된 조회에서는 이 인덱스를 통해 빠르게 조회가 가능하다. 

    select * from danial_table where a = 10;

    select * from danial_table where 3 ≤ a and a ≤ 10;

    만약 a 컬럼으로 인덱스를 만들었다면, 위의 두 쿼리에 대해 O(log n) 으로 해당되는 row들을 찾아올 수 있다. 특히, 두번째 쿼리는 범위조회 쿼리인데도 B-tree 자료구조로 해당되는 row들을 O(log n) 안에 모두 찾아올 수 있다. 왜냐하면 첫값(3)과 끝값(10)에 해당하는 Node를 logn으로 찾은 후, 사이에 있는 데이터를 모두 가져오면 되기 때문이다.

### 데이터베이스에서 B-tree index를 갖는것은 이후에 어떤 비용을 초래하게 되나요?(예를들어, 데이터 삽입/삭제 에서)

- 답변

    특정 컬럼으로 인덱스를 생성하게 되면, 내부적으로는 B-tree 혹은 해시테이블등의 자료구조를 영구적으로 생성하여 관리하게 된다. 

    insert/delete 연산시, 원래 테이블에 새로운 row를 추가/삭제 처리 하는 것에서 끝나지만, 인덱스를 생성한 이후부터는 인덱스 자료구조에도 똑같이 insert/delete 연산을 적용해야 한다. 

    따라서, 인덱스 생성시 해당하는 컬럼을 where 조건절에넣어 조건에 일치하는 row 조회과정은 빨라지겠지만, 삽입/삭제 과정에서 시간이 추가적으로 소모된다.
