# 트리
* 이진트리와 non-binary tree로 나눠진다.
  * 이진트리는 balanced binary tree(높이 1 이하로 균형을 이루는 트리), unbalanced binary tree로 나눠진다.
  * 균형이진탐색트리(균형을 먖추기 위해 나온 AVL 트리)
    * 균형 이진 탐색트리에는 여러가지가 있는데 대표적으로 AVL 트리 , 레드-블랙트리(Red-Black Tree) , B 트리, B+ 트리, B* 트리 들이 있다.
    * 회전을 자주하는 AVL을 대신하여 Red-Black tree 등장
     * 데이터의 양에 따라 비교해야 할 높이가 계속 높아진다. 왜냐하면 이진트리는 하나의 부모노드가 가지는 자식노드가 최대 2개 제한되어있기 때문이다.
      * 그래서 (non binary tree: B-) 가 등장한다.
* 나보다 작은 것은 왼쪽, 큰 것은 오른쪽: 이진탐색 
```java
위 그림에서 검정색 동그라미를 노드(node)라고 합니다. 보통 데이터가 여기에 담깁니다. 노드와 노드 사이를 이어주는 선을 엣지(edge)라고 합니다. 노드와의 관계를 표시합니다.

경로(path)란 엣지로 연결된, 즉 인접한 노드들로 이뤄진 시퀀스(sequence)를 가리킵니다. 경로의 길이(length)는 경로에 속한 엣지의 수를 나타냅니다.

트리의 높이(height)는 루트노드에서 말단노드에 이르는 가장 긴 경로의 엣지 수를 가리킵니다. 트리의 특정 깊이를 가지는 노드의 집합을 레벨(level)이라 부릅니다.

잎새노드(leaf node)란 자식노드가 없는 노드입니다. internal node란 잎새노드를 제외한 노드를 나타냅니다. 루트노드(root node)란 부모노드가 없는 노드를 가리킵니다.

트리의 속성 중 가장 중요한 것이 ‘루트노드를 제외한 모든 노드는 단 하나의 부모노드만을 가진다’는 것입니다. 이 속성 때문에 트리는 다음 성질을 만족합니다.

임의의 노드에서 다른 노드로 가는 경로(path)는 유일하다.
회로(cycle)가 존재하지 않는다.
모든 노드는 서로 연결되어 있다.
엣지(edge)를 하나 자르면 트리가 두 개로 분리된다.
엣지(edge)의 수 |E| 는 노드의 수 |V|에서 1을 뺀 것과 같다.
```

# 인덱스
```java
어떤 노드의 인덱스를 index, 왼쪽 자식노드의 인덱스를 left_index, 오른쪽 자식노드의 인덱스를 right_index로 선언하면 다음과 같은 관계를 지닙니다. 

left_index = 2 * index + 1
right_index = 2 * index + 2
```

# 전위, 후위, 중위
```java
preorder
루트 노드에서 시작해서 노드-왼쪽 서브트리-오른쪽 서브트리 순으로 순회하는 방식입니다. 깊이우선순회(depth-first traversal)라고도 합니다. 
위 예시 트리에 전위순회 방식을 적용하면 다음과 같습니다.

1, 2, 4, 5, 3

inorder
루트 노드에서 시작해서 왼쪽 서브트리-노드-오른쪽 서브트리 순으로 순회하는 방식입니다. 대칭순회(symmetric traversal)라고도 합니다. 
위 예시 트리를 중위순회 방식을 적용하면 다음과 같습니다.

4, 2, 5, 1, 3

postorder
루트 노드에서 시작해서 왼쪽 서브트리-오른쪽 서브트리-노드 순으로 순회하는 방식입니다. 위 예시 트리를 후위순회 방식을 적용하면 다음과 같습니다.

4, 5, 2, 3, 1
```

# Binary Tree

## 이진트리
* [잉구]('https://wangin9.tistory.com/entry/B-tree-B-tree')
* 일반적으로 데이터를 정해진 규칙에 따라 저장하고 빠르게 찾는 검색용도에 많이 사용한다.
* 이진트리검색의 문제점은 좌우 균형이 맞지 않으면 비효율적이다.
* 이진 트리(二進-, 영어: binary tree)는 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조로, 자식 노드를 각각 왼쪽 자식 노드와 오른쪽 자식 노드라고 한다.
* 힙 정렬과 이진탐색트리는 모두 이진트리를 기반으로 만들어진 기법입니다. 

### 정이진트리
* 정이진트리는 다음 그림과 같습니다. 모든 레벨에서 노드들이 꽉 채워진(=잎새노드를 제외한 모든 노드가 자식노드를 2개 가짐) 이진트리입니다.

### 완전이진트리
* 완전이진트리는 다음 그림과 같습니다. 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리입니다.

### 균형이진트리
* 균형이진트리는 다음 그림과 같습니다. 모든 잎새노드의 깊이 차이가 많아야 1인 트리를 가리킵니다. 균형이진트리는 예측 가능한 깊이(predictable depth)를 가지며, 노드가 n개인 균형이진트리의 깊이는 logn을 내림한 값이 됩니다.

```java
그림1 에서 4를 찾는다면 4번의 탐색이 필요하게 된다. 

이렇게 이진 탐색트리가 한쪽으로 치우쳐저 있는 트리를 skewed binary search tree(편향 이진 탐색 트리) 라고 부르는데 성능면에서 최악의 경우(worst case)인 것이다. 


그래서 최악의 경우를 피하기 위해 또는 계속 추가되는 노드로 인해 높이가 점점 커지는것을 좀 더 막을수 있는 방법이 무엇일까 ?

고민하였고 나오게된 것이 균형 이진 탐색 트리(Balanced Binary Search Tree) 인 것이다. 

균형 이진 탐색 트리란  노드의 삽입과 삭제가 일어나는 경우에 자동으로 그 높이를 작게 유지하도록 되어 있다.

그래서 아무리 노드의 빈번한 추가 삭제가 아무리 많이 있어도 높이가 얼마 이상되지 않도록 제약하는 특성을 갖게 되어 성능상 매우 유리하다. 


예를들어 그림2-a 처럼 균형이 맞지 않는 트리의 경우 루트에서 특정 노드로 갈 때 평균 3.27회의 노드 접근이 필요하다.

하지만 그림2-b 처럼 트리의 높이 균형을 맞춘다면 이동 비용이 3.0 으로 감소된다.  (위키 - 균형 이진 탐색 트리

균형 이진 탐색트리에는 여러가지가 있는데 대표적으로 AVL 트리 , 레드-블랙트리(Red-Black Tree) , B 트리, B+ 트리, B* 트리
```



# 이진 탐색은 알고리즘, 이진 탐색 트리는 자료구조

## 이진탐색트리 시간복잡도
```java
배열 정렬 O: 탐색: logn 삽입: O(n) 삭제: O(n)(삭제 후 shift)
배열 정렬 X: 탐색, 삽입, 삭제(찾았다고 가정하고 삭제만)
연결리스트 정렬 O: 탐색: O(n) 삽입: O(n) 삭제: O(1)(찾았다고 가정하고 삭제만)
연결리스트 정렬 x: 탐색: O(n) 삽입: O(1) 삭제: O(1)(찾았다고 가정하고 삭제만)


정렬된 혹은 정렬되지 않은 배열, 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)의 시간복잡도를 가짐.

* 3가지 연산 모두 O(n)의 시간을 갖지 않는 효율적인 알고리즘은 없는가?

1. 이진탐색트리(Binary Search Tree), 레드-블랙 트리, AVL- 트리등의 트리에 기반한 구조들
2. Direct Address Table, 해시 테이블 등
```

## 이진탐색트리
```java
이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. 
X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 
동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교한다. 해당 값을 찾을 때까지 이 과정을 반복한다.
```


## 이진검색트리
```java
이진탐색트리란 이진탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조의 일종입니다.
이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.

예컨대 이진탐색의 경우 탐색에 소요되는 계산복잡성은 O(logn)으로 빠르지만 자료 입력, 삭제가 불가능합니다.
연결리스트의 경우 자료 입력, 삭제에 필요한 계산복잡성은 O(1)로 효율적이지만 탐색하는 데에는
O(n)의 계산복잡성이 발생합니다. 두 마리 토끼를 잡아보자는 것이 이진탐색트리의 목적입니다.

이진탐색트리를 순회할 때는 중위순회(inorder) 방식을 씁니다.
(왼쪽 서브트리-노드-오른쪽 서브트리 순으로 순회) 이렇게 하면 이진탐색트리 내에 있는 모든 값들을 
 정렬된 순서대로 읽을 수 있습니다. 다음 예시와 같습니다.

```

### 이진검색트리 속성
```java
각 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값을 지닌 노드들로 이루어져 있다.
각 노드의 오른쪽 서브트리에는 해당 노드의 값보다 큰 값을 지닌 노드들로 이루어져 있다.
중복된 노드가 없어야 한다.
왼쪽 서브트리, 오른쪽 서브트리 또한 이진탐색트리이다.
```

### 이진검색트리 최악
```java
위에서 보듯, 이진 탐색 트리 연산의 시간복잡도는 트리 높이 h에 비례합니다.
트리가 충분히 균형잡혀 있다면 h=O(logn)이 되어 아주 빠르게 연산할 수 있지만 
다음과 같이 똑같이 1, 2, 3, 4, 6, 7, 8, 10, 15를 포함하고 있어도 한 쪽으로 
치우친(skewed) 경우에는 정렬된 연결 리스트와 다를 게 없습니다. 결국 평균적으로는 O(n)보다 
빠를지 몰라도 최악의 경우엔 정렬된 연결 리스트와 동일한 성능을 보여줍니다.
```



## 이진 탐색 트리
* [ratsgo](https://ratsgo.github.io/data%20structure&algorithm/2017/10/22/bst/)
* 이진탐색트리라고 하면 왼쪽 자식은 부모님보다 작고, 오른쪽 자식은 부모님보다 큰 조건만 잘 따라주면 이진탐색트리라는 것이다. 
* 정의: 모든 부모노드가 좌측 자식노드에는 더 작은값을 우측 자식노드에는 더 큰 값을 갖는 형태이다
  * 이러한 형태로 배열보다 평균적인 탐색 속도가 빠르다
    * 왜냐하면 최악의 경우에도 최대 높이만큼만 비교하면 값을 찾을 수 있다.
* 이진탐색트리란 이진탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조의 일종입니다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 
빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.
* 예컨대 이진탐색의 경우 탐색에 소요되는 계산복잡성은 O(logn)으로 빠르지만 자료 입력, 삭제가 불가능합니다. 연결리스트의 경우 자료 입력, 
삭제에 필요한 계산복잡성은 O(1)로 효율적이지만 탐색하는 데에는 O(n)의 계산복잡성이 발생합니다. 두 마리 토끼를 잡아보자는 것이 이진탐색트리의 목적입니다.

### 이진트리 단점
* 데이터를 삭제하거나 삽입할 때도 규칙을 따라야 한다.
* 루트 노드를 삭제할 때는 왼쪽 서브트리의 제일 큰값이나 오른쪽 서브 트리의 가장 작은 값과 바꿔주면 된다.
* 데이터를 삭제하다 보면 unbalanced binary tree가 될 수 있다.


```java
검색을 위한 자료구조 중에서 이진 트리는 비록 하나의 부모가 두 개의 자식밖에 가지질 못하고 자칫 균형이 맞지 않으면 
검색 효율이 선형검색 급으로 떨어지지만 잠재력이 가장 크다. 그렇지만 이진 트리는 구조의 간결함과 균형만 맞다면 검색, 
삽입, 삭제 모두 O(logN)의 성능을 보이는 장점이 있어서 이를 바탕으로 개선하고자 하는 노력이 많이 있어 왔다.



그 중에서도 B-Tree는 이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화하였다. B-트리는 자식 수에 대한 
일반화를 하면서 하나의 레벨에 더 많이 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞추는 로직까지 갖추었다. 
게다가 이 균형 로직은 단순하면서도 효율적이다. 그래서 B-트리는 레벨로만 따지면 완전히 균형을 맞춘 트리이다.



대량의 데이터를 처리해야 하는 검색 구조인 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 큰 장점이다.

대량의 데이터는 메모리 보다는 하드디스크 혹은 SSD에 저장되어야 하는데 이들 외부 기억 장치들은 블럭 단위로 입출력을 하기 때문이다.



예를 들어 한 블럭이 1024 바이트라면 2바이트를 읽으나 1024 바이트를 읽으나 입출력에 대한 비용은 동일하다. 
그렇다면 하나의 노드를 1024바이트가 되도록 조절한다면 입출력 면에서 매우 효율적인 구성이 된다. 
이런 장점으로 실제 B-Tree는 많은 데이터베이스 시스템의 인덱스 저장 방법으로 애용되고 있다.

출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

# Balanced Tree
* 삽입과 삭제 시 필요하면 스스로 균형을 유지한다.
* 항상 O(로그N)의 검색 성능

## AVL Tree(균형잡힌 이진트리)
*  삽입과 삭제를 할 때에는 원하는 노드를 찾기 위해 2개의 경로가 필요하기 때문에 레드-블랙 트리 만큼 효율이 좋지 않아 자주 쓰이지는 않는다.[2]
* AVL 트리란 서브트리의 높이를 적절하게 제어해 전체 트리가 어느 한쪽으로 늘어지지 않도록 한 이진탐색트리(Binary Search Tree)의 일종입니다. 트리의 높이가 h일 때 이진탐색트리의 계산복잡성은 O(h)이기 때문에 균형된 트리를 만들어 h를 줄이고자 하는 발상에서 비롯됐습니다.
* Binary tree를 삭제할 때마다 균형인수를 따져 불균형한 경우 노드를 재배치하는 알고리즘
* 균형인수: 균형상태를 숫자로 나타낸 것(왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이)
  * 균형인수가 +-2일 때 트리의 회전을 통해 불균형을 해소하게 된다.

### AVL 단점
* 균형을 유지하여 검색속도를 유지하지만 회전을 자주하기 때문에 삽입과 삭제속도가 느려진다.

### AVL 삽입
```java
요소 하나 추가하는 데 이렇게까지 복잡하게 할 필요가 있을까 싶기도 합니다. 하지만 AVL 트리는 기본적으로 이진탐색트리라는 
점에 유의해야 합니다. 삽입 연산을 수행하더라도, 부모노드는 왼쪽 자식노드보다 크거나 같고, 오른쪽 자식노드보다는 작거나
같다는 성질이 깨지지 않도록 해야 한다는 이야기입니다.
```

### 회전에서 주의해야 할 점
* LL회전에서 두 번쨰 노드에 오른쪽 자식노드가 붙은 경우
* RR 회전에서 두번째 노드에 왼쪽 자식노드가 붙은 경우

## Red-Black Tree
* AVL의 회전을 자주하는 점을 
* 노드에 색깔을 붙이고 이 색깔을 통해 정해진 규칙을 지키기만 하면 균형이 지켜지는 알고리즘

### Red-Black Tree 규칙 5가지
1. 모든 노드는 레드 아니면 블랙 두 가지 색이다. 
2. 루트 노드는 반드시 블랙이다.
3. 레드는 경로상에 연달아 올 수 없다
4. 최종노드에는 비어있는 리프노드 2개가 붙으며, 이는 블랙이어야 한다.
5. 이 모든 규칙을 지킬 시 루프부터 리프노드에 이르는 경로에서 만나는 블랙노드의 수는 항상 같다.
* 리프노드: NIL 노드; External Node

### Red-Black Tree에서 레드가 연달아 온 경우
1. 부모노드가 레드지만 형제는 블랙인 경우
  * AVL 트리에서와 같이 회전을 이용하여 불균형을 해소한다.
2. 부모노드와 부모의 형제가 모두 레드인 경우
  * 색상변환: 부모노드와 부모의 형제노드를 블랙으로 바꾸고 조부모는 레드로 바꿔준다.
    * 하지만 여기서 루트가 블랙이어야 하는 조건이 항상 우선한다. 


### Red-Black Tree
* AVL트리처럼 균형을 엄격하게 지키지는 않지만 삽입이나 삭제시에 성능을 보장한다.
* 실용적인 수준의 균형을 유지한다.


### RB 트리 삽입
* 보통 '레드는 경로상에 연달아 올 수 없다'가 문제

#### 삽입에서 자주 나오는 문제
```java
1. 삼촌 노드가 빨간색인 경우
        : 부모 노드와 삼촌 노드를 검정색으로 칠하고, 조부노드를 빨간색으로 칠한다.

            // 조부 노드를 빨간색으로 칠했을때 그 위로 다시 규칙 위반이 있나 봐야함


2. 삼촌은 검정색이며 새로 삽입한 노드가 부모노드의 오른쪽 자식인 경우
        : 부모 노드를 기준으로 왼쪽으로 회전시켜 문제를 3번 케이스로 변경한다.

 
3. 삼촌은 검정색이며 새로 삽입한 노드가 부모노드의 왼쪽 자식인 경우
        : 부모 노드를 검정색, 조부 노드를 빨간색으로 칠한다.

          그 다음 조부 노드를 기준으로 오른쪽으로 회전 시킨다.
```

#### RB-TRee 삭제
```java
∝ 노드를 삭제하고 무너진 규칙을 복원하는 것에 초점을 둔다.

        // 삭제또한 기본적으로 BST의 삭제에 기반한다.

 

∝ 삭제된 노드가 빨간색일 경우 추가 작업이 필요 없다.

        // 빨간색 노드가 삭제되는 걸로는 규칙을 벗어날 경우가 없음

 

∝ 하지만 검정색 노드를 삭제하는 경우 문제가 된다.


1. CASE Default 

        : 삭제가 일어나면 무조건 실행되는 케이스

          삭제된 노드가 검정색인 경우, 그 자리를 대체하는 노드를 검정색으로 칠한다.


하지만 그 자리를 대체하는 노드가 이미 검정색이라면 문제가 된다.

원래 검정색 노드를 다시 검정색으로 칠하는 경우로 이런 노드를 이중 흑색 노드 라고 부른다.

 

이중 흑색 노드는 해당 케이스 별로 해결하는 방식이 다르다.

 

 

// 지금 부터 알아 볼 경우는 이중 흑색 노드가 부모의 왼쪽 자식일 경우임

// 반대 경우인 오른쪽 자식일 경우또한 고려해야 한다.



이중 흑색 노드 처리

1. CASE Change

        : 이중 흑색 노드의 삼촌이 빨간색인 경우 삼촌을 검은색, 부모를 빨간색으로 칠하고

          부모 노드를 기준으로 좌회전 한다.

             // 여전히 이중 흑색 노드가 있다면 다음 CASE로 넘어간다.


2. CASE A

        : 이중 흑색 노드의 삼촌이 검정색이고 삼촌의 양쪽 자식 모두 검정색인 경우

          삼촌 노드만 빨간색으로 만들고, 이중 흑색 노드의 검정색 1개를 부모에게 전달한다.

 

            // 하지만 부모가 이미 검정색이였다면 부모가 이중 흑색 노드가 된다.

            // 이중 흑색 노드가 있다면 부모에게 검정색을 전달하면서 ROOT도달하고 끝낸다.

 
3. CASE B

        : 이중 흑색 노드의 삼촌이 검정색이고 삼촌의 왼쪽 자식이 빨간색,

          오른쪽 자식이 검정색인 경우 삼촌 노드를 빨간색, 삼촌 노드 왼쪽 자식을

          검정색으로 칠한 후 삼촌 노드 기준으로 우회전 한다.


4. CASE C

        : 이중 흑색 노드의 삼촌이 검정색이고 삼촌의 오른쪽 자식이 빨간색인 경우

          부모 노드의 색을 삼촌에게 넘기고 부모 노드와 삼촌 노드의 오른쪽 자식을

          검은색으로 칠한 후 부모 노드 기준으로 좌회전 한다.
```

# Non-binary tree

## B트리
```java
이진 트리가 자식 노드가 최대 2개인 노드를 말하는 것이라면 B-Tree는 자식 노드의 개수가 2개 이상인 트리를 말합니다. 
또한 노드내의 데이터가 1개 이상일수가 있습니다. 노드내 최대 데이터 수가 2개라면 2차 B-Tree, 3개라면 
3차 B-Tree 라고 말합니다. ‘1, 2, 3, … M차 B-Tree 라고 합니다.
차수가 홀수인지 짝수인지에 따라 알고리즘이 많이 달라집니다.

B-Tree 성립 조건에대해서 자세히 알아보겠습니다.

노드의 데이터수가 n개라면 자식 노드의 개수는 n+1 개입니다.
```

## B 트리
*  B-트리는 자식 수에 대한 
일반화를 하면서 하나의 레벨에 더 많이 저장되는 것 뿐만 아니라 트리의 균형을 자동으로 맞추는 로직까지 갖추었다. 
  * 대량의 데이터를 처리해야 하는 검색 구조인 경우 하나의 노드에 많은 데이터를 가질 수 있다는 점은 큰 장점이다.
* non-binary tree: 하나의 노드에 자식이 여러개가 가능
* B-트리는 스스로 균형을 맞추는 트리이다 .
```java
B-트리란 하나의 노드에 여러자료가 배치되는 트리 구조이다. 한 노드에 M개의 자료가 배치되면 M차 B-Tree라고 한다.

5차 B-트리 인 경우 자식노드가 최대 5개인 것을 의미한다. B-트리는 스스로 균형을 맞추는 트리이다 .
그래서 최악의 경우에도 O(logN)의 검색 성능을 보인다. 또한 B-트리는 하나의 노드에 많은 수의 데이터를 저장할 수 있다. 


규칙
1. 한 노드에 여러개의 데이터를 가지고 있는데 최개 개수(MAX-degree)를 정해두어야 함
  Max Degree 개수와 노드의 개수가 같아지면 분화한다
노드의 자료수가 N이라면 자식의 수는 N+1이어야 한다. 
각 노드의 자료는 정렬된 상태여야 한다.
노드의 자료Dk의 왼쪽 서브트리는 Dk보다 작은 값들이고 오른쪽 서브트리는 Dk보다 큰 값들이어야 한다.
2. 한 노드가 여러개의 자식 노드를 가질 수 있다.
Root 노드는 적어도 2개이상의 자식을 가져야 한다.
자식노드의 개수는 부모 노드의 개수 +1개
Root 노드를 제외한 모든 노드는 적어도 M/2개-1 이상의 자료를 가지고 있어야 한다.
3. 리프 노드는 모두 같은 레벨에 있어야 한다.
외부 노드로 가는 경로의 길이는 모두 같다. - 외부노드는 모두 같은 레벨에 있다
입력자료는 중복될 수 없다. 


출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B+ 트리
```java
B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다. (Wedekind, 1974) B-트리에서는 특정 key 값이 하나의 노드에서만 존재할 수 있지만 B+ 트리에서는 leaf 노드와 leaf의 부모 노드에서 공존할 수 있다. B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할만 하기 때문이다. (index set 이라 불린다) 그리고 leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다. 고로 B+ 트리는 (기존의 B-트리 + 데이터의 연결 리스트)로 구현된 색인구조라고 할 수 있다. 

1. 정리 : B-트리의 변형 구조로 index 부분과 leaf 노드로 구성된 순차 data 부분으로 이루어진다. Index 부분의 key 값은 leaf에 있는 key 값을 직접 찾아 가는데 사용하고 모든 key 값은 leaf 노드에 나열된다. 즉, index 부분의 key 값도 leaf 노드에 다시 한 번 나열된다. Leaf 노드는 순차적으로 linked list를 구성하고 있어서 순차적 처리가 가능하다.

2. 삽입
1) B-tree와 거의 동일하게 이루어진다.
2) 노드의 분열이 일어나면 중간 key 값이 부모 노드로 올라갈 뿐 아니라 새로 분열된 노드에도 포함되어야 한다.
3) 새 노드는 leaf 노드끼리의 linked list에도 삽입되어야 한다.

3. 삭제
1) 재배치와 합병이 필요하지 않을 때는 leaf 노드에서만 삭제된다.
2) Index 부분은 다른 key 값을 찾는데 사용될 수 있기 때문에 leaf node의 값이 삭제되어도 삭제하지 않는다.
3) 재배치할 경우 index 부분의 node의 key 값은 변하지만 tree 구조는 변하지 않는다.
4) 합병을 할 경우 index 부분에서도 key 값을 삭제한다.



http://egloos.zum.com/sweeper/v/899699



예시)

b트리와 달리 트리의 최하위 레벨의 리프노드에만 데이터 들이 정렬되어있음. 
나머지 노드들은 키값만 가지고 있다.
파일시스템 같은 블록기반 스토리지에서 저장데이터의 효율적인 검색에 유용함

58
1234/567/89 10


이와같이 인덱스에 사용되던 키값마저 리프노드에 중복되어있다.
또한 1->2->3->4->5->.,...->10순으로 각 리프로드가 링크되어 linked list를 구성하고 있기 때문에
데이터의 순차적 처리가 가능하다.


출처: http://lssang.tistory.com/entry/알고리즘-B트리-B트리 [쩡자의 개발노트]
출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B* 트리
```java
1. 정의
B-Tree의 각 노드는 디스크의 블록과 같기 때문에 노드 하나를 접근하는 것은 디스크를 한번 더 접근하는 것을 의미한다. 그러므로 보다 적은 수의 노드를 생성하는 것이 색인구조의 성능을 높일 수 있다. 생성되는 노드의 수를 줄이기 위해 B-Tree의 변형으로 B* 트리가 나오게 되었다.

B-Tree는 특성을 유지하기 위해 삽입과정에서의 분열과 삭제 과정에서의 합병 등의 보조 연산이 필요하다. B* Tree에서는 이런 보조 연산을 가급적 지연시켜 회수를 감소시키려 헸다.

2. 조건
1) Root 노드를 제외한 모든 노드는 2/3 이상 채워져야 된다. (B-Tree는 1/2 이상)
2) B* Tree는 노드의 분열을 줄여서 보조 연산을 줄이려고 한다. 따라서 노드가 가득차면 분열하는 대신 이웃한 형제 노드로 재배치를 한다.
---> 재배치 작업은 부모노드+해당노드+형제노드의 key들을 나열한 뒤, 중간 key 값을 부모 노드로 보내고 남은 key들을 반분하여 해당노드와 형제노드에 배치하는 행동이다. 중요한 것으므로 이해 필요;
3) 한 노드가 가득차고 인접 노드까지 모두 가득찰 때까지 분열을 지연한다.

이러한 노력으로 B* 트리의 평균 저장공간 사용률은 81%에 달한다. (Leung, 1984)

3. 삽입
1) B-Tree에서와 같은 방법으로 삽입을 한다.
2) 노드가 가득차면 이웃한 형제 노드를 살펴 빈 자리가 있으면 정렬하여 재배치한다.
3) 인접 노드에도 key 넘침 현상(overflow)이 일어나서 더 이상 빈 자리가 없을 경우, 가득찬 두 노드를 분열하여 2/3 정도 채워진 3개의 노드로 만든다. 이 과정에서 재배치 동작은 2번 발생한다. (가득찬 두 노드를 분열하여 3개의 노드로 만들 때 첫번째 노드와 두번째 노드간의 재배치 그리고 두번째 노드와 세번째 노드간의 재배치)

4. 삭제
B-Tree와 똑같이 삭제 후 key 값의 개수가 모자라면 이웃한 형제 노드로부터 재배치하고 재배치도 할 수 없는 경우 합병한다. 합병할 때는 세 개의 노드를 두 개의 노드로 합병한다.

출처: https://wangin9.tistory.com/entry/B-tree-B-tree [잉구블로그]
```

### B-tree 와 B+tree
 * B-tree와 각 노드에 데이터가 저장이 되지만 B+tree의 경우엔 인덱스노드와 리프노드가 분리되어서 존재한다. 
 * 그리고, 리프노드는 서로 연결되어 있어서 임의접근과 순차접근모드 성능이 우수하다. 

#### 공통점
1. 모든 leaf의 depth가 같다
2. 각 node에는 k/2 ~ k 개의 item이 들어있어야 한다.
3. search가 비슷하다.
4. add시 overflow가 발생하면 split 한다
5. delete 시 underflow가 발생하면 redistribution하거나 merge 한다.

#### 차이점
1. B-tree의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다. 여기서 data는 disk block으로의 포인터가 될 수 있다.
  B+tree는 각 node에서는 key만 들어가야 한다. 그러므로 B+tree에서는 data는 오직 leaf에만 존재한다.
2. B+tree는 B-tree와는 달리 add, delete가 leaf에서만 이루어진다.
3. B+ tree는 leaf node 끼리 linked list로 연결되어 있다.

#### B+tree의 장점
- 블럭사이즈(노드사이즈) 를 더 많이 이용할수잇다 ( 키값에 대한 harddisk 엑세스 주소가 없기 때문에 )
- leaf node 끼리 linked list로 연결되어있어서 시퀀셜한 레인지 탐색에 매우 유리하다 


#### B + Tree 의 단점
- B Tree의 경우 best case에는 루트에서 끝날수 있지만, B+ Tree의 경우 무조껀 leaf노드까지 가야한다.


