# 블로그
* [블로그](https://velog.io/@ollabu3/codestates-immersive-TIL-4)

# 배열
```java
배열은 값 모음을 저장할 수있는 기본 데이터 구조이다(원초적). 메모리 상에서 데이터 공간의 사이즈를 정해주면 그 사이즈를 할당 
할 수 있는 공간을 찾아 할당해준다(Javascript 제외)

Lookup(position) O(1)
Array에 경우 데이터의 위치를 알고 있기 때문에 검색을 하지않고 바로 접근 할 수 있다.

Assign O(1)
데이터를 덮어 씌울 때 또한 데이터의 위치를 알고 있기 때문에 바로 접근이 가능하다

Insert O(n)
: 데이터를 삽입하려 할 때 그 index의 공간을 확보해야 하기 때문에 다른 데이터들의 자리를 하나씩 옮겨야 한다

Remove O(n)
: insert와 마찬가지로 그 index의 데이터를 지우고 공간들을 하나씩 옮겨서 빈공간을 채워야 한다

Find O(n)
: 만약 데이터의 위치를 알고 있지 않다면, array의 index를 하나하나씩 살펴보아야 하며 최악의 경우 데이터의 갯수(n)만큼 찾아야 한다
```

# 연결리스트
```java
Array와 LinkedList의 차이점은 데이터를 저장하는 방식이다. LinkedList는 Array와 같이 데이터가 연속적인 구조가 아니라 랜덤적으로 공간이 배정되어 있다. 
따라서 Linked List는 비 연속 데이터 구조이므로 값이 연속 된 블록이 아닌 메모리 전체에 저장된다. Linked List에 경우 head의 노드값을 꼭 알고 있어야 하며, 
데이터를 제거할 시 제거하려는 노드의 연결을 끊어주고 그 노드는 garbage collector가 처리한다.


Lookup(position) O(n)
Linked List의 경우 random으로 주소를 알고 있기 때문에 바로 접근이 불가능하고 head부터 찾기 시작해야 한다. 따라서 원하는 노드가 나올때까지 찾아야 하며 
최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.

Assign O(n)
: lookup과 마찬가지로 head에서부터 찾기 시작하며 최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.


Insert O(1)
: 만약 노드를 head 또는 tail에 붙인다면 바로 접근이 가능하다. 따라서 본인의 노드를 head 또는 tail에 연결하면 되므로 시간복잡도는 O(1) 이다
만약 중간에 삽입하는 경우 노드를 삽입하고자 할때 이미 삽입해야하는 위치를 알고 있기 때문에 중간에 삽입한 경우 O(n)


Remove
: 내가 지우고자하는 데이터의 위치를 알고있다 가정하였을 때 insert와 마찬가지로 head와 tail은 시간복잡도가 O(1) 이다
그러나 만약 데이터를 중간에 제거하는 경우 내가 삭제하려는 노드의 위치는 알지만 내 전후의 노드들을 서로 연결시켜줘야 할때 연결하려는 
이전 노드를 알지 못하기 때문에 탐색시간이 걸린다(O(n))


Find O(n)
: Lookup과 마찬가지로, 첫 노드인 HEAD에서 출발하여 원하는 데이터가 나올 때까지 순서대로 다음 노드들을 살펴봐야 하기에 데이터의 양이 많아질수록 
작업 시간이 늘어난다. O(n)


doubly Linked List
doubly Linked List는 lookup, assign, insert, find의 경우 Linked List와 같이 O(n)이지만, remove의 경우 데이터의 위치를 모두 알고 있기
때문에 검색없이 바로 제거가 가능하다(O(1))
```

# 정렬
```java
# 버블 정렬  n2 n2 n2
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
 * N * (N + 1) / 2  여서 O(N2) 이지만 가운데 스왑을 계속 해주어야 해서 삽입정렬보다도 실질적으로 안좋은 제일 안좋은 정렬

# 삽입 정렬  n n2 n2
 * 자신보다 앞의 원소가 큰지 작은지 비교를 하여서 자신의 위치를 찾아서 '삽입' 하는 정렬입니다.
 * 앞의 원소를 비교해야 하기 때문에 arr[1]~arr[n] 까지 진행합니다. (두번째 원소인 arr[1] 부터 시작.)
 * 삽입을 하면 데이터가 하나씩 밀려야 하기 때문에 배열이 길어질수록 효율이 떨어집니다.
 
 # 선택정렬  n2 n2 n2
 * 제자리 정렬(in-place sorting) 알고리즘의 하나
 * 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
 * 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
 * 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
 * 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
 * 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
* 1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.


# 퀵 정렬  nlogn, nlogn n2
* 깊이(log n; 바이너리 트리를 쓰는 이유가 n을 log n으로 만들기 위해 사용) * 다른 값과 전부다 비교(n)
	* 퀵 정렬은 분할 정렬과 달리 무조건 반으로 쪼개지는 않기 때문에 한쪽으로 쏠리는 트리 형태가 나올 수 있어 최악의 경우 깊이 n
* 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
* 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.


# 쉘정렬  n n1.5  n2
* 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 ‘간격(gap)’ 이라고 한다.
* 간격의 초깃값: (정렬할 값의 수)/2
* 생성된 부분 리스트의 개수는 gap과 같다.
* 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
* 간격은 홀수로 하는 것이 좋다.
* 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
* 간격 k가 1이 될 때까지 반복한다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html


# 병합정렬  nlogn, nlogn nlogn
* 깊이(log n; 바이너리 트리를 쓰는 이유가 n을 log n으로 만들기 위해 사용) * 다른 값과 전부다 비교(n)
	* 병합 정렬은 퀵소트랑 달리 무조건 반으로 나누기 때문에 한쪽으로 쏠리는 트리 형태가 나오지 
* ‘존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법
* 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
* 분할 정복(divide and conquer) 방법
* 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
* 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
```

# 스택
```java
문제의 종류에 따라 배열보다 스택에 데이터를 저장하는 것이 더 적합한 방법일 수 있다.

배열과 달리 스택은 상수 시간에 i번째 항목에 접근할 수 없다.
하지만 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간에 가능하다. (스택은 끝에서만 추가 삭제가 가능하기 때문이다)
배열처럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.
https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html
```

# 이진검색트리
```java
이진탐색트리란 이진탐색(binary search)과 연결리스트(linked list)를 결합한 자료구조의 일종입니다.
이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.

예컨대 이진탐색의 경우 탐색에 소요되는 계산복잡성은 O(logn)으로 빠르지만 자료 입력, 삭제가 불가능합니다.
연결리스트의 경우 자료 입력, 삭제에 필요한 계산복잡성은 O(1)로 효율적이지만 탐색하는 데에는
O(n)의 계산복잡성이 발생합니다. 두 마리 토끼를 잡아보자는 것이 이진탐색트리의 목적입니다.

이진탐색트리를 순회할 때는 중위순회(inorder) 방식을 씁니다.
(왼쪽 서브트리-노드-오른쪽 서브트리 순으로 순회) 이렇게 하면 이진탐색트리 내에 있는 모든 값들을 
 정렬된 순서대로 읽을 수 있습니다. 다음 예시와 같습니다.

```
