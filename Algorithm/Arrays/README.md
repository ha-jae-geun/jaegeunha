# [노마드 배열](https://youtu.be/NFETSCJON2M)
* C언어 같은 저수준의 언어에서는 인덱스 0은  배열이 첫 칸부터 몇번째 떨어졌는지 묻는 것부터 시작

# 배열기반 리스트과 링크드리스트 비교해 주세요
- 답변
    배열

    배열은 데이터가 메모리공간에서 연속적으로 위치한다. 따라서, 캐시의 공간 지역성 원리에 의해 조회시에 높은 성능을 가질 확률이 높다.

    그러나, 첫 할당시에 전체 메모리공간을 미리 할당해야 하며, 이 때문에 메모리 비효율적인 현상이 발견된다

    링크드리스트

    그때그때 메모리를 동적할당하여 데이터를 추가하므로 필요한 메모리공간만 사용 가능하다.

    그러나 모든 메모리가 인접하게 위치하지 않아 인덱스접근이 순차적이라는 한계가 있다.

    또한 데이터갯수가 많을 경우, 힙메모리에 여기저기 데이터주소가 분산되어 있기 때문에 캐쉬 친화적이지 않다.


### [손코딩] 큐를 링크드리스트 기반, 배열기반으로 구현할때 차이점을 비교해 주세요

- 답변

    링크드리스트:

    Dequeue 는 링크드리스트의 head부분을 제거하는 방식으로 하고,

    Enqueue는 링크드리스트의 마지막 노드만 커서로 가리키는 방식을 통해 마지막에 추가하면 된다. 이 경우 둘다 O(1)이다. 그러나 동적할당을 이용하고 캐쉬지역성이 좋지 않다.

    배열기반:

    Dequeue: 원형큐 방식을 사용하면 O(1)

    Enqueue: 원형큐 방식을 사용하면 O(1)

    배열 용량이 꽉 찼을 경우, 동적배열의 형태로 새로운 배열을 할당하고 front부터 뒤의 데이터부분을 새로운 배열의 끝부분으로 밀어주는 방식을 사용한다.


## 배열 순서 뒤집기
```java
Collections.reverse(Arrays.asList(array));
```

## 스트링 배열을 스트링으로
```java
String.join("", array);
```

## 배열 동적 선언
```java
- public static void main(String[ ] args) {
- int[ ][ ] num = new int[3][ ];
- num[0] = new int[3];
- num[1] = new int[2];
- num[2] = new int[1];
```

## 동적 2차원 배열 값 반환
```java
- String[ ][ ] name = {{"홍길동", "전우치", "임꺽정"}, {"장길산", "일지매"}, {"조세형"}};
- // 배열의 주소값을 반복한다.
- for (String[ ] strings : name) {
- // 배열의 실제값을 반복한다.
- for (String string : strings) {
- System.out.println(string);
- }
- }
```


<hr/>
