# [노마드 배열](https://youtu.be/NFETSCJON2M)
* C언어 같은 저수준의 언어에서는 인덱스 0은  배열이 첫 칸부터 몇번째 떨어졌는지 묻는 것부터 시작

# 배열기반 리스트과 링크드리스트 비교해 주세요
- 답변
    배열

    배열은 데이터가 메모리공간에서 연속적으로 위치한다. 따라서, 캐시의 공간 지역성 원리에 의해 조회시에 높은 성능을 가질 확률이 높다.

    그러나, 첫 할당시에 전체 메모리공간을 미리 할당해야 하며, 이 때문에 메모리 비효율적인 현상이 발견된다

    링크드리스트

    그때그때 메모리를 동적할당하여 데이터를 추가하므로 필요한 메모리공간만 사용 가능하다.

    그러나 모든 메모리가 인접하게 위치하지 않아 인덱스접근이 순차적이라는 한계가 있다.

    또한 데이터갯수가 많을 경우, 힙메모리에 여기저기 데이터주소가 분산되어 있기 때문에 캐쉬 친화적이지 않다.


## 배열 순서 뒤집기
```java
Collections.reverse(Arrays.asList(array));
```

## 스트링 배열을 스트링으로
```java
String.join("", array);
```

## 배열 동적 선언
```java
- public static void main(String[ ] args) {
- int[ ][ ] num = new int[3][ ];
- num[0] = new int[3];
- num[1] = new int[2];
- num[2] = new int[1];
```

## 동적 2차원 배열 값 반환
```java
- String[ ][ ] name = {{"홍길동", "전우치", "임꺽정"}, {"장길산", "일지매"}, {"조세형"}};
- // 배열의 주소값을 반복한다.
- for (String[ ] strings : name) {
- // 배열의 실제값을 반복한다.
- for (String string : strings) {
- System.out.println(string);
- }
- }
```


<hr/>
