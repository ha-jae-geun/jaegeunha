# OCP(Open Close Principle)
## If-else의 문제점
* 변경, 확장이 될 수록 코드가 복잡해진다.
* 코드를 수정하거나 수정할 위치를 찾는데 점점 오래걸린다
* 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다 
* 유지보수가 어려워진다.
    * 변경, 확장이 될수록 코드가 복잡해진다
    * 코드를 수정하거나 수정할 위치를 찾는데 오래걸린다
    * 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다

## 개방폐쇄의 원칙
* 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방되야 하지만 변경에 대해서는 폐쇄되어야 한다
* 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한ㄷ나는 뜻이다.


### 적용 방법
### 상속(is-a)
* 깨지기 쉬운 상위클래스 문제
    * 상속은 하위클래스가 상위클래스의 기능과 밀접하기 때문에 상위가 바뀌면 하위에 영향이 매우 크다

### 컴포지션(has-a)
* 변경할 것과 변하지 않을 것을 명확히 구분
    * 이 두 모듈이 만나는 지점에서 인터페이스를 정의
      * 구현에 의존하기보다는 정의한 인터페이스에 의존하도록 코드를 작성

## OCP 장점
* 기능이 추가, 변경되어도 기존 코드는 변경되지 않는다.

## 전략 패턴
* 기존의 코드 변경 없이 행위를 자유롭게 바꿀 수 있게 해주는 OCP를 준수한 디자인 패턴
* 동일 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 상호 교체가 가능하게 만든다.
* OCp를 준수하기 위해 여태 한 방식이 전략 패턴
* 전략이란 어떤 목적을 달성하기 위해 일을 수행하는 방식
* 비즈니스 규칙, 문제를 해결하는 알고리즘 등
* 디자인 패턴의 꽃이라고 불린다; 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
* 전략을 쉽게 바꿀 수 있도록 해주는 전략 패턴
      * 새로운 기능의 추가가 기존의 코드에 영향을 미치지 못하게 하므로 OCP를 만족

### 전략 패턴의 구조
* 컨텍스트: 갖고 있는 전략 콘크리트에 따라 행동이 달리잔ㄷ.
* 전략: 제공하는 알고리즘에 대한 공동의 연산들을 인터페이스로 정의한다
* 전략 콘크리트 클래스: 실제 알고리즘을 구현한다.

### 전략 패턴 장점
1. 상속을 사용하지 않음
2. if문을 제거할 수 있음
3. 구현의 선택이 가능함

### 전략 패턴 단점
1. 객체수 증가
2. 서로 다른 전략을 대비해야 함

## 템플릿 메소드 패턴
* OCp를 준수하기 위해 여태 한 방식이 템플릿 패턴

### 전략패턴과 상태패턴 공통점
1. 인터페이스를 사용하여 콘크리트 클래스를 캡슐화한다
2. 컨텍스크 를래스는 영향을 받지 않고 변경에 유연한 대응 가능하다(둘다 OCP를 따른다)


### 전략패턴과 상태패턴 차이점
* 어떤 콘크리트 클래스를 사용할지 결정하는 주체
      * 전력패턴: 클라이언트 혹은 사용자에 의해 주입받는다
      * 상태 패턴: 컨텍스트 스스로 상태를 변환할 수 있다.
* 어떤걸 캡슐화 하는가?
      * 전략 패턴: 어떻게 객체가 일을 할지 즉 알고리즘을 캡슐화한다
      * 상태 패턴: 상태에 따른 행동을 캡슐화한다
* 범위
   * 전략 패턴: 하나의 특정 작업만 처리한다
   * 상태 패턴: 컨텍스트 객체가 수행하는 대부분의 메서드에 대한 인터페이스가 제공된다
* 언제 유용한가
      * 전략 패턴: 원하는 알고리즘으로 언제든지 변경하고 싶을 때
      * 상태 패턴: 상태 변화가 잦은 경우

## 전략 패턴과 템플릿 메소드 패턴의 차이
* Composite 방식을 사용한 것이 전략 패턴
* 상속 방식을 사용한 것이 템플릿 메소드 패턴


# 싱글톤 패턴
* 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.
* 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다. (자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함)
* => 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다.
* (인스턴스가 필요 할 때 똑같은 인스턴스를 만들어 내는 것이 아니라, 동일(기존) 인스턴스를 사용하게함)

## 싱글톤 패턴을 쓰는 이유
* 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음
* 또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다.
* DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용.
* (쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체등)
* 안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문...
+ 인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶을 경우 사용.
+ 두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아지는 장점!


## 싱글톤 패턴의 문제점
* 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 "개방-폐쇄 원칙" 을 위배하게 된다. (=객체 지향 설계 원칙에 어긋남)
* 따라서 수정이 어려워지고 테스트하기 어려워진다.
* 또한 멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생할 수 있음
* 개발을 할때 항상 들어온 goto는 쓰면 안돼! 전역 객체는 안 좋은거야! 라는 말 처럼 꼭 필요한 경우아니면 지양해야함. // 적절히 잘 쓰면 아주 좋음, (그게 어렵지)


# 템플릿 메소드 패턴(Template method pattern)
```JAVA
템플릿, 말 그대로 템플릿을 만들어주고 특정 메서드 안을 채워넣기만 하면 되는 디자인 패턴이다.
(PPT 템플릿처럼 제목, 목차, 내용, 질의응답 칸이 있고 거기에 맞게 글을 채워넣듯)

예를 들어 하나의 기능(게임 접속 과정(GameConnectMgr)에 4가지의 절차(보안->인증->권한->접속)를 개발해야 할 때, 
필요에 따라 변경되는 부분을 하위클래스에 위임하도록 하고 템플릿을 보내주는 방법이다.

A->B->C->D, A->B->C'->D, A->B->C''->D 처럼 다양하게 존재할 때 A->B->□->D 라는 템플릿을 만들어주고 하위클래스에서 구현하며, 
기능을 작동시키는 방법이다.

* 특히 C메서드는 절차이므로 외부에 공개되면 안되지만 상속받은 하위클래스에서는 접근가능해야하므로 protected 접근지정자를 사용함을 유의해야한다. + 인터페이스는 public 메서드를 사용해야하므로 추상클래스로 만들어 사용해야 한다.
```

# 스트래티지 패턴(Strategy pattern)
```JAVA
전략패턴! 은 쉽게 말해서 상속받은 객체마다 다를 수 있는 행위부분(메서드)을 캡슐화해 교환하여 사용하는 패턴이다.

예를 들어 'LOL(게임)'에 챔피언이라는 추상클래스가 있고 그것을 상속받는 자식클래스를 만들 때, '
기본공격' 메서드를 상속받아 재정의한다고 가정한다면(누군가는 원거리공격을 하고 누군가는 근접공격, 망치, 단검등...), 잘 사용할 수 있을 것 같다.

하지만 기본공격이 없는 챔피언이 추가되거나 새로운 기능을 가진 챔피언이 추가된다면 해당되지 않는 메서드를 
가지고 있어야 하거나 다시 제거시 번거로움이 있다.

인터페이스로 기능마다 만들려고 한다면 많은 기능이 있을 때 객체마다 다르게 implements해야하는 단점이 있다.

그래서 이것을 해결하기위해서 변경이 많은 부분은 인터페이스로 정의하고 인터페이스 변수를 자식클래스가 
가지고 있는 방법으로 하면 자식클래스에서 인터페이스의 메서드를 부르게만 해놓아서 기능을 위임하는 방법을 사용하는 것이다.
```
# 팩토리 메소드 패턴(Factory Method Pattern)
```JAVA
팩토리 메소드 패턴은 객체 생성을 직접하지 않고 하위 클래스가 어떤 객체 생성을 할지 결정하도록 위임하는 디자인 패턴이다.

Item 인터페이스를 만들고 안에 use() 라는 메서드를 만든다.

Item을 implements하는 아이템, 예를 들면 Hp포션, Mp포션이 있다고 가정하면 Hp포션과 Mp포션을 직접 생성하는 것이
아니라 팩토리 메소드에서 생성하게 하는 것이다.

팩토리 메소드(Creator)라는 추상클래스를 만들고 추상클래스안에 create()라는 추상메서드를 만든다.

이 추상메서드 create()는 일련의 프로세스가 존재할 것이다.(ex. DB에서 만들 Hp포션정보 획득->객체 생성->객체 생성 로그 저장)

그러면 이 것을 받는 extends 하는 하위클래스(PotionCreator)를 만들고 여기서 들어오는 인자(String)로 알맞은 객체를 생성한다. 

```

# 프로토타입 패턴* [자바스크립트 프로토](https://evan-moon.github.io/2019/10/23/js-prototype/)

* ```jAVA프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.
자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.
자바스크립트는 객체를 생성할 때 함수를 사용한다.
```

# 컴포넌트와 모듈의 차이
```java
모듈은 가장 상위에 위치하는 구현의 단위, 컴포넌트는 런타임 개체를 참조하는 단위

모듈은 실질적으로 구현이 된 단위,

컴포넌트는 실제적으로 동작하고 있는 개체

ex. 서버 클라이언트 구조에서 서버 1개와 클라이언트 100대가 있다면

구현된 모듈은 서버1, 클라이언트1 총 2개

동작하는 컴포넌트는 서버1개 클라이언트 100개 총 101개
```
