# 설계
```java
문 14. <보기>는 소프트웨어 개발방법론에 사용되는 분석,
설계 도구에 대한 설명이다. ᄀ~ᄃ에 들어갈 내용을 옳
게 나열한 것은?
◦ 시스템 분석을 위하여 구조적 방법론에서는 ( ᄀ )
다이어그램(diagram)이, 객체지향 방법론에서는
( ᄂ ) 다이어그램이 널리 사용된다.
◦ 시스템 설계를 위하여 구조적 방법론에서는 구조도
(structured chart), 객체지향 방법론에서는 ( ᄃ )
다이어그램 등이 널리 사용된다.
ᄀ ᄂ ᄃ
1 시퀀스(seq uenc e) 데이터 흐 름( da ta flow) 유스케이 스( use case)
2 시퀀스 유스케이스 데이터흐름
3 데이터흐름 시퀀스 유스케이스
4 데이터흐름 유스케이스 시퀀스

답 4
ᄀ 선택지 시퀀스 다이어그램과 데이터 흐름도 중, 구조적 방법론에
서 분석 단계에서는 데이터 흐름도(자료 흐름도)이다.
시퀀스 다이어그램은 객체지향 방법론 분석 및 설계 단계에서 사
용한다.
ᄂ 데이터 흐름도는 구조적 분석 도구이므로 ᄂ에 들어갈 수 없다.
유스케이스 다이어그램은 요구 파악 단계에서 사용하고, 시퀀스
다이어그램은 분석 및 설계 단계에서 사용한다.
요구 파악 단계는 분석 단계에 포함시킬 수 있으므로 유스케이스
와 시퀀스 모두 답이 가능하다.
ᄃ 유스케이스 다이어그램은 분석 단계에서만 사용하고, 시퀀스 다이
어그램은 분석·설계 단계 모두에서 사용한다.
따라서 답이 될 수 있는 건 시퀀스 다이어그램뿐이다.


14. 모듈의 응집도에 대한 설명으로 <보기>에서 옳은 것만
을 모두 고른 것은?
ᄀ. 모듈 내 한 구성 요소의 출력이 다른 구성 요소의
입력이 되는 경우는 순차적 응집도(sequential
cohesion)에 해당한다.
ᄂ. 모듈 내 구성 요소들이 서로 다른 기능을 같은 시
간대에 함께 실행하는 경우는 우연적 응집도
(coincidental cohesion)에 해당한다.
ᄃ. 모듈이 여러 가지 기능을 수행하며 모듈 내 구성
요소들이 같은 입력 자료를 이용하거나 동일 출력
데이터를 만들어내는 경우는 통신적 응집도
(communicational cohesion)에 해당한다.
1 ᄀ 2 ᄂ
3 ᄀ, ᄃ 4 ᄂ, ᄃ

답 3
ᄃ. 교환적 응집도 또는 통신적 응집도라고 한다.
<오답 체크> ᄂ. 특정 시간대에 같이 처리해야 하는 기능들을 묶어놓
은 것을 시간적 응집도라고 한다.

응집도순서(강함 -> 약함)
1. 기능적 : 모듈 내 모든 요소들이 단일 기능을 수행
2. 순차적 : 모듈 내의 한 요소의 출력 자료가 다음 요소의 입력 자료로 사용
3. 교환적 : 모듈 내의 요소들이 동일한 입출력 자료로 서로 다른 기능을 수행
4. 절차적 : 모듈 수행 요소들이 반드시 특정 순서대로 수행
5. 시작적(일시적) : 특정 시간에 실행되는 기능들을 모아 작성된 모듈
6. 논리적 : 논리적으로 유사한 기능을 수행 하지만 서로의 관계는 밀접하지 않음
7. 우연적 : 모듈 내 요소들이 뚜렷한 관계가 없이 존재


◈ 결합도(coupling) 낮은(좋은) 순서대로  @자습제외공내
▶ 자료 결합도(Data Coupling): 모듈간의 인터페이스가 자료 요소
로만 구성된 경우. 파라미터를 통해서만 모듈간의 상호 작용이 일
어나는 경우. Call by value
▶ 스탬프 결합도(Stamp Coupling): 모듈간의 인터페이스로 배열이
나 오브젝트, 스트럭쳐등이 전달되는 경우
▶ 제어 결합도(Control Coupling): 단순히 처리를 해야 할 대상인
값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소
(DCD, Flag등)이 전달되는 경우.
▶ 외부 결합도(External Coupling): 어떤 모듈에서 반환한 값을 다
른 모듈에서 참조해서 사용하는 경우
▶ 공통 결합도(Common Coupling): 파라미터가 아닌 모듈 밖에 선
언되어 있는 전역 변수를 참조하고 전역변수를 갱신하는 식으로
상호작용하는 경우
▶ 내용 결합도(Content Coupling): 다른 모듈 내부에 있는 변수나
기능을 다른 모듈에서 사용 하는 경우


문 17. 소프트웨어 시스템은 기능 관점, 동적 관점 및 정보 관점으로
분류할 수 있다. 동적 관점에서 시스템을 기술할 때 사용할 수
있는 도구로 옳지 않은 것은? 2
1 사건 추적도(Event Trace Diagram)
2 자료 흐름도(Data Flow Diagram)
3 상태 변화도(State Transition Diagram)
4 페트리넷(Petri Net)


[해설]
1. 기능관점(Function Space)
- 기능 모델은 시스템이 어떠한 기능을 수행하는가의 관점에서 시스템을
기술한다.
- 주어진 입력에 대하여 어떤 결과가 나오는가를 보여주는 관점이여 연
산과 제약조건을 묘사한다.
- 기능 모델의 일반적인 표현 방법은 자료흐름도에 의하여 도식적으로
나타난다.
2. 동적 관점(Dynamic Space)
- 시간의 변화에 따른 시스템의 동작과 제어에 초점을 맞추어 시스템의
상태와 상태를 변하게 하는 원인을 묘사하는 것이다.
- 상태변화도(STD), 사건추적도(ETD), 페트리네트 : 동적관점을 기술할
때, 외부와의 상호작용이 많은 실시간 시스템들은 동적 관점에서 시스템
이 기술되어야 할 때 쓰이는 도구이다.
3. 정보 관점(Information Space)
- 시스템에 필요한 정보를 보여줌으로써 시스템의 정적인 정보구조를 포
착하는데 사용한다.
- 정보 모델은 특히 시스템의 데이터베이스를 분석하는 데 많이 사용되
며 ER 모델이 대표적인 도구이다.
```

# 모듈
* 모듈(module)은 역사적으로 프로그래밍이라는 관점에서는 기본적으로 본체에 대한 독립된 하위 단위라는 필연적인 개념의 큰 틀을 따르고 있지만 본체와 모듈 간에 가지고 있었던 문제들을 해결해 나가는 과정에서 발전하였다.
* 프로그램의 꾸러미

## 모듈의 독립성
* 모듈의 독립성을 판단하는 두 가지 지표이다. 결합도는 모듈과 모듈간의 상호 의존 정도, 응집도는 모듈 내부의 기능적인 집중 정도라고 할 수 있다.
* 좋은 모듈화는 용도에 맞게 잘 구분된 기능을 가신 모듈들로 세분화 하는 것이다. 즉, 개별 모듈은 독립적으로 자신에게 주어진 기능만을 수행하고 명확한 결과값을 내 놓아야 하고 다른 모듈에 의존성이 높아선 안된다.



## 응집도는 높이고 결합도는 낮춰라. High Cohesion, Loose Coupling

### 응집도
* 하나의 클래스가 하나의 기능을 온전히 순도 높게 담당하는 정도

### 결합도
* 클래스간의 서로 다른 책임들이 얽혀 있어서 상호의존도가 높은 정도

### Role: 메소드


# [패턴의 종류](https://jwprogramming.tistory.com/68)
```java
1. 생성 패턴: 생성패턴(Creation Pattern) : 객체의 생성과정에 관여하는 패턴입니다.
* 추상 팩토리, 빌더, 팩토리 메소드, 프로토타입, 싱글턴

2. 구조 패턴: 클래스나 객체의 합성에 관한 패턴입니다.
클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.

* 어댑터, 브리지, 컴포지트, 데코레이터, 퍼사드, 플라이웨이트, 프록시


3. 동작 패턴: 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의하는 패턴입니다.
한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.
하나의 객체들이 모든 것을 처리하는 것이 아니라 관련된 객체들이 같이 처리하는 패턴


* 책임 연쇄, 커맨드, 인터프리터, 반복자, 중재자, 메멘토, 옵서버, 상태, 전략, 템플릿 메소드, 비지터
```

# Composition Pattern
## 상속의 장점
* 코드 재사용성
* 다형성을 지킬 수 있다.

## 상속의 단점
* 유연성이 떨어진다.
* 오버라이딩의 문제
* 캡슐화, LSP

## 상속을 써야할 때
* Is-a 관계가 명확할 때
* 본인의 코드일 경우
* 상속을 위해 설계된 경우

## 컴포지션 장점
* 유연성 제공
* 다중상속을 해소
* 불필요한 메소드 노출 X

# OCP(Open Close Principle)
## If-else의 문제점
* 변경, 확장이 될 수록 코드가 복잡해진다.
* 코드를 수정하거나 수정할 위치를 찾는데 점점 오래걸린다
* 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다 
* 유지보수가 어려워진다.
    * 변경, 확장이 될수록 코드가 복잡해진다
    * 코드를 수정하거나 수정할 위치를 찾는데 오래걸린다
    * 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다

## 개방폐쇄의 원칙
* 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해서는 개방되야 하지만 변경에 대해서는 폐쇄되어야 한다
* 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계해야 한ㄷ나는 뜻이다.


### 적용 방법
### 상속(is-a)
* 깨지기 쉬운 상위클래스 문제
    * 상속은 하위클래스가 상위클래스의 기능과 밀접하기 때문에 상위가 바뀌면 하위에 영향이 매우 크다

### 컴포지션(has-a)
* 변경할 것과 변하지 않을 것을 명확히 구분
    * 이 두 모듈이 만나는 지점에서 인터페이스를 정의
      * 구현에 의존하기보다는 정의한 인터페이스에 의존하도록 코드를 작성

## OCP 장점
* 기능이 추가, 변경되어도 기존 코드는 변경되지 않는다.

## 전략 패턴
* 기존의 코드 변경 없이 행위를 자유롭게 바꿀 수 있게 해주는 OCP를 준수한 디자인 패턴
* 동일 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 상호 교체가 가능하게 만든다.
* OCp를 준수하기 위해 여태 한 방식이 전략 패턴
* 전략이란 어떤 목적을 달성하기 위해 일을 수행하는 방식
* 비즈니스 규칙, 문제를 해결하는 알고리즘 등
* 디자인 패턴의 꽃이라고 불린다; 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
* 전략을 쉽게 바꿀 수 있도록 해주는 전략 패턴
      * 새로운 기능의 추가가 기존의 코드에 영향을 미치지 못하게 하므로 OCP를 만족

### 전략 패턴의 구조
* 컨텍스트: 갖고 있는 전략 콘크리트에 따라 행동이 달리잔ㄷ.
* 전략: 제공하는 알고리즘에 대한 공동의 연산들을 인터페이스로 정의한다
* 전략 콘크리트 클래스: 실제 알고리즘을 구현한다.

### 전략 패턴 장점
1. 상속을 사용하지 않음
2. if문을 제거할 수 있음
3. 구현의 선택이 가능함

### 전략 패턴 단점
1. 객체수 증가
2. 서로 다른 전략을 대비해야 함

## 템플릿 메소드 패턴
* OCp를 준수하기 위해 여태 한 방식이 템플릿 패턴

### 전략패턴과 상태패턴 공통점
1. 인터페이스를 사용하여 콘크리트 클래스를 캡슐화한다
2. 컨텍스크 를래스는 영향을 받지 않고 변경에 유연한 대응 가능하다(둘다 OCP를 따른다)


### 전략패턴과 상태패턴 차이점
* 어떤 콘크리트 클래스를 사용할지 결정하는 주체
      * 전력패턴: 클라이언트 혹은 사용자에 의해 주입받는다
      * 상태 패턴: 컨텍스트 스스로 상태를 변환할 수 있다.
* 어떤걸 캡슐화 하는가?
      * 전략 패턴: 어떻게 객체가 일을 할지 즉 알고리즘을 캡슐화한다
      * 상태 패턴: 상태에 따른 행동을 캡슐화한다
* 범위
   * 전략 패턴: 하나의 특정 작업만 처리한다
   * 상태 패턴: 컨텍스트 객체가 수행하는 대부분의 메서드에 대한 인터페이스가 제공된다
* 언제 유용한가
      * 전략 패턴: 원하는 알고리즘으로 언제든지 변경하고 싶을 때
      * 상태 패턴: 상태 변화가 잦은 경우

## 전략 패턴과 템플릿 메소드 패턴의 차이
* Composite 방식을 사용한 것이 전략 패턴
* 상속 방식을 사용한 것이 템플릿 메소드 패턴




# 템플릿 메소드 패턴(Template method pattern)
```JAVA
템플릿, 말 그대로 템플릿을 만들어주고 특정 메서드 안을 채워넣기만 하면 되는 디자인 패턴이다.
(PPT 템플릿처럼 제목, 목차, 내용, 질의응답 칸이 있고 거기에 맞게 글을 채워넣듯)

예를 들어 하나의 기능(게임 접속 과정(GameConnectMgr)에 4가지의 절차(보안->인증->권한->접속)를 개발해야 할 때, 
필요에 따라 변경되는 부분을 하위클래스에 위임하도록 하고 템플릿을 보내주는 방법이다.

A->B->C->D, A->B->C'->D, A->B->C''->D 처럼 다양하게 존재할 때 A->B->□->D 라는 템플릿을 만들어주고 하위클래스에서 구현하며, 
기능을 작동시키는 방법이다.

* 특히 C메서드는 절차이므로 외부에 공개되면 안되지만 상속받은 하위클래스에서는 접근가능해야하므로 protected 접근지정자를 사용함을 유의해야한다. + 인터페이스는 public 메서드를 사용해야하므로 추상클래스로 만들어 사용해야 한다.
```

# 스트래티지 패턴(Strategy pattern)
```JAVA
전략패턴! 은 쉽게 말해서 상속받은 객체마다 다를 수 있는 행위부분(메서드)을 캡슐화해 교환하여 사용하는 패턴이다.

예를 들어 'LOL(게임)'에 챔피언이라는 추상클래스가 있고 그것을 상속받는 자식클래스를 만들 때, '
기본공격' 메서드를 상속받아 재정의한다고 가정한다면(누군가는 원거리공격을 하고 누군가는 근접공격, 망치, 단검등...), 잘 사용할 수 있을 것 같다.

하지만 기본공격이 없는 챔피언이 추가되거나 새로운 기능을 가진 챔피언이 추가된다면 해당되지 않는 메서드를 
가지고 있어야 하거나 다시 제거시 번거로움이 있다.

인터페이스로 기능마다 만들려고 한다면 많은 기능이 있을 때 객체마다 다르게 implements해야하는 단점이 있다.

그래서 이것을 해결하기위해서 변경이 많은 부분은 인터페이스로 정의하고 인터페이스 변수를 자식클래스가 
가지고 있는 방법으로 하면 자식클래스에서 인터페이스의 메서드를 부르게만 해놓아서 기능을 위임하는 방법을 사용하는 것이다.
```


# 프로토타입 패턴* [자바스크립트 프로토](https://evan-moon.github.io/2019/10/23/js-prototype/)

* ```jAVA프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.
자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.
자바스크립트는 객체를 생성할 때 함수를 사용한다.
```

# 컴포넌트와 모듈의 차이
```java
모듈은 가장 상위에 위치하는 구현의 단위, 컴포넌트는 런타임 개체를 참조하는 단위

모듈은 실질적으로 구현이 된 단위,

컴포넌트는 실제적으로 동작하고 있는 개체

ex. 서버 클라이언트 구조에서 서버 1개와 클라이언트 100대가 있다면

구현된 모듈은 서버1, 클라이언트1 총 2개

동작하는 컴포넌트는 서버1개 클라이언트 100개 총 101개
```
