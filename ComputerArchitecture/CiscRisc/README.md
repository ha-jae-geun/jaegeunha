# 플랫폼
* C는 컴파일 플랫폼과 타겟 플랫폼이 다를 경우, 프로그램이 동작하지 않는다.
  * 플랫폼: 운영체제 + CPU 아키텍처


### Cisc
* x86 아키텍처가 리틀 엔디언을 쓰기 때문에, 오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언을 쓰며 이를 ‘인텔 포맷’이라 한다. 거꾸로 네트워크에서는 주소를 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다. 이의 영향으로 많은 프로토콜과 몇몇 파일 포맷이 빅 엔디언을 사용하고 있다. 모토로라 프로세서들은 일반적으로 빅 엔디언을 사용하며, ARM 프로세서들은 성능 향상을 위해 빅 엔디언과 리틀 엔디언을 선택할 수 있도록 되어 있다.
* 명령어가 복잡하기 때문에 명령어를 해석하는 데 시간이 오래 걸리며, 명령어 해석에 필요한 회로도 복잡하다.
* CISC란 소프트웨어 특히, 컴파일러 작성을 쉽게 하기 위해 하드웨어화할 수 있는 것은 가능한 모두 하드웨어에게 맡긴다는 원칙 아래 설계된 컴퓨터이다. 
* 뒤에서부터 스택에 PUSH
* 계산연산에서 빅 엔디안보다 속도가 빠름

### Risc
* RISC의 특징을 CISC와 비교하여 알아보면 다음과 같다. 첫째, 명령의 대부분은 1머신 사이클에 실행되고, 명령길이는 고정이며, 명령세트는 단순한 것으로 구성되어 있는데, 가령 메모리에 대한 액세스는 Load/Store 명령으로 한정되어 있다. 둘째, 어드레싱 모드가 적으며, 마이크로 프로그램에 의한 제어를 줄이고, 와이어드 로직을 많이 이용하고 있다. 반면에 레지스터수가 많으며 마이크로 프로그램을 저장하는 칩의 공간에 레지스터를 배치한다. 셋째, 어셈블러 코드를 읽기 어려울 뿐 아니라 파이프라인을 효과적으로 사용하기 위해서 일부 어셈블러 코드를 시계열로 나열하지 않은 부분이 존재하여 컴파일러의 최적화가 필요하다. 최적화를 하지 않으면 파이프라인을 유효하게 이용할 수 없고, RISC을 사용하는 의미가 없어진다.
* RISC는 CISC 형식의 CPU내 ROM에 소프트웨어적으로 적재된 내부 명령어들을 하드웨어적으로 구성해 제어기가 제거된 부분에 프로세서 레지스터 뱅크와 캐시를 둡니다. 이렇게 함으로써 CPU가 상대적으로 느린 메인 메모리에 접근하는 횟수를 줄여 시스템 수행속도를 향상시킬 수 있습니다.  
* 반면 RISC는 실행 속도를 높히기 위해 가능한 한 복잡한 처리는 소프트웨어에게 맡기는 방법을 택한 컴퓨터이다.
* Unix 의 RISC계열의 프로세서가 사용하는 바이트 오더링
* 네트워크에서 사용하는 바이트 오더링
* 앞에서부터 스택에 PUSH
* 비교연산에서 리틀 엔디안보다 속도가 빠름
* Intel 계열의 프로세서가 사용하는 바이트 오더링
* RISC 프로세서의 경우 CISC 프로세서보다 파이프라인 효율이 좋다. RISC는 명령어가 한 클록에 처리되므로, 한 명령어를 오래 처리해서 다음 명령어의 처리가 늦어지지 않기 때문이다. 또한, 메모리에 접근하는 경우, 매우 오랜 처리시간이 걸리는데, RISC는 LOAD나 STORE 명령어만으로 메모리에 접근하므로 비효율적인 접근이 CISC보다 적기 때문이다.
* 최대의 단점은 코드밀도가 감소하여 같은 내용을 처리하는 데 더 많은 코드 용량이 필요하게 되었다는 점이다. 그 원인은 또 다음과 같이 분류할 수 있다.
  + 항상 16bit 혹은 32bit를 차지하는 고정 길이 명령어는 상황에 따라 8~32bit를 오가는 CISC의 가변 길이 명령어에 비해 코드밀도 면에서 원천적으로 불리하다.
  + 메모리를 대상으로 하는 연산 명령어의 경우 CISC에서는 1개 명령어로 표현 가능한데 RISC에서는 load-execute-store로 3개의 명령어가 필요하다.
  + 마이크로코드로 한 줄로 구현된 CISC명령어를 몇 개, 혹은 수십개의 RISC명령어로 변환해야 한다.

### Cisc, Risc 차이점
* Complex
  + CISC의 단점이자 RISC의 장점은 CISC의 경우 하드웨어의 회로가 복잡해져서 RISC에 비해 가격이 비싸지고 발열이 많고 전력소모가 많게 됩니다.
  +  RISC 명령어가 단순히 명령어 수를 줄인 것이 아니라 명령어 해석기에서의 마이크로코드의 의존도를 제거하고 관련 로직을 단순화하여 성능을 올리는 방향으로 발전했다는 것을 상기하라.
* Instruction
  + RISC: CPI(Clock Per Instruction)을 1 이하로 줄이는 것임, 동급의 CISC에 비해 더 높은 clock frequency를 실현하는 것임
  + RISC 프로세서의 경우 CISC 프로세서보다 파이프라인 효율이 좋다. RISC는 명령어가 한 클록에 처리되므로, 한 명령어를 오래 처리해서 다음 명령어의 처리가 늦어지지 않기 때문이다. 또한, 메모리에 접근하는 경우
  + CISC에서는 여러 clock을 차지하는 복잡한 연산을 하는 명령어들이 종종 있었다. 심지어 for 루프를 실행하는 명령어가 존재했을 정도였다. 이는 과거에 컴파일러의 성능이 부족했기 때문에, 컴파일러를 사용한 후에도 최적화를 하기 위해서 기계어 코드를 수정하는 등 프로그래머가 기계어를 직접 다루는 경우가 많았기 때문이다. 
* Set
  + CPU는 메모리 접근을 피하기 위해 인자나 지역변수를 저장하는데에도 레지스터를 사용한다.
  + 즉, CISC 각각의 명령어는 머신코드는 길지만 전체 프로그램 사이즈는 RISC보다 작습니다. 따라서 코드를 수행할 때 RISC가 메모리를 더 많이 참조해야 하므로.... [CISC가 RISC보다 빠른 요인이 됩니다.] CISC는 복잡한 하드웨어를 가지게 되므로 보통 hard wired방식 보다는 microprogram 방식을 사용하게 됩니다. RISC는 hard wired 방식을 사용할 수 있습니다. [RISC가 CISC보다 빠른 요인이 됩니다.]
  CISC는 레지스터의 양이 많을 필요가 없고 RISC는 레지스터의 양이 많아야 하므로.... (예>함수에 파라미터를 메모리에 저장하는 경우와 레지스터에 저장하는 경우의 차이)
CISC가 메모리의 access가 많아지게 됩니다. [RISC가 CISC보다 빠른 요인이 됩니다.] RISC머신이 파이프라인구현이 용이하다라고 합니다..
* Stack
  + CISC: 일반적으로 하드웨어 스택이 내장되어 있어서 서브루틴 리턴 주소나 인자, 지역변수, 기타 임시 값을 저장하는데 사용한다. Call, ret, push, pop 같은 기계어 명령어를 사용할 경우 stack의 데이터는 자동적으로 관리된다.
  + RISC; Stack 관련 명령어가 존재하지 않음; Return address 나 기타 stack 자료 구조는 SW 적으로 처리해주어야 한다.; Power PC 의 경우, 함수의 인자를 전달하기 위해 8개의 레지스터를 따로 준비하고 있다. 인자값을 메모리에 접근하는 stack operation에 비해 register에 load 한다. 지역변수를 저장하기 위해 stack을 사용할 필요가 없다. 대부분의 짧은 프로시저나 함수를 호출할 때 리턴주소를 SW stack에 저장하기 위해 stack을 사용할 필요가 없다.

## 파이프라인
* 파이프라인(instruction pipeline)은 명령어를 읽어 순차적으로 실행하는 프로세서에 적용되는 기술로, 한 번에 하나의 명령어만 실행하는 것이 아니라 하나의 명령어가 실행되는 도중에 다른 명령어 실행을 시작하는 식으로 동시에 여러 개의 명령어를 실행하는 기법이다.
* 하나의 명령어는 여러 개의 단계로 나눌 수 있는데, 이때 하나의 명령어를 처리할 때까지 다음 명령어가 처리되지 않고 기다린다면, 명령어의 특정 단계를 처리하는 동안 다른 단계를 처리하는 부분은 아무 작업도 하지 않게 된다. 이때 파이프라인을 사용하면 한 명령어의 특정 단계를 처리하는 동안 다른 부분에서는 다른 명령어의 다른 단계를 처리할 수가 있게 되므로 속도가 향상될 수 있다.
* 파이프라인의 효율은 브랜치나 서브루틴 콜이 많아질수록 떨어진다. 그 이유는, 브랜치나 서브루틴 콜이 이루어지면, 파이프라인에서 처리되던 명령어들이 다 취소되고 새로 브랜치나 서브루틴의 명령어를 처리해야하기 때문이다. 최신 아키텍처는 분기 예측 등의 기법을 통해 이런 문제를 회피한다.
* RISC 프로세서의 경우 CISC 프로세서보다 파이프라인 효율이 좋다. RISC는 명령어가 한 클록에 처리되므로, 한 명령어를 오래 처리해서 다음 명령어의 처리가 늦어지지 않기 때문이다. 또한, 메모리에 접근하는 경우, 매우 오랜 처리시간이 걸리는데, RISC는 LOAD나 STORE 명령어만으로 메모리에 접근하므로 비효율적인 접근이 CISC보다 적기 때문이다.

### 부연설명
* CPU 전체가 한 번에 하나의 명령을 처리하는 것이 아니라 명령어 몇 개를 동시에 처리함과 동시에 명령 하나를 또다시 여러 단계의 작은 명령으로 나누고 각 부분을 차례대로 처리한다. 
* 즉 몇 개의 명령어가 몇분의 1로 나누어지고, 그런 명령어 몇 개가 한번에 돌아가는 것이다. 이런 식으로 작동하는 이유는 많은 기계어 명령이 코드로는 하나로 되어 있어도 실제 처리해야 하는 일은 여러 단계로 나누어져 있고 각 단계는 이전 단계가 처리되기 전에는 수행이 불가능하기 때문이다.

### 클록
* 클럭 속도(문화어: 박자속도) 또는 클록 주파수는 컴퓨터 프로세서의 동작 속도이다. "초당 사이클"로 측정하며 헤르츠(Hz) 단위를 사용한다.


## CISC RISC 비교
-  하드웨어가 강조됨 <> 소프트웨어가 강조됨
- 여러 클럭의 복합 명령어를 포함 - 오직 단일 클럭의 축약명령어만 포함
- Memory to Memory : “LOAD”, “STORE” 가 각 명령들 안에서 수행됨. <> Register to Register : “LOAD”, “STORE” 를 독립적인 명령으로 사용함
- 작은 코드 크기, 단위시간동안 높은 사이클 <> 단위시간동안 낮은 사이클수, 큰 코드 크기
- 축약명령어를 저장을 위해 트랜지스터가 사용됨. <> 메모리 레지스터에 보다 많은 트랜지스터가 사용됨.
- 그러나 RISC는 몇몇 아주 중요한 장점을 가져다 준다. 왜냐하면 각각의 명령은 실행하기 위해 단지 한 클럭 사이클만 필요로 한다. 전체 프로그램은 여러 사이클의 “MULT" 명령 만큼의 총 수행 시간에 근접하게 실행될 것이다. 이런 RISC의 “축약 명령어(Reduced Instruction)"는 복합 명령어에 비해 적은 수의 트랜지스터를 요구하면서 범용 레지스터들을 위한 좀 더 많은 공간을 남겨둔다. 결국 모든 명령어들은 단일 형태로 실행되기 때문에 파이프라이닝(Pipelining)이 가능하게 된다. 나누어진 “LOAD" 와 “STORE" 명령어는 실제로 컴퓨터가 수행하야 하는 작업의 총량을 감소시켜준다. CISC 스타일의"MULT" 명령이 실행된 이후 프로세서는 자동적으로 레지스터들을 지운다. 만약 피연산자 값 중에 하나가 다른 계산에서 사용되고자 한다면. 프로세서는 메모리 뱅크에서 레지스터로 그 데이터를 다시 읽어와야만 한다. RISC에서는 다른 새로운 값이 저장되기 전까지 데이터가 레지스터에 그대로 남아 있게 된다.
 
## 최근 동향
- 80년대 초반 RISC 칩이 소개된 이후로 프로세서 기술은 두드러진 발전을 보여왔다. 여러 가지 향상된 기술들이 RISC와 CISC프로세서에 도입됨으로써 둘 간의 경계는 흐려지고 있다. 사실은 두 아키텍처들은 거의 서로의 장점들을 수용하고 있는 듯해 보인다. 프로세서의 성능이 향상됨에 따라 CISC 칩들은 이제 하나의 클럭 안에 1개 이상의 명령어를 실행할 수 있다. 이것은 또한 CISC 칩이 파이프라이닝을 이용하는 것을 허락한다.  또한 다른 기술적인 향상과 함께 칩 안에 보다 많은 트랜지스터를 넣을 수 있게 되었다. 이것은 RISC프로세서가 CISC와 같은 복잡한 명령들을 제공할 수 있는 여유를 제공한다. 또한 “수퍼스칼라 실행(Superscalar Execution)”과 같은 여분의 실행 단위를 이용할 수 있는 복잡한 하드웨어를 사용할 수 있다.
 
## EPIC
- CISC와 RISC의 가장 큰 위협적인 상대는 서로가 아니라 EPIC이라 일컬어지는 새로운 기술일 것이다. EPIC은Explicitly Parallel Instruction Computing을 나타낸다. Parallel 단어가 상징하는 것처럼 EPIC은 여러 명령어를 병렬로 실행할 수 있다.
- EPIC은 인텔에 의해 개발되었고, CISC와 RISC가 조합된 방법으로 제작되었다. 이론적으로 하나의 CPU가 유닉스 기반 뿐 아니라 윈도 기반의 프로세싱을 제공한다.
- 인텔은 초기 머시드(Merced)라는 코드네임으로 작업해오다가 현재는 아이태니엄(Itanium, IA-64)이라는 64비트 마이크로프로세서로 시판중에 있다. (인텔의 경쟁사 AMD는 아이태니엄에 대응하여 확장된 형태의 64비트 CISC – 해머(Hammer) – 를 내놓을 준비를 하고 있다. 과거 CPU 들과 서로 호환되는 것이 큰 장점이다.)
- 인텔의 EPIC 아키텍처가 성공한다는 이것은 RISC에 가장 큰 위협이 될 것이다. Sun이나 모토롤라과 같은 주요 CPU제조업체들은 현재 x86기반의 제품들을 판매하고 있다. 몇몇은 아이태니움을 판매하고 있지만 CISC나 RISC가 사라질 것으로 예상하진 않는다.
 
