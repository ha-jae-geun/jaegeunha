# [반도체 업계 시가총액 1위 TSMC](https://www.youtube.com/watch?v=LFIgECK69Mw&list=PLJPjg3It2DXQUdlAocHh5FASozqwtJavv&index=7)

# GPU
* 논리적으로 수천 개의 코어가 있으며 쉽고 서로 관련 되어있지 않은 독립적인 일을 병렬적으로 하는데 

# 슈퍼 컴퓨터
* 슈퍼 컴퓨터가 할 수 있는 것은 일반 컴퓨터도 할 수 있다.
* CPU는 고성능보다 저전력에 다량으로 집어넣음
 * 한 슈퍼컴퓨터가 사용하는 전력의 양 = 중소도시 전체 사용량

## 계산노드
* 예를 들어 54코어 CPU + RAM(512GB) + 여러개의 GPU

## IO노드
* 54코어 CPU + 여러 SSD(TLC, QLC) + SLC/MLC(용량 작지만 속도 빠른) + 램(계층별로) 

## 네트워크 스위치
* 랙(rack) 끼리 네트워크 연결 위함

## 랙(rack)
* 네트워크 스위치 - CN - IO노드

## 스토리지 노드
* 네트워크 스위치 - 여러 랙 - 네트워크 스위치 - 스토리지 노드(최종저장)

## 스토리지 메타데이터 노드
* 파일을 찾을 때 그 파일이 어디 SN에 있는지 몇번째 하드에 있는지 알려주는 정보 보관

# 윈도우
* 루퍼스
* 3DP Chip

## 정품
* 개발용 컴퓨터: 폴더 보안

# 중고 컴퓨터
* CPU, 메인보드, 램, 그래픽카드/VGA, SSD, HDD, 본체
* CPU는 반후법칙
* 램은 16GB면 8GB 두개 끼거나 16GB 한개 끼거나( 램은 따로 떼어서 파는 사례가 많아 가격이 많이 안내려감)
* 중고나라, 다나와, 구글
  * 구글에 - vs 
* 기본적으로 컴퓨터 부품은 최소 1~3년 또는 3~5년 정도의 무상a/s기간이 존재합니다.  (이 기간은 부품별로 다릅니다.)
* 어느제조사 파워인지와 정격파워인지 뻥파워인지도 알아보셔야 합니다. 뻥파워라고 해서 못쓸건아닙니다만. 정격파워와는 다르게 뻥파워600W면 최대출력이 600W이고 안정적으로 사용할수 있는 실제 W수는 250-400W사이라고 합니다. (제조사마다 다릅니다.) 뻥파워의 성능은 그야말로 최악이죠.  그리고 뻥파워는 A/s또한 대부분 제대로 이루어지지 않기에 파워를 교체할 수 밖에 없게됩니다. 
* 5. 그냥 돈 10-20만원 더모아서 다나와에서 조립컴퓨터 맞추고 동네 컴퓨터점에서 윈도우만 깔아달라고 해라﻿
 
# 노트북
* 게이밍 / 경량(코딩 등에 특화) / 맥북
* 화면 크기(키패드 유무), 무게(저장 공간, 그래픽 카드), 램, CPU, 프리도스(운영체제 미설치)
* 무게 결정: 하드디스크, 그래픽카드
* 다나와

# 모니터
* 화면크기, 패널, 해상도(와이드; FHD/4K), 주사율, 플리커 프리, 블루라이트 차단, 틸트

## 일반 사무용 모니터
* 일반적으로 24, 27인치

## 게이밍 모니터


## 패널
1. 응답속도
* GTG: 회색 to 회색
* 빠르면 게임에 적합

2. 광시야각
* 어디에서 보든 정자세에서 보는 사람과 같은 화면 볼 수 있음

3. 색 표현

## 해상도
* 보통 16:9
* FHD(1920x1080)

## 주사율
* 1초에 화면이 새로고침 되는 횟수; 사무용은 60HZ면 충분
  * 높은 주사율을 구사하려면 그래픽 카드가 뒷받침 되야함(그만큼 많은 화면을 보여줘야 하기 때문)
* 기존엔 68HZ명 충분했지만 게이밍 모니터엔ㄴ 144HZ를 선호하기 시작; 2014년에 대부분 인터넷에서 최대 60프레임까지 사용 가능

## 플리커
* 플리커프리: 화면 깜빡임이 없어 장시간 사용에도 눈의 피로도가 적은 모니터

## 블루라이트
* 청색 파장은 자외선과 유사한 속성을 가져 눈의 망막 깊숙히 침투

## 무결성
* 무결점정책이라는게 전세계 통틀어서 한국에만 있는 웃기는 것임. 원래 모든 화면 제품에는 불량화소란 없어야 하는 것이지만 이 공정을 줄이고 불량화소 껴있어도 단가 후려치지 못하도록 양품에다가 프리미엄 가격을 붙여서 더 많이, 더 비싸게 팔기 위한 상술 
  * 회사마다 무결점의 기준, 불량 기준이 다르다.

## g-sync/Free-sync
* 모니터-그래픽 카드 사이의 싱크 맞추는

## 수직 동기화
* 프레임 고정; 프레임이 올라갔다 내려갔다 보다는 차라리 60HZ에 고정;
  * 안정된 프레임으로 고정되기 때문에 59HZ로 프레임이 내려가면 30HZ로 고정시킨다.

## 인풋랙 

## 핫키
* RPG/FPS 각각 다른 그래픽 셋팅 값

## 조준선

## 기타
* 자체 스피커, 틸트

# 비트

- 비트가 클수록 - 한 번에 처리할 수 있는 데이터가 더 많아지는데요. 쉬운 예로 32bit는 빵굽는 틀이 32개이고 64bit는 빵굽는 틀이 64개라는 것입니다. 당연히 구울수 있는 양의 차이가 날 수 밖에요.
- 64비트는 무려, 1천 844경 6744조 737억 955만 1616 비트만큼의 데이터를 처리할 수 있습니다!!
- 32비트와 64비트의 가장 큰 차이점은 메모리 인식률로, 32비트는 4GB까지 가능하지만 64비트는 4GB이상의 RAM을 인식할 수 있는데요. 그렇기에 윈도우 32비트에서는 8GB의 RAM을 꽂더라도 4GB까지만 사용할 수 있습니다. (결국 데이터의 처리 양과 속도, 업그레이드 가능/불가능의 차이로 볼 수 있죠) 데이터 처리속도의 경우 전문적으로 사용하지 않는 이상, 그래픽에서나 그 차이를 확인할 수 있는데요. 64bit가 32bit에 비해 더 정밀한 그래픽 처리가 가능하기 때문입니다. 그리고 이론적으로 32비트와 64비트의 차이는 2배 정도지만, 실제로는 10-20%정도라고 하네요.


## x86 표시 이유
- x86으로 표시된 이유는 바로 PC 칩셋의 품번 때문입니다. x86으로 표기가 된 것은 80-86이라는 숫자를 인텔 32비트이하 계열 제품명에 붙였기 때문인데요. 그리하여 32비트는 x86이라고 표시되어 있는것이죠. x64는 32비트와 다르게 64비트인것을 표시하기 위해 붙여진 것이고요.


## Y2K 문제
* 1900년대 시간을 가르킬 때 19라는 반복되는 숫자를 아끼기 위해 19 생략하고 뒤에 년도만 표시했었음
  * 평촌 목련아파트 온수 공급중단 사건

## Y38K 문제
* Y38K(2038년도) 문제; time_t가 1970년도 1월 1일부터 시간 세는 중; 2038년 1월 10일에 1901년대로 인식하게 되고 이렇게 되면 조그만 가정제품부터 큰 댐, 공장에게 치명적인 오류가 발생할 가능성이 높다.

## 32비트
* 4,294,967,295 숫자 표현 가능; 예전 바람의 나라 풀 경험치; 여기서 맨 왼쪽 부호비트 주면서 2,147,483,647 표현
* Y38K(2038년도) 문제; time_t가 1970년도 1월 1일부터 시간 세는 중; 2038년 1월 10일에 1901년대로 인식하게 되고 이렇게 되면 조그만 가정제품부터 큰 댐, 공장에게 치명적인 오류가 발생할 가능성이 높다.

## 64비트
* 2922억년 7천만년까지 카운트 가능
* 램을 192GB까지 지원 가능

## 게이밍 노트북
* 화면 크기가 크면 무겁지만 큰 것을 고려하는 사람이 많음

## 초경량 노트북; 울트라북


## 폰 노이만 구조
* 입력 장치 -> CPU(제어장치 / 산술+논리장치) <> 메모리 -> 출력장치
* 폰노이만 구조는 크게 CPU, 메모리, 입출력 장치로 구성되어 있으며, CPU안에는 산술/논리장치, 프로세서 레지스터를 포함하고 있는 처리 장치(Processing Unit)와 명령어 레지스터와 프로그램 카운터를 포함하는 제어장치로 구성된다. 메모리는 데이터와 명령어를 함께 저장할 수 있다.

## IOT
* OS + CPU + 메모리 + 

## 영상
* Decoder -> codec (열 많이 냄)

## 열 발생
* CPU, 그래픽 카드

# NAND
* SSD 는 NAND Falsh Memory 를 사용합니다.
* SLC ( Single Level Cell ) : 셀당 1바이트를 기록, 속도와 수명이 가장 높다. 가격 또한 비싸다. 초기 SSD에 사용됬었다.
* MLC ( Multi Level Cell) : 셀당 2바이트를 기록, 속도와 수명은 보통. 가격 또한 적당. 현재 대부분 SSD에 사용된다.
* TLC ( Triple Level Cell) :  셀당 3바이트를 기록 , 속도와 수명이 매우 낮다. 주로 USB에 많이 사용된다.
* NAND Falsh Memory 는 셀마다 플로팅 게이트(FG) 라는곳에 전자를 채우고 비우는 방식으로 기록 됩니다.
* SLC 상에서는 가득차고 비우고로 구분을 하기때문에 간단하지만 MLC 부터 TLC 는 채워진 전자의 양에 따락 구분하므로 읽고 , 쓰기 속도가 떨어집니다.
* 또한 NAND Falsh Memory 는 덮어쓰기 기능이 존재하지 않습니다. 말했듯이 전자를 채우고 비우는 방식으로 기록하기 때문에 일단 지우고 다시 채우는 방식을 택하기때문에, 덮어쓰기가 불가능 합니다ㅏ.
* 그러므로 MLC 와 TLC 처럼 전자의 채워진 양을 구분해서 기록하고 쓰기때문에 이 작업은 더뎌 질 수 밖에 없죠.
* 정확한 전자량을 측정하기 매우 힘들기때문에 , 전자의량을 세부화 시킨 TLC 는 오류량도 그만큼 많고, 그 많은 오류를 측정하기 때문에, 속도가 더욱 떨어지게 된다고 합니다.

## NAND와 DRAM의 차이
* 메모리 반도체는 어떤 디바이스든 모두 스위칭 및 데이터 저장 기능을 갖습니다. 스위칭 기능은 창고에서 데이터 집단을 받을 것인지 받지 않을 것인지의 여부를 결정하는 문(door)의 여닫이 역할을 하고, 데이터 저장 기능은 말 그대로 데이터를 쌓아두는 창고 역할을 하지요.
* 스위칭 동작에 있어서는 디램이 훨씬 빠르지만, 데이터 저장 기능에서는 낸드플래시가 월등합니다. 디램은 64ms(1,000분의 1초) 동안만 저장할 수 있는 반면, 낸드플래시는 디램과 비교했을 때 저장기간이 상상을 초월합니다. 제품별로 다르지만, 저장하는 Cell의 물리적인 입장에서 본다면 SLC는 약 5~10년, MLC/TLC는 약 1~2년 동안의 기간을 저장할 수 있습니다(SW 등의 보완 조치로 저장 기간을 더욱 길게 확장 할 수 있음). 그래서 낸드플래시는 전원이 꺼져도 창고라는 공간에 저장된 데이터가 존재하므로 ‘비휘발성 메모리’라고 합니다. 반면 디램은 전원이 ON일 때 일정한 주기로 새로운 refresh 전원을 계속적으로 인가해주면 데이터는 저장창고에 남게 됩니다. 하지만 전원을 OFF하면 어떤 경우든 데이터는 소멸하므로 ‘휘발성 메모리’라고 부릅니다.
* 낸드플래시가 구조적으로 디램과 구분되는 가장 큰 차이점은 게이트(Gate)가 2개라는 점입니다. MOS형 트랜지스터(Tr)는 소스(Source), 드레인(Drain), 게이트 총 3개의 단자로 구성되는데요. 그중 게이트 단자가 1개이면 디램, 2개이면 낸드플래시가 됩니다. 낸드플래시의 추가된 게이트 단자는 부유 게이트, 즉 플로팅 게이트(Floating Gate)라고 부릅니다. 이는 모든 입체 영역으로부터 절연층으로 분리된 상태로 마치 섬처럼 부유하고 있다고 하여 붙여진 이름입니다. 이로 인해 낸드플래시는 읽고 쓰고 저장하는 모든 동작에서 디램과 에스램(SRAM)보다 독특한 특성을 지니게 되었는데요. 그 중 가장 핵심적인 특징이 데이터를 원하는 일정기간 저장할 수 있는 비휘발성 데이터의 저장 능력입니다. 그런데 이러한 장점을 갖기 위해서는 동작 속도 등 디바이스 특성에서 희생을 감수하고, 또 재질과 공정방법 및 설계 등에서 보완해야 한다는 단점이 다수 있습니다. 
* 따라서 구조적으로 볼 때, 디램은 스위칭 역할을 하는 Tr 1개와 Tr 밖에 별도로 데이터를 저장하는 캐패시터 1개를 둡니다(DRAM Cell=MOS Tr 1개+Capacitor 1개). 반면 낸드플래시는 스위칭 역할을 하는 트랜지스터 속에 데이터 저장 기능을 갖는 플로팅 게이트를 같이 내포하고 있어서 MOS Tr 1개만으로 메모리로서 해야 할 여러 가지 기능을 수행합니다(NAND Cell=MOS Tr 1개). 따라서 낸드플래시는 Top gate(상판게이트 혹은 Control 게이트)와 Bottom gate(하판 게이트 혹은 부유 게이트)가 있으므로 총 2개의 게이트를 갖게 되는 셈입니다.
* 집적도 측면에서는 낸드플래시가 메모리 디바이스 중 가장 유리합니다. 표면적을 차지하는 디바이스의 점유 면적을 상대적으로 가장 작게 할 수 있기 때문이지요. 낸드플래시의 집적도가 가장 높은 근본적인 이유는 구조에서 찾아볼 수 있는데요. 디램은 저장기능을 하는 캐패시터를 Tr 밖에 별도로 두어야 하므로 2D 표면적을 많이 점유합니다. 따라서 낸드플래시의 집적도는 항상 디램보다 앞서 나가며, 3D를 적용하고부터는 집적도 차이는 더욱 커질 것으로 예측됩니다. 동일 메모리의 저장용량으로 들여다볼 때, 2D 낸드플래시의 구조적인 차이가 디램과 10년 차이를 만들어 내었고, 3D 낸드플래시는 동일 집적도 비교 시 디램과는 15년 차이를 나타낼 것으로 예측됩니다. 
* 낸드플래시는 메모리 디바이스 중에 속도가 가장 느립니다. 이는 디램과는 달리 추가적으로 존재하는 게이트인 플로팅 게이트가 있기 때문인데요. 낸드플래시의 핵심 구조물인 플로팅 게이트는 낸드플래시에 전자들을 저장하는 역할을 합니다. 플로팅 게이트를 6개 면으로 둘러싸고 있는 절연막들은 그 안에 저장된 전자들이 쉽게 탈출하지 못하도록 막는 역할을 하지요. 그래서 플로팅 게이트의 위로는 Blocking Layer(ONO : 3개 절연층)가 있고, 아래로는 Tunneling Oxide(전자들이 건너가는 절연막, SiO2), 옆으로는 Sidewall Oxide(측벽절연막, SiO2)가 막아서고 있습니다. 이런 구조에서 동작 전압이 인가되면 플로팅 게이트와 아래위의 절연막들이 합작하여 여러 가지 캐패시턴스 성분을 만들고, 이런 성분들이 결국 낸드플래시의 동작 속도를 느리게 하는 요인으로 작용하게 됩니다.
* MOS Tr에 인가되는 게이트 단자에 디램과 낸드플래시에 동일한 크기로 전압이 인가될 경우, 채널 형성에 기여하는 실질적인 전압은 낸드플래시에 더 작게 인가됩니다. 이는 플로팅 게이트와 플로팅 게이트 아래위로 존재하는 2개 캐패시터의 영향 때문이지요. Word line으로 게이트 전압 Vgate가 인가 시에 디램은 기판층(Substrate) 혹은 채널에 직접적인 영향(Vgate=Vsub)을 끼칩니다. ▶<채널이 만들어 내는 반도체 동작특성, 드레인 전류의 변화> 편 참고 하지만 낸드플래시에서는 기판 방향으로 직렬로 늘어서 있는 캐패시터 2개(Cono+Ctox)를 통과하기 때문에 기판에 최종적으로 인가되는 전압 Vsub(Input 전압2 @NAND)은 초창기 게이트 전압 Vgate(Input 전압1 @DRAM)에 비해 작아집니다.
* 트랜지스터의 스위칭 작용인 ON/OFF를 결정 짓는 드레인 전류를 비교해보겠습니다. 게이트에 전압이 동일하게 인가되는 조건(Vgate)이라면, 디램보다는 낸드플래시의 드레인 전류가 적게 흐르고 전류 Drive 능력이 떨어지므로 동작 속도도 느려집니다. 일반적으로 게이트 입력 전압을 증가시킬 경우 기판 내의 전자가 이동할 채널의 체적이 커지므로 드레인 전류(소스 단자에서 드레인단자로 이동하는 전자의 흐름)는 게이트 전압에 비례하여 증가합니다. 또, 소스와 드레인 단자 사이를 연결하는 채널도 빠르게 형성되므로 동작 속도 역시 빨라지지요. 
* 그런데 디램과 낸드플래시의 드레인 전류 증가율을 비교해보면, 입력 게이트 전압이 높아질수록 디램에 비해 낸드 전류의 상승률이 낮습니다. 이는 실질적으로 기판의 채널에 영향을 주는 게이트 전압인 Vsub의 증가률이 낮기 때문이지요. 결국 MOS Tr이 ON/OFF 구실을 제대로 하기 위하여는 일정 전류량 이상이 확보되어야 하는데요. 따라서 낸드플래시의 경우, 드레인 전류량을 디램과 동일하게 하려면 인가하는 게이트 전압을 디램보다 높여야 하겠지요

# 램; Random Access Memory = 주기억장치(Rom+RAM), DRAM, 메인 메모리
* <> SAM; Sequential Access Memory; 순차 접근 메모리; 하드디스크, CD, 테이프(예전에 테이프 감으면서 썼던것 처럼; 랜덤하게 갈 수 없음)
* DRAM = Dynamic RAM; 메인 메모리; 주기억장치(ROM+RAM)
  1. 최근에 접근된 데이터; Tempoary Locality - 시간적 지연성
  2. 최근에 접근된 데이터의 주변 데이터; Spatial Locality - 공간적 지연성
* CPU - 램 - 하드디스크
* Level 1,2,3 캐시 접근 - 메인 메모리(램) - SSD
* 램이 크면 느린 디스크와 상대할 일이 줄어들기 때문에 속도도 자연스럽게 빨라진다.
  * 현재 필요한 데이터와 가까운 미래에 필요할 것 같은 데이터만 램에 올려놓기 때문에 게임보다 작아도 정상 실행된다.
* 16GB 1개 VS 8GB 2개(듀얼채널); 

## 속도
* CPU > Level1 cache access > Level2 cache access > Level3 cache access > RAM > Optane Memory > SSD > HDD

## Optane Memory: 비휘발성메모리
* 램에서 발전
* 인텔과 마이크론의 합작으로 탄생한 RAM과 플래시 메모리의 중간 형태. 일단은 비휘발성 메모리이다. 다만 DIMM 형태로 RAM이나 메모리가 아닌 새로운 패러다임으로 봐야할 지도 모른다. 기존의 NAND 형태의 SSD보다 레이턴시가 1,000배 더 빠르고,[1] 1,000만 번의 쓰기가 가능하는 등 1,000배 더 내구성이 뛰어나고, DRAM보다 10배 더 높은 집적도를 가진다고 홍보하고 있다.

## 램을 추가하면 속도가 빨라지는 이유
* 램이 크면 느린 디스크와 상대할 일이 줄어들기 때문에 자연스럽게 빨라진다.

## 게임들이 용량이 큰데 렘이 게임보다 작다
* 현재 필요한 데이터와 가까운 미래에 필요할 것 같은 데이터만 램에 올련호기 때문에 게임보다 작아도 정상 실행된다.

## 램 개수
* 8G2개보다 16GB 1개가 불리할 때가 있음; 

## 듀얼채널 구성

### 메모리 채널
* @@ CPU - 캐시 - 메모리 컨트롤러(채널) - 데이터 버스 
* [메모리 채널](https://thrillfighter.tistory.com/439)

```java
메모리 채널은 메모리와 CPU의 캐시 간에 데이터 전달 통로다. 비유하자면 자동차 도로의 하나의 차로가 하나의 채널이라고 생각하면 된다. 자동차 하나하나를 데이터로 생각하면 1차로 보다는 2차로를 사용할 때 시간당 데이터 전달 양을 많이 할 수 있다. 이것을 대역폭(bandwidth)라고 한다. 2개의 채널을 사용하게 되면 1개의 채널을 사용할 때 보다 대역폭이 2배로 커지므로 캐시에 데이터를 더 많이 전달할 수 있다. 

그렇다고 데이터 전송 속도가 빨라지는 것은 아니므로 대역폭 증가가 처리속도 증가를 보장하지는 않는다. 1차로로 충분한 도로를 2차로로 바꿔도 목적지까지 빨리갈 수 있는 것이 아니기 때문이다.
```

### 메모리 인터리빙
```java
메모리 인터리빙(Memory Interleaving)
채널을 여러 개 사용하면 메모리 인터리빙이라는 기능을 통해서 한번에 미리 사용가능한 데이터를 다채널(듀얼채널)로 캐시에 전달해 놓을 수 있다. 채널1을 통해서 현재 사용하려는 데이터를 캐시에 전달했다면 채널 2를 통해서 다음에 사용할 가능성이 높은 데이터를 동시에 전달하는 것이다. 다음에 사용할 가능성이 높은 데이터는 바로 다음 주소의 데이터가 된다.

이렇게 할 수 있는 이유는 앞에서도 말했지만 듀얼 채널을 사용할 경우 메모리 뱅크 1과 메모리 뱅크 2 간에 주소 순서가 번갈아가면서 연결되기 때문이다.
아무튼 램(메모리) 듀얼채널을 사용하는 이유는 이런 효율성을 위한 것이다. 
```



## bus
* CPU와 메인 메모리 사이에 데이터를 저장하기 위한 터미널이다.  
  ^bus is terminal between CPU and Main memory to save data
* Address bus, Data bus, Control bus
* [Bus link](http://ssoonidev.tistory.com/14)
* [Bus link2](http://contents.kocw.net/KOCW/document/2015/cup/leesangkwan/6.pdf)


## Clipboard
* 윈도우 뿐만 아니라 다른 OS에도 있다.  
    ^Not only on Windows, but also on other operating systems.






# 환경변수 등록

## Path
- 서비스에 등록한 것과 같음.
- 우선순위가 높은 것이 올라가는 등 순서가 바뀜
  - 시작 프로그램에 등록해놓으면 우선순위 올라감; 수동적으로 수정해서 우선순위 변경 가능
