# 윈도우
* 루퍼스
* 3DP Chip

## 정품
* 개발용 컴퓨터: 폴더 보안

# 중고 컴퓨터
* CPU, 메인보드, 램, 그래픽카드/VGA, SSD, HDD, 본체
* CPU는 반후법칙
* 램은 16GB면 8GB 두개 끼거나 16GB 한개 끼거나( 램은 따로 떼어서 파는 사례가 많아 가격이 많이 안내려감)
* 중고나라, 다나와, 구글
  * 구글에 - vs 
* 기본적으로 컴퓨터 부품은 최소 1~3년 또는 3~5년 정도의 무상a/s기간이 존재합니다.  (이 기간은 부품별로 다릅니다.)
* 어느제조사 파워인지와 정격파워인지 뻥파워인지도 알아보셔야 합니다. 뻥파워라고 해서 못쓸건아닙니다만. 정격파워와는 다르게 뻥파워600W면 최대출력이 600W이고 안정적으로 사용할수 있는 실제 W수는 250-400W사이라고 합니다. (제조사마다 다릅니다.) 뻥파워의 성능은 그야말로 최악이죠.  그리고 뻥파워는 A/s또한 대부분 제대로 이루어지지 않기에 파워를 교체할 수 밖에 없게됩니다. 
* 5. 그냥 돈 10-20만원 더모아서 다나와에서 조립컴퓨터 맞추고 동네 컴퓨터점에서 윈도우만 깔아달라고 해라﻿
 
# 노트북
* 게이밍 / 경량(코딩 등에 특화) / 맥북
* 화면 크기(키패드 유무), 무게(저장 공간, 그래픽 카드), 램, CPU, 프리도스(운영체제 미설치)
* 무게 결정: 하드디스크, 그래픽카드
* 다나와

# 모니터
* 화면크기, 패널, 해상도(와이드; FHD/4K), 주사율, 플리커 프리, 블루라이트 차단, 틸트

## 일반 사무용 모니터
* 일반적으로 24, 27인치

## 게이밍 모니터


## 패널
1. 응답속도
* GTG: 회색 to 회색
* 빠르면 게임에 적합

2. 광시야각
* 어디에서 보든 정자세에서 보는 사람과 같은 화면 볼 수 있음

3. 색 표현

## 해상도
* 보통 16:9
* FHD(1920x1080)

## 주사율
* 1초에 화면이 새로고침 되는 횟수; 사무용은 60HZ면 충분
  * 높은 주사율을 구사하려면 그래픽 카드가 뒷받침 되야함(그만큼 많은 화면을 보여줘야 하기 때문)
* 기존엔 68HZ명 충분했지만 게이밍 모니터엔ㄴ 144HZ를 선호하기 시작; 2014년에 대부분 인터넷에서 최대 60프레임까지 사용 가능

## 플리커
* 플리커프리: 화면 깜빡임이 없어 장시간 사용에도 눈의 피로도가 적은 모니터

## 블루라이트
* 청색 파장은 자외선과 유사한 속성을 가져 눈의 망막 깊숙히 침투

## 무결성
* 무결점정책이라는게 전세계 통틀어서 한국에만 있는 웃기는 것임. 원래 모든 화면 제품에는 불량화소란 없어야 하는 것이지만 이 공정을 줄이고 불량화소 껴있어도 단가 후려치지 못하도록 양품에다가 프리미엄 가격을 붙여서 더 많이, 더 비싸게 팔기 위한 상술 
  * 회사마다 무결점의 기준, 불량 기준이 다르다.

## g-sync/Free-sync
* 모니터-그래픽 카드 사이의 싱크 맞추는

## 수직 동기화
* 프레임 고정; 프레임이 올라갔다 내려갔다 보다는 차라리 60HZ에 고정;
  * 안정된 프레임으로 고정되기 때문에 59HZ로 프레임이 내려가면 30HZ로 고정시킨다.

## 인풋랙 

## 핫키
* RPG/FPS 각각 다른 그래픽 셋팅 값

## 조준선

## 기타
* 자체 스피커, 틸트

# 비트

## Y2K 문제
* 1900년대 시간을 가르킬 때 19라는 반복되는 숫자를 아끼기 위해 19 생략하고 뒤에 년도만 표시했었음
  * 평촌 목련아파트 온수 공급중단 사건

## Y38K 문제
* Y38K(2038년도) 문제; time_t가 1970년도 1월 1일부터 시간 세는 중; 2038년 1월 10일에 1901년대로 인식하게 되고 이렇게 되면 조그만 가정제품부터 큰 댐, 공장에게 치명적인 오류가 발생할 가능성이 높다.

## 32비트
* 4,294,967,295 숫자 표현 가능; 예전 바람의 나라 풀 경험치; 여기서 맨 왼쪽 부호비트 주면서 2,147,483,647 표현
* Y38K(2038년도) 문제; time_t가 1970년도 1월 1일부터 시간 세는 중; 2038년 1월 10일에 1901년대로 인식하게 되고 이렇게 되면 조그만 가정제품부터 큰 댐, 공장에게 치명적인 오류가 발생할 가능성이 높다.

## 64비트
* 2922억년 7천만년까지 카운트 가능
* 램을 192GB까지 지원 가능

## 게이밍 노트북
* 화면 크기가 크면 무겁지만 큰 것을 고려하는 사람이 많음

## 초경량 노트북; 울트라북


## 폰 노이만 구조
* 입력 장치 -> CPU(제어장치 / 산술+논리장치) <> 메모리 -> 출력장치
* 폰노이만 구조는 크게 CPU, 메모리, 입출력 장치로 구성되어 있으며, CPU안에는 산술/논리장치, 프로세서 레지스터를 포함하고 있는 처리 장치(Processing Unit)와 명령어 레지스터와 프로그램 카운터를 포함하는 제어장치로 구성된다. 메모리는 데이터와 명령어를 함께 저장할 수 있다.

## IOT
* OS + CPU + 메모리 + 

## 영상
* Decoder -> codec (열 많이 냄)

## 열 발생
* CPU, 그래픽 카드

# 램; Random Access Memory
* <> SAM; Sequential Access Memory; 순차 접근 메모리; 하드디스크, CD, 테이프
* DRAM = Dynamic RAM; 메인 메모리; 주기억장치(ROM+RAM)
  1. 최근에 접근된 데이터; Tempoary Locality - 시간적 지연성
  2. 최근에 접근된 데이터의 주변 데이터; Spatial Locality - 공간적 지연성
* CPU - 램 - 하드디스크
* Level 1,2,3 캐시 접근 - 메인 메모리(램) - SSD
* 램이 크면 느린 디스크와 상대할 일이 줄어들기 때문에 속도도 자연스럽게 빨라진다.
  * 현재 필요한 데이터와 가까운 미래에 필요할 것 같은 데이터만 램에 올려놓기 때문에 게임보다 작아도 정상 실행된다.
* 16GB 1개 VS 8GB 2개(듀얼채널); 

# CPU
## 캐시메모리
* 시간적, 공간적 지역성을 기반으로 가까운 미래에 접근될 확률이 높은 데이터를 작지만 빠른 캐시 메모리에 미리 보관하여 전체적인 시스템의 성능을 높인다.
* 메인 메모리(램)보다 훨씬 빠르지만 용량이 작아 중요한 것들이 들어가야 함
* 캐시 메모리 저장 규칙
  1. 최근에 접근된 데이터; Tempoary Locality - 시간적 지연성
  2. 최근에 접근된 데이터의 주변 데이터; Spatial Locality - 공간적 지연성
* 사용하는 곳: 파일 시스템, OS, 구글 크롬, FM, CPU 안에서도 3단계로 나눔


### Cisc
* x86 아키텍처가 리틀 엔디언을 쓰기 때문에, 오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언을 쓰며 이를 ‘인텔 포맷’이라 한다. 거꾸로 네트워크에서는 주소를 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다. 이의 영향으로 많은 프로토콜과 몇몇 파일 포맷이 빅 엔디언을 사용하고 있다. 모토로라 프로세서들은 일반적으로 빅 엔디언을 사용하며, ARM 프로세서들은 성능 향상을 위해 빅 엔디언과 리틀 엔디언을 선택할 수 있도록 되어 있다.
* 명령어가 복잡하기 때문에 명령어를 해석하는 데 시간이 오래 걸리며, 명령어 해석에 필요한 회로도 복잡하다.
* CISC란 소프트웨어 특히, 컴파일러 작성을 쉽게 하기 위해 하드웨어화할 수 있는 것은 가능한 모두 하드웨어에게 맡긴다는 원칙 아래 설계된 컴퓨터이다. 
* 뒤에서부터 스택에 PUSH
* 계산연산에서 빅 엔디안보다 속도가 빠름

### Risc
* RISC의 특징을 CISC와 비교하여 알아보면 다음과 같다. 첫째, 명령의 대부분은 1머신 사이클에 실행되고, 명령길이는 고정이며, 명령세트는 단순한 것으로 구성되어 있는데, 가령 메모리에 대한 액세스는 Load/Store 명령으로 한정되어 있다. 둘째, 어드레싱 모드가 적으며, 마이크로 프로그램에 의한 제어를 줄이고, 와이어드 로직을 많이 이용하고 있다. 반면에 레지스터수가 많으며 마이크로 프로그램을 저장하는 칩의 공간에 레지스터를 배치한다. 셋째, 어셈블러 코드를 읽기 어려울 뿐 아니라 파이프라인을 효과적으로 사용하기 위해서 일부 어셈블러 코드를 시계열로 나열하지 않은 부분이 존재하여 컴파일러의 최적화가 필요하다. 최적화를 하지 않으면 파이프라인을 유효하게 이용할 수 없고, RISC을 사용하는 의미가 없어진다.
* RISC는 CISC 형식의 CPU내 ROM에 소프트웨어적으로 적재된 내부 명령어들을 하드웨어적으로 구성해 제어기가 제거된 부분에 프로세서 레지스터 뱅크와 캐시를 둡니다. 이렇게 함으로써 CPU가 상대적으로 느린 메인 메모리에 접근하는 횟수를 줄여 시스템 수행속도를 향상시킬 수 있습니다.  
* 반면 RISC는 실행 속도를 높히기 위해 가능한 한 복잡한 처리는 소프트웨어에게 맡기는 방법을 택한 컴퓨터이다.
* Unix 의 RISC계열의 프로세서가 사용하는 바이트 오더링
* 네트워크에서 사용하는 바이트 오더링
* 앞에서부터 스택에 PUSH
* 비교연산에서 리틀 엔디안보다 속도가 빠름
* Intel 계열의 프로세서가 사용하는 바이트 오더링
* RISC 프로세서의 경우 CISC 프로세서보다 파이프라인 효율이 좋다. RISC는 명령어가 한 클록에 처리되므로, 한 명령어를 오래 처리해서 다음 명령어의 처리가 늦어지지 않기 때문이다. 또한, 메모리에 접근하는 경우, 매우 오랜 처리시간이 걸리는데, RISC는 LOAD나 STORE 명령어만으로 메모리에 접근하므로 비효율적인 접근이 CISC보다 적기 때문이다.
* 최대의 단점은 코드밀도가 감소하여 같은 내용을 처리하는 데 더 많은 코드 용량이 필요하게 되었다는 점이다. 그 원인은 또 다음과 같이 분류할 수 있다.
  + 항상 16bit 혹은 32bit를 차지하는 고정 길이 명령어는 상황에 따라 8~32bit를 오가는 CISC의 가변 길이 명령어에 비해 코드밀도 면에서 원천적으로 불리하다.
  + 메모리를 대상으로 하는 연산 명령어의 경우 CISC에서는 1개 명령어로 표현 가능한데 RISC에서는 load-execute-store로 3개의 명령어가 필요하다.
  + 마이크로코드로 한 줄로 구현된 CISC명령어를 몇 개, 혹은 수십개의 RISC명령어로 변환해야 한다.

### Cisc, Risc 차이점
* Complex
  + CISC의 단점이자 RISC의 장점은 CISC의 경우 하드웨어의 회로가 복잡해져서 RISC에 비해 가격이 비싸지고 발열이 많고 전력소모가 많게 됩니다.
  +  RISC 명령어가 단순히 명령어 수를 줄인 것이 아니라 명령어 해석기에서의 마이크로코드의 의존도를 제거하고 관련 로직을 단순화하여 성능을 올리는 방향으로 발전했다는 것을 상기하라.
* Instruction
  + RISC: CPI(Clock Per Instruction)을 1 이하로 줄이는 것임, 동급의 CISC에 비해 더 높은 clock frequency를 실현하는 것임
  + RISC 프로세서의 경우 CISC 프로세서보다 파이프라인 효율이 좋다. RISC는 명령어가 한 클록에 처리되므로, 한 명령어를 오래 처리해서 다음 명령어의 처리가 늦어지지 않기 때문이다. 또한, 메모리에 접근하는 경우
  + CISC에서는 여러 clock을 차지하는 복잡한 연산을 하는 명령어들이 종종 있었다. 심지어 for 루프를 실행하는 명령어가 존재했을 정도였다. 이는 과거에 컴파일러의 성능이 부족했기 때문에, 컴파일러를 사용한 후에도 최적화를 하기 위해서 기계어 코드를 수정하는 등 프로그래머가 기계어를 직접 다루는 경우가 많았기 때문이다. 
* Set
  + CPU는 메모리 접근을 피하기 위해 인자나 지역변수를 저장하는데에도 레지스터를 사용한다.
  + 즉, CISC 각각의 명령어는 머신코드는 길지만 전체 프로그램 사이즈는 RISC보다 작습니다. 따라서 코드를 수행할 때 RISC가 메모리를 더 많이 참조해야 하므로.... [CISC가 RISC보다 빠른 요인이 됩니다.] CISC는 복잡한 하드웨어를 가지게 되므로 보통 hard wired방식 보다는 microprogram 방식을 사용하게 됩니다. RISC는 hard wired 방식을 사용할 수 있습니다. [RISC가 CISC보다 빠른 요인이 됩니다.]
  CISC는 레지스터의 양이 많을 필요가 없고 RISC는 레지스터의 양이 많아야 하므로.... (예>함수에 파라미터를 메모리에 저장하는 경우와 레지스터에 저장하는 경우의 차이)
CISC가 메모리의 access가 많아지게 됩니다. [RISC가 CISC보다 빠른 요인이 됩니다.] RISC머신이 파이프라인구현이 용이하다라고 합니다..
* Stack
  + CISC: 일반적으로 하드웨어 스택이 내장되어 있어서 서브루틴 리턴 주소나 인자, 지역변수, 기타 임시 값을 저장하는데 사용한다. Call, ret, push, pop 같은 기계어 명령어를 사용할 경우 stack의 데이터는 자동적으로 관리된다.
  + RISC; Stack 관련 명령어가 존재하지 않음; Return address 나 기타 stack 자료 구조는 SW 적으로 처리해주어야 한다.; Power PC 의 경우, 함수의 인자를 전달하기 위해 8개의 레지스터를 따로 준비하고 있다. 인자값을 메모리에 접근하는 stack operation에 비해 register에 load 한다. 지역변수를 저장하기 위해 stack을 사용할 필요가 없다. 대부분의 짧은 프로시저나 함수를 호출할 때 리턴주소를 SW stack에 저장하기 위해 stack을 사용할 필요가 없다.

## bus
* CPU와 메인 메모리 사이에 데이터를 저장하기 위한 터미널이다.  
  ^bus is terminal between CPU and Main memory to save data
* Address bus, Data bus, Control bus
* [Bus link](http://ssoonidev.tistory.com/14)
* [Bus link2](http://contents.kocw.net/KOCW/document/2015/cup/leesangkwan/6.pdf)

## SSD HDD
* Hdd: 디스크가 돌아야 한다.  
    ^Hdd: disk has to spin
* 기가바이트 회사가 HDD를 RAM으로 만들었었다.  
    ^Gigabyte Company made the HDD with RAM. It didn't release
* SSD는 HDD보다 약 5배 빠르다.  
    ^SSD is 5times faster than HDD
* SSD는 읽기위 쓰기를 하는 개수에 한계가 있다.  
    ^Reading and writing have a limit in SSD
* SSD: Flash memory(Like USB) + Controller  
  - 읽기가 쓰기보다 빠르다
      ^Reading is faster than writing
  - Cell(Memory Storation way) SLC(single) > MLC(Multi) > TLC(triple)  //Usually we use MLC
    + 셀의 개수가 SSD의 가격을 결정한다.  
        ^The number of cell decides SSD's price
    + SLC: 1비트가 1개의 방에 저장된다.  
        ^SLC: 1 bit will be stored in one room
    + SLC: 컨트롤러를 복잡하게 만들고, 불안정하게 한다.  
        ^SLC: It makes a controller complicated and it makes it unstable


## Clipboard
* 윈도우 뿐만 아니라 다른 OS에도 있다.  
    ^Not only on Windows, but also on other operating systems.




# 키보드

## 멤브레인
* 장점: 러버돔 고무; 제조 간단; 단가 저렴; 방수; 가벼운 무게, 저소음
* 단점: 손가락 피로감, 낮은 병렬성->동시 입력 제한, 고장-> 키보드 교환
* 구성: 키캡, 러버돔, 멤브레인, 쇠로 구성

## 무접점
* 구성은 비슷하지만 러버돔 안에 스프링이 존재; 러버돔이 밑에 바닥부분과 접촉하지 않아도 쉽게 눌림
* 장점: 키보드에 무리가 덜감으로 인해 높은 내구도
* 단점: 비싼 가격; 러버돔의 변형
* 키압 선택 가능(균등/차등); wasd 키는 가볍게 다른 것은 무겁게

## 기계식
* 적축, 흑축, 청축, 갈축
  * 1. 필요 키압 2. 소리와 느낌
* 독립적인 스위치; 동시 입력 + 반 영구적인 내구도; 키가 고장나면 한개만 수리
* 비싼 가격; 무게; 오염에 약함

### 청축
* PC방 사운드; 힘 50g; 

### 갈축
* 소음기 달린 청축버전; 힘 45g; 조용하지만 소리 내고 싶음; 입문하기 좋은 기계식

### 적축
* 갈축과 비슷; 빠른 입력/잦은 오타; 힘 45g; 전문가 느낌
* 단시간에 같은 키 반복 입력에 편리

### 흑축
* 입문용에서 제일 먼; 높은 키압; 힘 60g; 조용함+바닥소리
* 리듬게임이나 격투게임의 유저같이 키 실수가 가장 나면 안되는 사람들이 사용; 힘 60g