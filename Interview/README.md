# 자기소개
## 장점
* 습관 정리


# OS


# '웹 크롤링', '스크래핑'

# 크롤링
* (2) 크롤링 크롤링은 웹 사이트를 정기적으로 돌며 정보를 추출하는 기술이다. 크롤링하는 프로그램을 크롤러 또는 스파이더라고 한다. 
* 크롤링으로 웹 정보를 추출할 때는 반드시 하나의 특정 웹 페이지의 URL 주소를 명시해주어야 한다. 가장 먼저 방문하는 URL은 중요한 역할을 하는데 뒤이어 크롤링 되어야할 웹 페이지의 URL은 웹 페이지가 링크하고 있는 웹 페이지를 순차적으로 방문한다. 

# 스크레핑
* (3) 스크레이핑 스크레이핑은 웹 사이트에 있는 특정 정보를 추출하는 기술이다. 스크레이핑은 웹에서 자료를 추출 하는 것 뿐만 아니라 구조도 분석한다. 스크레이핑은 로그인해서 필요한 웹 페이지에 접근 하는 기술이 필요하다. 
* 시스템이나 웹사이트에 있는 정보(데이터) 중에서 필요한 정보를 추출 및 가공하여 제공하는 소프트웨어 기술입니다. 이는 고객이 한 번만 자신의 정보 제공을 인증하게 되면 컴퓨터가 대신하여 필요한 고객 정보들을 자동으로 추출하여 제공하는 것을 말합니다. 

## 뱅크 샐러드
* 뱅크샐러드라는 하나의 애플리케이션을 통해 고객은 자신의 카드사 및 은행, 보험정보들을 한번에 조회할 수 있습니다.

## 스크래핑 종류
* 금융위는 또 서버에 저장하고 관리해 문제가 있다고 거론하는데 이는 서버형 스크래핑이다. 이를 이용하는 업체는 일부인데, 기술력을 보유한 스크래핑 개발업체는 이 방식을 지양하고 있다. 서버형 보다는 클라이언트형 스크래핑을 활용한다. 스마트폰 보급률이 높기 때문이다. 스마트폰에 저장된 개인 인증서를 스크래핑 엔진이 있는 업체에게 곧바로 가기 때문에 제3자가 개인정보를 보거나 유출하기 힘들다. 또 최근 정보 유출 사고 사례 중 스크래핑에 의한 경우는 없었다."
* "API는 무조건 안정적이며 스크래핑은 안정적이지 않다는 비교는 하기 어렵다. 스크래핑은 지속적으로 보안성을 높이는 기술을 개발하고 업그레이드해왔다. 다만 스크래핑은 대상 사이트의 보안정책을 준수하지만, 통신프로토콜을 적용한 API방식은 보안성이 뛰어난 것은 사실이다.


# 은행
## OTP
* OTP(One Time Password)발생기는 전자금융 거래에서 사용되는 일회용 비밀번호 생성 기기로 1분마다 새로운 비밀번호가 생성되어 해킹이나 외부노출의 위험으로부터 안전하게 서비스를 이용하실 수 있습니다.
* 보안카드 불편성 해결(앞자리 뒷자리, 비밀번호 3개 입력),  OTP는 6자리 비밀번호 그대로 입력
* 1분마다 새롱누 6자리 비밀번호 생성

## OTP 단점
* 하지만, 전원문제로 소진이 되면 보안카드 보다 훨씬 더 불편함을 발생할 수 있는데 이를 감추었다고 할 수 있다. 이 같은 상황은 국내 은행들이 발행하는 OTP 비밀번호 발생기는 3V 배터리가 내장되어 밀봉된 형태로, 배터리가 소진하면 재사용이 불가하고, 은행으로부터 새로운 기기를 수령해야 하며, 결과적으로 OTP도 새롭게 등록해야 합니다.
* 반면, 영국은행에서 지급되는 OTP는 국내은행과는 다른 형태의 기기를 제공한다. 사실상 우리의 공인인증서 역할을 함께 한다고 할 수 있다. 그 차이점은 단말기에 '사용자 확인(Identify), 서명(sign), Response등 복합적인 기능을 한꺼번에 처리가 가능하다. 그리고, 우리 개인용 OTP와는 달리, 키패드도 내장되어 있어서, 필요한 번호를 입력함으로써 보안성을 높였다고 할 수 있다.



# N
## thin client
 CPU, 메모리 등 필수적인 하드웨어 장치만 탑재해 네트워크로 연결된 중앙서버에서 모든 업무를 관리하도록 설계된 업무용 PC를 일컫는다.

## vm


## RDP

## Spice

# 가상화 업체 VDI 개발 현황
 
## 가. Citrix
- Citrix의 XenDesktop은 XenServer를 이용하여 공용 또는 전용 VM(Virtual Machine)을 제공하며, 사용자 단말에서 구동되는 XenClient나 스트리밍 VHD(Virtual Hard Disk) 방식을 지원하는 XenApp을 이용한 원격 또는 스트리밍 방식을 지원한다.
 
## 나. VMware
- VMware의 VMware View는 서버 가상화 기술인 vSphere와 통합되어 RDP과 PCoIP 원격 디스플레이 프로토콜을 지원한다. 또한 오프라인으로 가상 데스크톱을 사용할 수 있는 로컬 모드 View는 온라인 가상 데스크톱과 동기화시키는 방식을 사용한다.
 
## 다. Microsoft
- Microsoft는 가상화 플랫폼인 Hyper-V에 RDS(Remote Desktop Services)와 RDVH(Remote Desktop Virtualization Host)를 통합하고 원격 디스플레이 프로토콜로는 RDP를 지원해 가상 데스크톱 인프라 기술을 제공한다.
 
## 라. Oracle
- Oracle에서는 가상 데스크톱 인프라 기술로 Sun Ray 가상 데스크톱 세션 관리 기술과 가상화 플랫폼인 Oracle VDI 하이퍼바이저 기술을 개발하였다. Oracle의 기술은 VMware vCenter, Microsoft Hyper-V, Microsoft RDS를 지원한다.
 
## 마. 공개 SW
- 공개 SW 커뮤니티 중심의 개발 사례로는 RedHat이 오픈 소스 원격 디스플레이 프로토콜인 SPICE(Simple Protocol for Independent Computing Environments)를 데스크톱 가상화에 적용하였으며, Ulteo에서는 Debian과 Ubuntu 기반의 오픈 소스 VDI 솔루션을 제공한다. 
CloudStack.com은 클라우드 IaaS(Infrastructure as a Service) 플랫폼 솔루션을 통한 VDI 클라우드 인프라 구축을 지원하고 있다.


# 회기분석
* 회귀분석은 독립변수와 종속변수 사이의 구체적인 함수식을 찾아내고, 독립변수로부 터 종속변수를 예측하는 데 그 목적이 있다.
* 선형회귀, 다중회귀분석

## 독립변수
- 독립변수는 연구자가 의도적으로 변화시키는 변수를 말합니다.
- 독립변수는 영어로 Independent variable입니다. 말 그대로 독립적인 변수입니다. 통계에서 독립적이라는 말은 다른 변수에 영향을 받지 않는다는 뜻입니다. 따라서 독립변수는 다른 변수에 영향을 받지 않습니다. 오히려 종속 변수에 영향을 주는 변수 입니다. 
* 회귀분석에서 다른 변수에 영향을 주는 원인에 해당하는 변수를 독립변수(independent variable) 또는 설명변수(explanatory variable)라고 하며

## 종속변수
- 영향을 받는 결과에 해당하는 변 수를 종속변수(dependent variable) 또는 반응변수(response variable)라고 한다. 
- 종속변수는 연구자가 독립변수의 변화에 따라 어떻게 변하는지 알고 싶어하는 변수를 말합니다.
- 그렇다면 종속변수는 무엇일까요? 종속변수는 영어로 Dependent variable 입니다. 말 그대로 종속적인 또는 의존적인 변수입니다. 즉 독립변수에 영향을 받아서 변화하는 변수를 종속변수라고 생각하시면 됩니다. 
- 조금 어렵나요? 더욱 쉽게 설명하면 독립변수는 연구자가 마음대로 조정할 수 있는 변수입니다. 왜 일까요? 바로 독립변수가 어떻게 변화하느냐에 따라 종속변수가 어떻게 변화하는지 보고 싶기 때문이죠. 이 때문에 독립변수는 원인변수 (Explanatory variable), 예측 변수 (Predictor variable)라고 부르기도 합니다. 반면에 종속 변수는 연구자가 알고 싶어하는 변수입니다. 연구자의 목표는 독립변수를 조정하여 변화시킬 때 종속변수가 어떻게 변화하는지 알아내는 것 입니다. 이 때문에 종속변수를 반응 변수 (Response variable), 결과 변수 (Outcome variable)이라고 부르기도 합니다. 

## MAE
* Mean absolute error
* -통계에서 평균 절대 오차는 두 연속 변수의 차이를 측정 한 것입니다

# 판다스, 맷플롯립
## 판다스
1. 시리즈(Series): 시리즈 클래스는 1차원 배열의 값(values)에 각 값에 대응되는 인덱스(index)를 부여할 수 있는 구조를 갖고 있습니다.
2. 데이터프레임(DataFrame): 은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스(index)와 열방향 인덱스(column)가 존재합니다. 즉, 행과 열을 가지는 자료구조입니다. 시리즈가 인덱스(index)와 값(values)으로 구성된다면, 데이터프레임은 열(columns)까지 추가되어 열(columns), 인덱스(index), 값(values)으로 구성됩니다.
3. 패널(Panel)

## 넘파이
* Numpy(보통 "넘파이"라고 발음.)는 수치 데이터를 다루는 Python 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.

## 사이킷런
*  머신러닝 학습용 패키지다. 대부분의 머신러닝 모형을 제공하므로 파이썬으로 머신러닝을 공부하는 데 최적의 학습 도구다.
* https://book.coalastudy.com/data-science-lv1/week3/stage3

### Training set
* 모델의 학습에 사용되는 데이터

### Validation set
* 모델 제작 과정 중, 학습된 모델의 성능을 측정하기 위한 데이터
### Test set 모델의 최종 성능을 평가하기 위한 데이터
* 모델의 최종 성능을 평가하기 위한 데이터


## 맷플롯립
* Matplotlib는 데이터를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이해를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.

## Seaborn¶
* Seaborn("시본"이라고 읽는다) 패키지는 Matplotlib 패키지에서 지원하지 않는 고급 통계 차트를 그리는 통계용 시각화 기능을 제공한다.



# 신경망 알고리즘
* Artificial neural network (ANN)는 딥 러닝의 가장 핵심적인 기술로써, 신경 세포인 neuron을 추상화한 artificial neuron으로 구성된 네트워크이다. ANN은 일반적으로 어떠한 형태의 function이든 근사할 수 있는 universal function approximator로도 알려져 있다. 이 글에서는 ANN을 구성하는 가장 작은 요소인 artificial neuron부터 multi-layer ANN과 이를 학습시키기 위한 algorithm에 대해 서술한다.
* 일반적으로 사용되는 기본적인 인공신경망 알고리즘인 다층인공신경망(multi-layer neural network)의 경우 아래 그림과 같이 입력층(input layer), 은닉층(hidden layer), 그리고 출력층(output layer),이렇게 세가지 층으로 구분이 됩니다. 그리고 각 층들은 노드들로 구성되어 있습니다. 아래 그림의 예에서는 입력층은 4개의 노드, 은닉층은 3개의 노드, 그리고 출력층은 1개의 노드를 가지고 있습니다.
* 입력층은 예측값(출력변수)을 도출하기 위한 예측변수(입력변수)의 값들을 입력하는 역할을 합니다. 만약 n개의 입력 값들이 있다면 입력층은 n개의 노드를 가지게 됩니다. 은닉층은 모든 입력노드부터 입력값을 받아 가중합을 계산하고, 이 값을 전이함수에 적용하여 출력층에 전달하게 됩니다. 각 입력노드와 은닉노드들은 모두 가중치를 가지는 망으로 연결되어 있으며 은닉노드와 출력노드도 마찬가지로 연결되어 있습니다.
* 이 가중치는 연결강도로 표현되며 랜덤으로 초기에 주어졌다가 예측 값을 가장 잘 맞추는 값으로 조정되게 됩니다. 전이함수는 비선형함수를 사용하게 되며, 이러한 전이함수를 통하여 출력층에 예측 값이 전달되기 때문에 인공신경망이 비선형 모델로서 역할을 할 수 있게 됩니다.
* https://blog.lgcns.com/1359

## 의사결정트리
* 의사결정나무는 데이터를 분석하여 이들 사이에 존재하는 패턴을 예측 가능한 규칙들의 조합으로 나타내며, 그 모양이 ‘나무’와 같다고 해서 의사결정나무라 불립니다. 질문을 던져서 대상을 좁혀나가는 ‘스무고개’ 놀이와 비슷한 개념입니다. 한번 예를 들어볼까요?
* 의사결정나무는 분류(classification)와 회귀(regression) 모두 가능합니다. 범주나 연속형 수치 모두 예측할 수 있다는 말입니다. 의사결정나무의 범주예측, 즉 분류 과정은 이렇습니다. 새로운 데이터가 특정 terminal node에 속한다는 정보를 확인한 뒤 해당 terminal node에서 가장 빈도가 높은 범주에 새로운 데이터를 분류하게 됩니다. 운동경기 예시를 기준으로 말씀드리면 날씨는 맑은데 습도가 70을 넘는 날은 경기가 열리지 않을 거라고 예측합니다.


## 텍스트와 이미지 딥러닝 기법
* 텍스트 인식 기능, 이미지 딥러닝: 


# SPRING 
## EJB

## POJO

## IOC

## FACTORY 패턴

## SINGLE톤

## FRONT CONTROLLER



# MVC 패턴 로직
1. 프리젠테이션 계층 
 * ◆ 역할 : 프리젠테이션 계층은 말 그대로 사용자 인터페이스에 불과하다. 식당을 예로 들면 손님이 접하게 되는 메뉴판과 전달될 음식을 차려놓는 식탁에 해당한다. 
 * ◆ 기능 : 사용자가 선택할 수 있는 기능이 표시되어 있어야 하고, 요청에 필요한 부가적인 정보 전달을 위한 입력 양식이 있어야 한다. 또한 전달된 자료를 효과적으로 보여주기 위한 프리젠테이션 로직이 포함된다. 하지만 비즈니스 로직이나 퍼시스턴스 계층에서 처리하는 일을 직접 수행하거나(스크립트 릿 사용), 각 계층의 컴포넌트와 직접적인 통신이 있어선 안된다. 
 * 모든 요청은 제어 계층을 통해 처리되어야 한다는 뜻이다. 고급 레스토랑(엔터프라이즈 시스템)에서는 웨이터(지배인)를 통해서만 요구를 전달하고, 그 결과를 전해들어야 한다. 직접 주방장에게 주문을 하거나 자기가 직접 요리를 하는 것은 자기 집(프로토타입)이나 동네 자장면 가게(소규모 웹 애플리케이션)에서나 가능한 일이다. 
 * ◆ 대안 기술 : 현재 가장 주류를 이루는 기술은 JSP 1.2와 JSTL과 같은 태그 라이브러리를 결합하는 방식이다. 과도기적인 형태로 벨로시티와 타일즈 태그 라이브러리가 결합된 형태도 현재 주목을 받고 있다. 하지만 점차적으로 JSF에 기반한 JSP 2.0에 주류 기술로 옮겨갈 가능성이 크고, 프리젠테이션 계층 개발에 있어서도 JSF를 지원하는 IDE를 채택하는 경우가 늘어날 것이다. 
 * ◆ 주요 패턴 : Composite View 패턴 



2. 제어 계층 
 * ◆ 역할 : 제어 계층은 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 컨트롤러를 제공한다. 식당으로 치자면 지배인의 역할과 종업원의 역할을 병행하는 것이라고 볼 수 있다. 
 * ◆ 기능 : 전체 시스템의 설정 상태를 유지해야 하며, 그를 통해 어떤 요청이 들어왔을 때 어떤 로직이 처리해야 하는지를 결정한다. 사용자 요청을 검증하고 로직에 요청을 전달하는 일과 로직에서 전달된 응답을 적절한 뷰에 연결짓는 것 역시 제어 계층의 몫이다. 
 * 손님이 바다가재 요리를 요청했을 때 종업원은 그 요리가 서비스 가능한 것인지 또한 누구에게 시키면 되는지를 알고 있어야 한다는 뜻이다. 요청을 전달받은 요리사가 바다가재 요리를 주면 그것을 식탁까지 운반해 주는 것 역시 종업원의 몫이다. UI 검증, 요청 및 응답 전달, 로직에서 던져진 예외 처리, 도메인 모델을 뷰와 연결하기 등의 고유 기능 외에는 어떤 기능도 포함하지 않는다. 
 * ◆ 대안 기술 : 현재 WAF들은 대부분 제어 계층의 핵심 기능을 포함한다. 터빈이나 에스프레소 등이 선전하고 있지만, 스트럿츠와 웹워크가 대세라고 생각된다. 당분간 별다른 대안 기술이 등장할 가능성은 적다. 오히려 스트럿츠를 확장시켜 자사 고유의 프레임워크로 최적화 시키는 작업이 활발히 진행될 것이다. 
 * ◆ 주요 패턴 : Front Controller 패턴, Service to Worker 패턴(또는 Command 패턴), Intercepting Filter 패턴, Application Controller & Context Object 패턴 


3. 비즈니스 로직 계층 
 * ◆ 역할 : 비즈니스 로직은 말 그대로 핵심 업무를 어떻게 처리하는지에 대한 방법을 기술하는 곳이다. 식당에서 종업원이 고객의 요구를 전달해 주면, 재료를 이용해 요리를 만드는 요리사라고나 할까? 비즈니스 로직 계층은 애플리케이션에서 가장 재사용될 확률이 높은 요소이기 때문에 신경 써서 설계해야 한다. 
 * ◆ 기능 : 비즈니스 로직에는 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증 외에도 다양한 부가적인 구현이 추가된다. 트랜잭션 처리라든가, 다른 계층들과 통신하기 위한 인터페이스를 제공한다거나, 해당 계층의 객체들간의 관계를 관리하는 것 등이 그것이다. 
 * 비즈니스 로직 계층에 있어야 할 코드들이 프리젠테이션 계층이나 퍼시스턴스 계층에 여기저기 흩어져 있는 애플리케이션을 찾아보기란 그리 어려운 일이 아니다. 이런 구조는 각각의 계층을 모호하게 만들어 유지보수시 많은 시간을 필요로 하게 만든다. 
 * 가장 신경 써서 개발해야 할 비즈니스 로직에 그동안 신경을 쓰지 못했다는 것. 프리젠테이션 계층과 퍼시스턴스 계층 사이의 다리 역할을 충실히 하도록 함으로써 애플리케이션에 유연성을 더하는 것. 그것이 스프링이 탄생하게 된 배경이라고 할 수 있다. 
 * ◆ 대안 기술 : 지금까지 비즈니스 로직의 구현은 크게 EJB를 사용하는 것과 일반 자바 객체(POJO)를 사용하는 것으로 나눌 수 있었다. EJB를 사용하는 경우 개발자들의 많은 불만이 EJB 3.0을 사용함으로써 해결되리라 예상된다. 하지만 해외를 중심으로 해서 EJB를 사용하건, 사용하지 않건 비즈니스 로직들을 체계적으로 관리하는 IoC 컨테이너에 대한 관심이 증가하고 있는 추세이다. IoC 컨테이너에 대해서는 뒤에서 다시 자세히 살펴보도록 하겠다. 
 * ◆ 주요 패턴 : Business Delegate 패턴, Session Facade 패턴, Service Locator 패턴, Application Service 패턴, EJB Home Factory 패턴 

4. 퍼시스턴스 계층 
 * ◆ 역할 : 퍼시스턴스 계층은 데이터 처리를 담당하는 계층이다. 주로 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행하게 된다. 식당으로 보자면 주방장이 사용할 재료를 담당하는 재료 담당자라고나 할까? 이 데이터는 주로 데이터베이스에서 처리되는 경우가 많아, 영속성을 의미하는 퍼시스턴스 계층이란 용어를 사용했다. 하지만 데이터가 처리되는 다른 업무 시스템이나, 웹 서비스, XML, 파일 시스템 등을 모두 고려한다면 레거시 개념을 갖는 EIS 계층이란 표현이 더 적합할 것이다. 
 * ◆ 기능 : 이 계층에서 수행하는 일은 관계형 정보를 저장하고, 수정/삭제하는 것과, 그러한 일을 수행하는 데 필요한 질의문을 관리하는 것, 그리고 가져온 관계형 정보를 객체화시키는 일이다. 
 * ◆ 대안 기술 : EJB 사용에 있어서 개발자들이 가장 불만스러워 하는 것은 CMP 방식의 엔티티 빈일 것이다. 그러한 불만은 객체 관계 맵핑(ORM)을 이용한 JDO라는 대안기술을 탄생시켰고, 또한 하이버네이트라는 또 하나의 오픈소스 기술을 실무로 끌여들였다. JDBC를 이용한 DAO 객체를 구성하는 방법도 소규모 애플리케이션에서는 여전히 인기를 끌고 있다. EJB 3.0과 JDO/하이버네이트, 그리고 JDBC를 이용한 POJO 방식 중 어떤 것이 개발자들에게 낙점될 지는 아직 미지수다. 
 * ◆ 주요 패턴 : Data Access Object 패턴, Domain Store 패턴, Sequence Blocks 


5. 도메인 모델 계층 
 * ◆ 역할 : 도메인 모델은 각 계층 사이에 전달되는 실질적인 비즈니스 객체라고 할 수 있다. 식당을 예로 든다면, 음식이 담긴 그릇이라고 비유할 수 있겠다. 
 * ◆ 기능 : 도메인 모델 계층은 흔히 데이터 전송 객체(DTO) 형태로 개발자가 직접 제작해서, 리퀘스트나 세션과 같은 컨텍스트에 담아 넘기게 된다. 하지만 데이터베이스의 모든 정보를 일일이 객체로 만드는 것은 귀찮을 뿐 아니라, 계층간의 통신 과정에서 데이터가 유실될 위험도 있기 때문에 최근에는 도메인 모델을 서비스로 제공하여 자동화하는 경우가 많다. 
 * ◆ 주요 패턴 : Data Transfer Object 패턴, Value List Handler 패턴 
 * 지금까지 엔터프라이즈 시스템을 구축하기 위해 일반적으로 사용되는 다섯 계층에 대해 간단히 정리해 보았다. 뻔한 이야기들을 길게 늘여 쓴 이유는 2가지 사실을 강조하기 위해서이다. 첫째, 각각의 계층은 저마다의 분명한 역할이 존재하며, 그 역할을 충실히 수행할 수많은 대안기술(Alternative)들 사이에서 개발자는 무엇을 선택할 지 결정을 내려야 한다. 둘째, 각각의 기술들은 독립적으로도 충분한 가치를 지니고 있지만, 가장 장점을 발휘하는 제 위치에서 서로 연계되어 사용될 때 그 시너지 효과가 더욱 크다. 





# 자바

## Generic
* 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움이 줄어든다. 자연스럽게 코드도 더 간결해진다. 예를 들면, Collection에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다. 이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다. 
* 또한 api를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.

## wrapper
* 기본 자료형(Primitive data type)에 대한 클래스 표현을 Wrapper class라고 한다. Integer, Float, Boolean 등이 Wrapper class의 예이다. 
* int를 Integer라는 객체로 감싸서 저장해야 하는 이유가 있을까? 일단 컬렉션에서 제네릭을 사용하기 위해서는 Wrapper class를 사용해줘야 한다. 또한 null 값을 반환해야만 하는 경우에는 return type을 Wrapper class로 지정하여 null을 반환하도록 할 수 있다. 
* 하지만 이러한 상황을 제외한 일반적인 상황에서는 Wrapper class를 사용해야 하는 이유는 객체지향적인 프로그래밍을 위한 프로그래밍이 아니고서야 없다. 일단 해당 값을 비교할 때, Primitive data type인 경우에는 ==로 바로 비교해줄 수 있다. 하지만 Wrapper class인 경우에는 .intValue() 메소드를 통해 해당 Wrapper class의 값을 가져와 비교해줘야 한다.

## autoboxing
* JDK 1.5 부터는 AutoBoxing과 AutoUnBoxing을 제공한다. 이 기능은 각 Wrapper class에 상응하는 Primitive data type일 경우에만 가능하다.
```java
List<Integer> lists = new ArrayList<>();
lists.add(1);
```
* 우린 Integer라는 Wrapper class로 설정한 collection에 데이터를 add할 때 Integer 객체로 감싸서 넣지 않는다. 자바 내부에서 AutoBoxing해주기 때문이다.



## OOP 설계 원칙(SOLID)

### SRP(The Single Responsibility Principle); 단일 책임 원칙
* 한 클래스는 하나의 역할만 맡는다. 
* Responsibility: Method
* 어떤 클래스(메소드, 컴포넌트)가 변경되는 이유는 유일해야 한다.

### OCP(Open Close) 개방-폐쇄 원칙
* 확장에 대해 열려있고 수정에 대해 닫혀있다.
  - 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
  - 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
* interface, protocol, standard, HTTP 표준을 rendering 하는 각종 browser 들
* 운전자 -> 자동차 -> 마티즈/소나타(사용자는 마티즈, 소나타를 볼 수 없다.)
* 자바 애플리 케이션 <> JDBC 인터페이스 <> JDBC 드라이버(오라클, MySQL, MS-SQL)

### LSP(Liskov Substitution); 리스코프 교체 원칙
* 이미 언어 상에서 구현되어 있음
* 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 
* 기반 클래스의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
  서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다.
  펭귄은 동물의 한 종류이다.(상속)
* 상위 분류는 하위분류의 종류여야 한다. 하위타입은 그것의 기반 타입에 대해 치환 가능해야 한다.
* 구현 클래스는 인터페이스가 될 수 있어야 한다.
  펭귄은 날 수 있어야 한다.(인터페이스)
  Base Class의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
* 위키피디아 논문: 하위형에서 선행 조건은 강화될 수 없다.
  하위형에서 후행 조건은 약화될 수 없다.
  하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

### ISP(Interface Segregation); 인터페이스 격리 원칙
* 클라이언트는 자신이 쓰지 않는 인터페이스에 의존하지 않는다.(그러니 인터페이스를 더 작게 나눈다.)
* 로버트 마틴: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

### DIP(Dependency Inversion); 의존 관계 역전 원칙
* 상위 수준 모듈이 하위 수준 모듈에 의존하면 안 된다.
* 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙
* 로버트 마틴: 자주 변경되는 구체 클래스에 의존하지 말아야 한다.
* 자동차 -> 타이어(인터페이스) > 스노우타이어

## DAO
- Data Access Object 의 약자로 데이터베이스의 data에 접근하기 위한 객체입니다.
- DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용합니다.
- DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많습니다.
- 그래서 현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드뭅니다.
- 출처: https://lemontia.tistory.com/591 [안녕하세요]

## DTO(Data Transfer Object), VO 차이
- 여기서 말하는 계층간의 의미는 Controller, View, Business Layer, Persistent Layer 
-       전송되는 데이터의 컨테이너이다.
-       VO와 동일하게 데이터를 저장하여 사용하도록 하는 부분에서 필요하다.
-       VO와 비교를 하여 보면 DTO는 같은 시스템에서 사용되는 것이 아닌 다른 시스템으로 전달하는 작업을 처리하는 객체이다.
-       Layer간의 통신 용도로 오가는 객체를 말하기도 한다.
-       현재의 개발 환경에서 보통 데이터는 다음과 같이 흐름으로 이동한다.
- n   서버 측 : Database Column Data -> DTO -> API(JSON or XML) -> Client
- n   클라이언트 측 : Server -> API(JSON or XML) -> DTO -> View or Local Database System

## VO(Value Object)
-       데이터 그 자체로 의미 있는 것을 담고 있는 객체이다.
-       DTO와 동일한 개념이나 차이점은 Read–Only 속성 객체이다.
-       간단한 독립체( Entity )를 의미하는 작은 객체를 의미한다. 
-       관계데이터베이스의 레코드에 대응되는 자바클래스이다.
- n   형태는 Database레코드를 구성하는 필드들을 VO의 Attribute로 하고 해당 변수에 접근 할 수 있는 Getter와 Setter 메소드의 조합으로 클래스를 형성되어진 클래스이다.
- n   거의 불변성을 가지고 equals()로 비교할 때 객체의 모든 값을 비교해야 한다.

### 차이
   - VO : 사용 되는 값이 객체로 표현 되며, 값 변경이 없는 경우를 말한다.
-       DTO : 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용하기 한다.
- 예를 들어 외부 시스템과 데이터 통신을 할 경우에는 DTO로, DB에서 가져오는 Data는 VO로 정의해서 사용한다고 약속을 하면, 향후 DTO/VO를 수정할 경우 좀 더 고민할 여지가 생길것 같다.
- DTO와 VO의 공통점은 넣어진 데이터를 getter를 통해 사용하므로 주 목적은 같습니다. 그러나 DTO의 경우는 가변의 성격을 가진 클래스 입니다(setter 활용). 그에반해 VO는 불변의 성격을 가졌기에 차이점이 있습니다. 



### 예제
```JAVA
DTO a = new DTO(1);

DTO b = new DTO(1);

이라고 했을 때 a != b 이지만,

VO a = VO(1);

VO b = VO(1); 이라고 했을때는 a == b라고 정의하는 형태입니다.

출처: https://itmore.tistory.com/entry/자바-VO-DTO-차이점사용하는-방식이-같다고-똑같다고-생각하지-말자 [IT모아]
```

# 서버

## 세션
* 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다.
* 페이지를 이동해도 사용자의 로그인 상태를 유지하는 기능을 생각해 봅시다. 앞서 살펴본 쿠키를 이용해서 사용자의 아이디와 비밀번호를 쿠키에 저장한다고 가정해 봅시다. 페이지를 이동하여도 쿠키를 통해 아이디와 비밀번호를 서버에 전달해서 서버에서는 사용자를 식별하여 해당 사용자의 로그인 상태를 유지시킬 수 있습니다. 하지만 이렇게 쿠키만을 이용하여 인증을 구현하면 쿠키가 유출, 조작 될 수 있는 보안상 매우 큰 문제가 됩니다. 개인 소유가 아닌 컴퓨터에서 사용할 경우 누구나 그 사용자의 비밀번호를 확인할 수 있고 HTTP로 개인 정보를 주고 받는 것은 매우 위험합니다.
* Session은 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONID(session id)를 저장합니다. 서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장합니다. 보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용합니다.
* 세션 기간 조정 안하면 많은 VMWare가 켜져 있어 서버가 느려질 우려


### 세션의 동작 순서
* 클라이언트가 서버에 처음으로 Request를 보냄 (첫 요청이기 때문에 session id가 존재하지 않음)
* 서버에서는 session id 쿠키 값이 없는 것을 확인하고 새로 발급해서 응답
* 이후 클라이언트는 전달받은 session id 값을 매 요청마다 헤더 쿠키에 넣어서 요청
* 서버는 session id를 확인하여 사용자를 식별
* 클라이언트가 로그인을 요청하면 서버는 session을 로그인한 사용자 정보로 갱신하고 새로운 session id를 발급하여 응답
* 이후 클라이언트는 로그인 사용자의 session id 쿠키를 요청과 함께 전달하고 서버에서도 로그인된 사용자로 식별 가능
* 클라이언트 종료 (브라우저 종료) 시 session id 제거, 서버에서도 세션 제거


### 세션의 특징
* 세션 아이디는 브라우저 단위로 저장되고 브라우저 종료시 소멸됩니다.
* 로그인한 사용자에 대해서만 세션을 생성하는 것이 아닙니다. 따라서 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성됩니다.
* 사용자가 로그인 했는지, 닉네임 등의 사용자가 요청 할 때 마다 필요한 청보들을 세션에 담아두면 사용자 디비에 접근할 필요가 없어서 효율적입니다.

### 세션 보안
* 누군가 어떤 사용자의 세션 아이디를 훔친다면 그 사용자처럼 로그인할 수 있게 됩니다. https를 이용해서 통신 하는 것이 좋고 cookie와 마찬가지로 session의 옵션으로 secure을 true로 주면 https에서만 세션 정보를 주고받을 수 있고 HttpOnly을 true를 주면 js를 통해서 세션 쿠키를 사용할 수 없도록 강제할 수 있습니다.


## 쿠키의 룰
1. 같은 도메인에서만 한정
* 자동적으로 보냄
* 자동적으로 세팅
* 페이스북이 만든 쿠키는 페이스북안에서만 보내질 수 있지만 페이스북의 좋아요 버튼이 들어간 링크에의 쿠키가 페북으로 들어감

### 쿠키
* 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터라고 했습니다. 쿠키의 데이터 형태는 Key 와 Value로 구성되고 String으로만 이루어져 있습니다. 4KB 이상 저장할 수는 없습니다.
* 쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것입니다. (쿠키가 없다면 다음 페이지로 정보를 파라미터로 넘겨줘야 합니다.)
  * ID 저장, 로그인 상태 유지
  * 7일간 다시 보지 않기. (쿠키에 체크한 날짜를 기록하여 다시 방문 했을 때의 시간과 시차를 이용하여 계산)
  * 최근 검색한 상품들을 광고에서 추천
  * 쇼핑몰 장바구니 기능

### 세션과 쿠키의 차이
- 쿠키의 경우는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말한다
- 예를 들자면 ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는데에 사용한다. (IE 인터넷 옵션에서 검색 기록 삭제할때 임시 파일, 열어본 페이지 목록, 쿠키, 저장된 암호 및 웹 양식 정보 삭제라고 되어있지 아니한가)
- 세션은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는것을 말한다.

### HTTP Session 동작 순서
1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.
2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.
3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.

## 클러스터링
* 클러스터란 여러 대의 서버를 네트워크로 연결하여 전체적으로 하나의 서버처럼 보이게 하는 기술이다.
* 클러스터를 구성하면 한 대의 서버가 고장이 나도 다른 서버에서 처리를 계속할 수 있어서 서비스의 신뢰성 확보 가능
* 클러스터 구성은 스토리지의 소유 방법에 따라 공유 스토리지 구성과 데이터 미러 구성으로 크게 나뉜다.

1.  공유 스토리지 구성
* 즉 서버 개수 + 공유 스토리지로 구성
* 여러 대의 서버가 공유하는 스토리지를 마련하여 장애 시에 데이터의 무결성을 확보하는 방
* 공유 스토리지를 마련할 필요가 있지만 확장성이 높아 대규모 시스템에서 많이 채택한다.

2. 데이터 미러 구성
* 모든 서버가 같은 내용을 복사하여 가지고 있음
* 로컬 디스크 볼륨의 복사본을 네트워크로 보냄으로써 장애 시 데이터의 무결성을 확보하는 방식이다.
* 저가로 구축할 수 있어서 소규모 시스템에서 채택한다.

## 하트비트로 서로의 상태를 감시
* 클러스터 구성에서는 클라이언트로부터 오는 트래픽을 가상 IP 주소라는 논리적인 IP 주소로 받는다.
* 클러스터는 이 가상 IP 주소를 액티브 서버로 보냄으로써 서비스의 다중성을 확보한다.
* 액티브 1대 /스탠바이 1대 인 경우 액티브는 하트비트 네트워크라는 전용 네트워크로 스탠바이 서버의 상태를 감시한다.
* 액티브 서버는 장애를 감지하면 가상 IP 주소를 스탠바이 서버에게 전달한다.
* 가상 IP 주소를 넘겨받은 스탠바이 서버는 이제 액티브 서버가 되어 클라이언트로부터 오는 트래픽을 받게 된다.


# 웹
## Get 방식
* GET 방식은 전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송하며 파라미터의 길이가 256바이트를 넘을 수 없지만 본문(Body)이 필요 없기 때문에 전송 속도가 POST 방식에 비해 빠르다.


## Post 방식
* POST 방식은 파라미터 값들을 요청 메시지의 본문(Body)에 담아서 전송하기 때문에 길이의 제약이 없다.
⎼ HTTP 헤더 속으로 정보가 감춰지고 반드시 HTML 폼을 통해서만 사용할 수 있다.

#  데이터베이스
## Transaction
* 트랜잭션(Transaction)은 데이터베이스의 완전성을 보장하기 위한 것입니다.
* 상태를 변화시키기 해서 수행하는 하나의 작업의 단위를 뜻합니다.


### 원자성 (Atomicity)
* all or nothing
 * 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 것을 의미한다.
 * 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

### 일관성 (Consistency)
 * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
 * 일관성 있는 데이터베이스 상태라는 것은 다양한 제약 조건(constraints, cascades, triggers)등에 만족한다는 것이다. - Software Level

### 독립성 (Isolation)
 * 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
 * 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.

### 지속성 (Durability)
 * 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. - Hardware Level
 * 전력문제, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
 * 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
 * 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.


### 트랜잭션(Transaction)을 사용하며 주의해야 할점?
* 언제나 얻는 것이 있으면 잃는 것도 있다.
* 트랜잭션은 데이터를 완전성을 보장하기 위해 많은 자원들을 사용하게 된다. 자원을 사용하며 Lock을 걸게 되면 다른 사용자들은 Lock이 해제될 때까지 기다려야한다. 기다린다는 것은 성능에 좋지 않다는 의미이다. 따라서 Transaction의 범위를 최소화하여 적용하는 것이 좋다.


## 오라클
- MySQL과 달리 오라클은 대용량 데이터 베이스라고 하는데, 대용량 데이터 타입(CLOB; 4GB까지 가능) 까지 가질 수 있다.


## to_char 규칙
- 자바, C언어, 자바스크립트 등 언어마다 날짜 format이 다른데 그때마다 변환하기는 복잡하니 언어끼리는 String으로 교환하고 마지막에 오라클에서 to_char로 바꿔날짜로 바꿔주면 다른 코드들도 짧아지고 편해진다.
- 넘겨주기 전 언어가 Comparable, Serializable 등 기능을 가진 언어여야 함.(객체지향 언어는 대부분 보유; PHP같은 언어는 안됨)
- ① 형식 모델은 단일 따옴표로 묶어야 하며 대소문자를 구분한다. 
- ② 형식 모델은 임의의 유효한 날짜 형식 요소를 포함할 수 있지만 쉼표를 사용하여 날짜값을 형식 모델과 구분해야 한다. 
- ③ 자동으로 출력의 일 및 월 이름은 공백으로 채워진다. 
- ④ 채워진 공백을 제거하거나 선행 0 fmt . 을 출력하지 않으려면 채우기 모드 요소를 사용한다
