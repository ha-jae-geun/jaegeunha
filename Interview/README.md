

# 알고리즘 
* 버블(쓰레기), 선택정렬  -> 삽입(best n) -> 셀정렬(보완)
* 분할정복: 병합정렬, 퀵정렬(합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다, 배열의 병합정렬과 달리 추가 메모리 공간을 필요로 하지 않는다)
* 기타: 힙(가장 큰 값 몇개 필요할 때)

## 버블 정렬  n2 n2 n2
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
* 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
 * N * (N + 1) / 2  여서 O(N2) 이지만 가운데 스왑을 계속 해주어야 해서 삽입정렬보다도 실질적으로 안좋은 제일 안좋은 정렬
* https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html


### 장점
* 구현이 매우 간단하다.

### 단점
* 순서에 맞지 않은 요소를 인접한 요소와 교환한다.
* 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
* 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
* 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.


## 삽입 정렬  n n2 n2
 * 자신보다 앞의 원소가 큰지 작은지 비교를 하여서 자신의 위치를 찾아서 '삽입' 하는 정렬입니다.
 * 앞의 원소를 비교해야 하기 때문에 arr[1]~arr[n] 까지 진행합니다. (두번째 원소인 arr[1] 부터 시작.)
 * 삽입을 하면 데이터가 하나씩 밀려야 하기 때문에 배열이 길어질수록 효율이 떨어집니다.

### 장점
* 안정한 정렬 방법
* 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
* 대부분위 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.

### 단점
* 비교적 많은 레코드들의 이동을 포함한다.
* 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.
* https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html

## 선택정렬  n2 n2 n2
 * 제자리 정렬(in-place sorting) 알고리즘의 하나
 * 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법
 * 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
 * 첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.
 * 두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.
 * 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 가장 작은 값을 찾아 첫 번째에 놓고, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.
* 1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로 그 다음 회전에서는 두 번째 자료를 가지고 비교한다. 마찬가지로 3회전에서는 세 번째 자료를 정렬한다.
 
### 과정 설명
 * 주어진 배열 중에서 최솟값을 찾는다.
 * 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
 * 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
 * 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.
 * https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html


### 장점
* 자료 이동 횟수가 미리 결정된다.

### 단점
* 안정성을 만족하지 않는다.
* 즉, 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있다.
* https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html

## 퀵 정렬  nlogn, nlogn n2
* 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
* 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.

 - 장점
 * 속도가 빠르다.
 * 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
 * 추가 메모리 공간을 필요로 하지 않는다.
 * 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
 - 단점
 * 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
 * 퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
 * EX) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다.


### 퀵정렬 과정
 * 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
 * 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
 * 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
 * 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
 * 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
 * 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
 * 리스트의 크기가 0이나 1이 될 때까지 반복한다.
 * 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
 * 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
 * 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
 * 순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
 * https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html

### 퀵 정렬 단계


### 장점
* 속도가 빠르다.
* 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
* 추가 메모리 공간을 필요로 하지 않는다.
* 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.

### 단점
* 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
* https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html

## 힙 정렬  nlogn nlogn nlogn
 * - 사실 선택 정렬과 거의 같은 알고리즘으로. 단지 가장 큰 원소를 뒤로 보내는 데에 단순히 매번 쭉 돌면서 알아내느냐 힙을 사용하여 알아내느냐가 유일한 차이점이다.
 * 힙정렬은 추가적인 메모리를 전혀 필요로 하지 않는다는 점과, 최악의 경우에 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(nlgn) 정렬의 성능을 발휘하는 장점이 있다. 하지만 실제 코드를 짜서 비교를 해 보면 퀵정렬이 힙정렬보다 일반적인 경우에 빠르게 동작한다.
 * 그러나 아래 퀵정렬의 경우 피벗을 잡는 전략에 어느 정도의 휴리스틱이 들어가야 최악의 경우를 회피할 수 있으나 힙정렬은 휴리스틱이 필요없이 항상 일정한 성능을 보이는 장점이 있다. 즉 알고리즘에 꼼수를 쓰지 않고, 각종 하드웨어 가속도 전혀 고려하지 않고 알고리즘이 정의하는 최소한만 구현할 경우 힙정렬이 가장 안정적인 성능을 보인다.

## 삽입(n, n2, n2), 힙(nlogn), 선택정렬(n2)
* 삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.


## 쉘정렬  n n1.5  n2
* 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 ‘간격(gap)’ 이라고 한다.
* 간격의 초깃값: (정렬할 값의 수)/2
* 생성된 부분 리스트의 개수는 gap과 같다.
* 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
* 간격은 홀수로 하는 것이 좋다.
* 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.
* 간격 k가 1이 될 때까지 반복한다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html

### 쉘 정렬이 나온 이유
* 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안
* 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동
* 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있다.
* 삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html


### 장점
* 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.
* 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬보다 더욱 빠르게 수행된다.
* 알고리즘이 간단하여 프로그램으로 쉽게 구현할 수 있다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html

## 병합정렬  nlogn, nlogn nlogn
* ‘존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법
* 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
* 분할 정복(divide and conquer) 방법
* 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
* 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.

### 과정 설명
* 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
* 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
* 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
* 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.


### 과정
* 2개의 정렬된 리스트를 합병(merge)하는 과정
* 2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮긴다.
* 둘 중에서 하나가 끝날 때까지 이 과정을 되풀이한다.
* 만약 둘 중에서 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 값들을 전부 새로운 리스트(sorted)로 복사한다.
* 새로운 리스트(sorted)를 원래의 리스트(list)로 옮긴다.
https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


### 단점
* 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
* 제자리 정렬(in-place sorting)이 아니다.
* 레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

### 장점
* 안정적인 정렬 방법
* 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
* 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
* 제자리 정렬(in-place sorting)로 구현할 수 있다.
* 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.
* https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html


## 힙정렬
* 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조
* 최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조
* 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
* 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.

### 과정 설명
* 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
* 내림차순을 기준으로 정렬
* 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
* 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.


1. 내림차순 정렬을 위한 최대 힙(max heap)의 구현
* 힙(heap)은 1차원 배열로 쉽게 구현될 수 있다.
* 정렬해야 할 n개의 요소들을 1차원 배열에 기억한 후 최대 힙 삽입을 통해 차례대로 삽입한다.
* 최대 힙으로 구성된 배열에서 최댓값부터 삭제한다.

2. 최대 힙(max heap)의 삭제
* 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
* 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
* 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
* 힙을 재구성한다.
* 아래의 최대 힙(max heap)에서 최댓값을 삭제해보자. 

### 장점
* 시간 복잡도가 좋은편
* 힙 정렬이 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때 이다.


## Hash Index와 Tree Index 비교 ??

# OS

## 리눅스
* 무료고 오픈소스라서 다양한 소프트웨어가 돌아감
* 콘솔에서 소프트웨어 설치 가능
* 코드는 오픈소스 무료이고 깃허브에서 코드 볼수 있고 파일을 커스터마이징 가능
* 아마존 서버는 리눅스 서버에서 돌아감

## 데드락 문제
* - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다.
* - 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황이 발생 할 수 있습니다. 어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 대기 상태로 들어 가게됩니다. 대기 상태로 들어간 프로세스들이 실행 상태로 변경 될 수 없을 때 이러한 상황을 교착 상태라 합니다.

### 예제
* P1과 P2가 리소스 A, B 둘 다를 얻어야 한다고 가정할 때, t1에 P1이 리소를 A를 얻고 P2가 리소스 B를 얻었다면 t2때 P1은 리소스 B를, P2는 리소스 A를 기다리게 됩니다. 하지만 서로 원하는 리소스가 상대방에게 할당되어 있기 때문에 이 두 프로세스는 무한정 기다리게 되는데 이러한 상태을 DeadLock상태라고 합니다.


### 데드락 (Dead lock)의 발생 조건

- 교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립 할 때 발생합니다
- 따라서, 아래의 네 가지 조건 중 하나라도 성립하지 않도록 만든다면 교착 상태를 해결할 수 있습니다.

1. 상호 배제 (Mutual exclusion)
- 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

2. 점유 대기 (Hold and wait)
- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

3. 비선점 (No preemption)
- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

4. 순환 대기 (Circular wait)
- 프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.

 

### 데드락 (Dead lock) 처리

1. 교착 상태 예방(Prevention): 교착 상태 발생 조건 중 하나를 제거함으로써 해결하는 방법
- 자원의 낭비가 심하다.

#### 상호 배제 (Mutual exclusion) 부정
- 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.

#### 점유 대기 (Hold and wait) 부정
- 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.

#### 비선점 (No preemption) 부정
- 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.

#### 순환 대기 (Circular wait) 부정
- 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.



2. <회피(Avoidance)법>: 교착 상태가 발생하면 피해나가는 방법

- 은행원 알고리즘 (Banker’s Algorithm)

* E,J,Dijkstra가 제안한 방법으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법이다.
* 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법
* 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기함
* 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 이용하는 방법



3. 교착 상태 탐지 및 회복 : 교착 상태가 되도록 허용한 다음에 회복시키는 방법


* 교착 상태 무시
	* 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다. **

* < 교착 상태 탐지 (Detection) >
	- 자원 할당 그래프를 통해 교착 상태를 탐지할 수 있다.
	- 자원 할당 그래프 예시
	- - 자원을 요청할 때마다 탐지 알고리즘을 실행하면 그에 대한 오버헤드가 발생한다.
	- 출처: https://jwprogramming.tistory.com/12 [개발자를 꿈꾸는 프로그래머]


4. < 교착 상태로부터 회복 (Recovery) >
- 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복하는 것을 의미한다.
- 프로세스를 종료하는 방법
	1. 교착 상태의 프로세스를 모두 중지
	2. 교착 상태가 제거될 때까지 한 프로세스씩 중지


- 자원을 선점하는 방법
	1. 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 해당 프로세스를 일시 정지 시키는 방법
	2. 우선 순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점한다.


# 웹
## XML과 JSON 비교 ??

# jQuery
 * jQuery 1.x
- 모든 브라우저 지원
- jquery-migrate-1.2.1, jquery-1.11.2 + min 파일

jQuery, migrate 차이

# * 자바 스크립트에서 Jquery가 나온 이유
1. 못생긴 코드
2. 멍청한 브라우저들
	* JQuery는 브라우저 호환성도 관리
* 하지만 자바스크립트 ES6, ES7 덕분에 위의 문제 해결

# 자바 스크립트
- 웹 솔루션 개발자: 폼 제어
- 스크립트 언어: 뷰, 자바, 파이썬: DB 연동
- 자바 스크립트 -> jQuery로 css, html 조종
- 즐겨찾기 -> 파이썬 라이브러리(크롤링; document) -> jQuery -> 탐색 기능

# jQuery
- : jquery는 모질라 소속이었던 John Resig이 개발한 라이브러리로 현재 가장 인기 있는 자바스크립트 라이브러리 중 하나로 꼽히고 있다. jquery 자체에 대한 이야기를 많이 하지는 않을 것이니 아직 jquery를 한번도 접해보지 않은 사람이라면 위의 사이트를 방문해서 간단하게 둘러보는 것도 괜찮을 것이다.
- 기존에 자바스크립트로 사용했던 DOM 탐색의 경우 끽해야 id 탐색, class 이름과 태그명으로 탐색했었는데 이러한 것들을 CSS 의 검색 스타일로 너무나 쉽게 적용을 해서 나타난 것이다.

# jQuery의 장점
- 그렇다면 jquery의 가장 큰 장점이 무엇이라고 생각하는가? jquery를 사용해본 사람이라면 단축된 문법이라던가 여러 가지 말을 하는 것보다는 '멀티 브라우져 지원'을 말할 것이다. 어느 브라우져에서나 동일하게 작동을 한다는 것은 자바스크립트 개발자로서는 너무나 매력적인 일이다. 특히 IE의 독자노선 행보로 인해 IE와 다른 브라우져들은 자바스크립트에서 지원하는 기능이 다르거나, 같은 기능이 있더라도 사용 방법이 다른 경우 jquery에서는 이것을 전부다 해결해준다는 것이 제일 큰 장점이라고 말할 수 있을 것이다.
- 멀티 브라우져에서의 ajax이용, 이벤트 설정, DOM 탐색이야말로 jquery의 핵심적인 기능인 것이다.
- 또 다른 장점은 바로 간단하게 이용할 수 있는 핵심 기능들을 포함하고 있다는 것이다. 다른 것보다도 아마 가장 많이 이용할 기능은 바로 toggleClass나 removeClass가 아닌가 생각한다. 일을 할 수 밖에 없게 되는 것을 toggleClass 하나로 해결하게 된 것이다. addClass는 그냥 += 을 이용하면 간단하게 해결되지만 제한된 상황이 아닌 용도에서 정규표현식을 잘 모르면 indexOf, replace, substring 등등 매우 복잡하고 무거운 함수를 만들어야 할 것이다.
- 특히, jquery-mobile을 이용해본 사람이라면 모든 모바일 단말에서의 똑같은 UI와 동작으로 인해 그 매력에 빠졌을지도 모른다. 단순히 attribute를 설정해주는 것만으로 UI들이 바로바로 적용되는 놀라운 기능들을 소개해주고 있다. 물론, 그 디자인을 보게 되면 너무나 투박하기 짝이 없기는 하지만 말이다.



## jQuery 단점
- 하지만 언제나 만능은 없는 법. jquery도 단점은 있기 마련이다. 무엇보다도 jquery라는 라이브러리를 이용하기 위해 새로운 API를 학습해야한 다는 것이 큰 이슈일 것이다. 이는 jquery를 한번도 접해보지 않은 사람이 처음으로 jquery를 보고 겪게 되는 그 충격을 기억하고 있다면, 공감할 수 있을 것이다. 게다가 그것에 자바스크립트라는 언어를 잘 모를 때, 겉핥기 정도로 밖에 모를 때 이것은 큰 이슈일 것이다. 심지어는 jquery를 자바스크립트가 아닌 새로운 하나의 언어로 받아들이게 되는 지경이 될지도 모른다. (처음에 실제로 그렇게 느꼈었다. 이건 자바스크립트가 아닌것 같았다.) 게다가 API로 기존의 자바스크립트와는 상이하기 때문에 효과적으로 사용하기 위해서는 jquery API를 별도로 공부해야하기까지 한다.
- 뭐, 위의 단점은 충분히 극복이 가능한 단점이지만, jquery로 극복하지 못하는 아주 큰 단점이 하나 있다. 바로 퍼포먼스의 문제이다. 어플리케이션마다 다른 요구사항에 최적화를 하기 위해서는 직접 jquery를 파고 들어가야하는 경우도 있을지도 모른다. 물론 이러한 최적화는 라이브러리를 잘 구성해 놓은 jquery에서는 큰 고민이 아닐지도 모르지만, 그것보다도 더 큰 퍼포먼스의 문제는 32k나 되는 용량의 문제이다. gzip까지 했는데도 32k라는 용량을 왠만한 사이트 자바스크립트의 전체를 합친양 정도 될지도 모른다. 그런데 단순히 한두 기능을 사용하려고 jquery 전체를 가져오는 것은 너무나도 비효율적인 투자다.
- jquery의 $ selector는 document.querySelector와 document.querySelectorAll을 통해서도 충분히 구현이 가능하고, 멀티브라우져 ajax와 event 핸들러는 함수 몇가지만 이용하면 쉽게 구현이 가능하다. toggleClass와 removeClass 또는 regular expression을 이용하면 3-4줄이면 가능하다. 1k이면 충분히 해결하고도 남는 기능들만을 사용하기 위해 32배가 넘는 용량을 가져오는 것은 지양해야할 것이다. 또 다른 예로 document.getElementById 이런 구문 백번이면 될 간단한 자바스크립트를 $로 표현하기 위해 jquery를 가져오는 것은 배보다 배꼽이 커지는 실수인 것이다. 하지만 퍼포먼스가 그다지 필요하지 않은 웹페이지라면 이러한 단점들도 그다지 커지지는 않는다.


## 왜 jquery를 사용하는가?
- 그러면 다시 제목의 질문으로 돌아와서 왜 jquery를 사용하는가? 하는 질문을 하고 싶다. jquery를 쓰기 좋을 때는 멀티브라우져 지원, 이벤트+애니메이션+복잡한 CSS 변환+AJAX의 기능 모두를 다양하게 사용할 때, 그리고 위의 기능들을 구현할만한 시간적 여유가 없고 jquery에 대해서 이미 알고 있을 때. 그리고 무엇보다도 페이지가 퍼포먼스를 크게 요구하지 않고 사용자와의 인터렉션이 많지 않을 때 사용해야할 것이다.
- 그리고 반대로 자바스크립트에 대해 충분히 이해하고 jquery의 소스를 볼줄 안다면, jquery의 소스를 전부다 가져오는 것 보다는 일부 기능만 가져오거나 그 구현을 보고 자기만의 라이브러리를 만드는 것이 웹페이지의 퍼포먼스상 도움이 많이 될 것이다.
- 인터넷 속도가 1Gbps까지 올라가는 시대에 고작 32k를 가지고 퍼포먼스를 이야기하는 것도 웃긴 이야기지만, 이것은 http request가 하나 더 늘어난다는 점, 페이지의 구동이 느려진다는 점, 이후 최적화가 부족하다는 점이 완제품인 jquery를 가져오는 것의 단점이라고 말할 수 있다. 또한 중요한 것은 인터넷 속도 뿐만아니라 자바스크립트가 실행되는 브라우져 자체의 속도이기도 한데, 이것을 최적화하기 위해 jquery가 웹페이지의 목적에 맞게 튜닝이 되어있는지 뒤지는 것보다는 최적화된 자기의 라이브러리를 만드는 것이 훨씬 더 빠를 것이기 때문이다.
- : 하지만 분명한 것은 jquery는 최적화가 잘 된 좋은 라이브러리이며 멀티브라우져 지원에 대해 고민할 필요를 없애주는 너무나 고마운 라이브러리라는 것이지만, 페이지의 궁극적인 목적에 따라 그 사용 여부를 조심스럽게 결정을 해야한다는 것이다.

## jQuery 조심해야 할 점
- jQuery 라이브러리(jquery-1.11.2.min.js)를 HTML 문서 내에 포함하는 방법은 일반적으로 head 태그 내에 스타일 시트를 읽어들인 다음 자바스크립트를 읽어 들이는 순서를 따르며 이 때 다른 스크립트를 로드하기 전에 jQuery 스크립트를 우선하여 로드해야 한다.
- ⎼head 태그에 기술한 jQuery는 적용이 되지 않는데 그 이유는 브라우저 내의 HTML 인터프리터에 의해서 DOM 트리가 생성되기 전에 span 엘리먼트를 검색하려고 시도했기 때문이다. 
- addClass(className) 메서드는 jQueη 메서드로 style 태그 내부에 기술한 .className으로  정의된 클래스를 해당 엘리먼트에 추가하는 기능으로 메서드의 특징은 다음과 같다.





# '웹 크롤링', '스크래핑'

# 크롤링
* (2) 크롤링 크롤링은 웹 사이트를 정기적으로 돌며 정보를 추출하는 기술이다. 크롤링하는 프로그램을 크롤러 또는 스파이더라고 한다. 
* 크롤링으로 웹 정보를 추출할 때는 반드시 하나의 특정 웹 페이지의 URL 주소를 명시해주어야 한다. 가장 먼저 방문하는 URL은 중요한 역할을 하는데 뒤이어 크롤링 되어야할 웹 페이지의 URL은 웹 페이지가 링크하고 있는 웹 페이지를 순차적으로 방문한다. 

# 스크레핑
* (3) 스크레이핑 스크레이핑은 웹 사이트에 있는 특정 정보를 추출하는 기술이다. 스크레이핑은 웹에서 자료를 추출 하는 것 뿐만 아니라 구조도 분석한다. 스크레이핑은 로그인해서 필요한 웹 페이지에 접근 하는 기술이 필요하다. 
* 시스템이나 웹사이트에 있는 정보(데이터) 중에서 필요한 정보를 추출 및 가공하여 제공하는 소프트웨어 기술입니다. 이는 고객이 한 번만 자신의 정보 제공을 인증하게 되면 컴퓨터가 대신하여 필요한 고객 정보들을 자동으로 추출하여 제공하는 것을 말합니다. 

## 뱅크 샐러드
* 뱅크샐러드라는 하나의 애플리케이션을 통해 고객은 자신의 카드사 및 은행, 보험정보들을 한번에 조회할 수 있습니다.

## 스크래핑 종류
* 금융위는 또 서버에 저장하고 관리해 문제가 있다고 거론하는데 이는 서버형 스크래핑이다. 이를 이용하는 업체는 일부인데, 기술력을 보유한 스크래핑 개발업체는 이 방식을 지양하고 있다. 서버형 보다는 클라이언트형 스크래핑을 활용한다. 스마트폰 보급률이 높기 때문이다. 스마트폰에 저장된 개인 인증서를 스크래핑 엔진이 있는 업체에게 곧바로 가기 때문에 제3자가 개인정보를 보거나 유출하기 힘들다. 또 최근 정보 유출 사고 사례 중 스크래핑에 의한 경우는 없었다."
* "API는 무조건 안정적이며 스크래핑은 안정적이지 않다는 비교는 하기 어렵다. 스크래핑은 지속적으로 보안성을 높이는 기술을 개발하고 업그레이드해왔다. 다만 스크래핑은 대상 사이트의 보안정책을 준수하지만, 통신프로토콜을 적용한 API방식은 보안성이 뛰어난 것은 사실이다.


# 은행
## OTP
* OTP(One Time Password)발생기는 전자금융 거래에서 사용되는 일회용 비밀번호 생성 기기로 1분마다 새로운 비밀번호가 생성되어 해킹이나 외부노출의 위험으로부터 안전하게 서비스를 이용하실 수 있습니다.
* 보안카드 불편성 해결(앞자리 뒷자리, 비밀번호 3개 입력),  OTP는 6자리 비밀번호 그대로 입력
* 1분마다 새롱누 6자리 비밀번호 생성

## OTP 단점
* 하지만, 전원문제로 소진이 되면 보안카드 보다 훨씬 더 불편함을 발생할 수 있는데 이를 감추었다고 할 수 있다. 이 같은 상황은 국내 은행들이 발행하는 OTP 비밀번호 발생기는 3V 배터리가 내장되어 밀봉된 형태로, 배터리가 소진하면 재사용이 불가하고, 은행으로부터 새로운 기기를 수령해야 하며, 결과적으로 OTP도 새롭게 등록해야 합니다.
* 반면, 영국은행에서 지급되는 OTP는 국내은행과는 다른 형태의 기기를 제공한다. 사실상 우리의 공인인증서 역할을 함께 한다고 할 수 있다. 그 차이점은 단말기에 '사용자 확인(Identify), 서명(sign), Response등 복합적인 기능을 한꺼번에 처리가 가능하다. 그리고, 우리 개인용 OTP와는 달리, 키패드도 내장되어 있어서, 필요한 번호를 입력함으로써 보안성을 높였다고 할 수 있다.



# N
## thin client
 CPU, 메모리 등 필수적인 하드웨어 장치만 탑재해 네트워크로 연결된 중앙서버에서 모든 업무를 관리하도록 설계된 업무용 PC를 일컫는다.

## vm


## RDP

## Spice

# 가상화 업체 VDI 개발 현황
 
## 가. Citrix
- Citrix의 XenDesktop은 XenServer를 이용하여 공용 또는 전용 VM(Virtual Machine)을 제공하며, 사용자 단말에서 구동되는 XenClient나 스트리밍 VHD(Virtual Hard Disk) 방식을 지원하는 XenApp을 이용한 원격 또는 스트리밍 방식을 지원한다.
 
## 나. VMware
- VMware의 VMware View는 서버 가상화 기술인 vSphere와 통합되어 RDP과 PCoIP 원격 디스플레이 프로토콜을 지원한다. 또한 오프라인으로 가상 데스크톱을 사용할 수 있는 로컬 모드 View는 온라인 가상 데스크톱과 동기화시키는 방식을 사용한다.
 
## 다. Microsoft
- Microsoft는 가상화 플랫폼인 Hyper-V에 RDS(Remote Desktop Services)와 RDVH(Remote Desktop Virtualization Host)를 통합하고 원격 디스플레이 프로토콜로는 RDP를 지원해 가상 데스크톱 인프라 기술을 제공한다.
 
## 라. Oracle
- Oracle에서는 가상 데스크톱 인프라 기술로 Sun Ray 가상 데스크톱 세션 관리 기술과 가상화 플랫폼인 Oracle VDI 하이퍼바이저 기술을 개발하였다. Oracle의 기술은 VMware vCenter, Microsoft Hyper-V, Microsoft RDS를 지원한다.
 
## 마. 공개 SW
- 공개 SW 커뮤니티 중심의 개발 사례로는 RedHat이 오픈 소스 원격 디스플레이 프로토콜인 SPICE(Simple Protocol for Independent Computing Environments)를 데스크톱 가상화에 적용하였으며, Ulteo에서는 Debian과 Ubuntu 기반의 오픈 소스 VDI 솔루션을 제공한다. 
CloudStack.com은 클라우드 IaaS(Infrastructure as a Service) 플랫폼 솔루션을 통한 VDI 클라우드 인프라 구축을 지원하고 있다.


# 회기분석
* 회귀분석은 독립변수와 종속변수 사이의 구체적인 함수식을 찾아내고, 독립변수로부 터 종속변수를 예측하는 데 그 목적이 있다.
* 선형회귀, 다중회귀분석

## 독립변수
- 독립변수는 연구자가 의도적으로 변화시키는 변수를 말합니다.
- 독립변수는 영어로 Independent variable입니다. 말 그대로 독립적인 변수입니다. 통계에서 독립적이라는 말은 다른 변수에 영향을 받지 않는다는 뜻입니다. 따라서 독립변수는 다른 변수에 영향을 받지 않습니다. 오히려 종속 변수에 영향을 주는 변수 입니다. 
* 회귀분석에서 다른 변수에 영향을 주는 원인에 해당하는 변수를 독립변수(independent variable) 또는 설명변수(explanatory variable)라고 하며

## 종속변수
- 영향을 받는 결과에 해당하는 변 수를 종속변수(dependent variable) 또는 반응변수(response variable)라고 한다. 
- 종속변수는 연구자가 독립변수의 변화에 따라 어떻게 변하는지 알고 싶어하는 변수를 말합니다.
- 그렇다면 종속변수는 무엇일까요? 종속변수는 영어로 Dependent variable 입니다. 말 그대로 종속적인 또는 의존적인 변수입니다. 즉 독립변수에 영향을 받아서 변화하는 변수를 종속변수라고 생각하시면 됩니다. 
- 조금 어렵나요? 더욱 쉽게 설명하면 독립변수는 연구자가 마음대로 조정할 수 있는 변수입니다. 왜 일까요? 바로 독립변수가 어떻게 변화하느냐에 따라 종속변수가 어떻게 변화하는지 보고 싶기 때문이죠. 이 때문에 독립변수는 원인변수 (Explanatory variable), 예측 변수 (Predictor variable)라고 부르기도 합니다. 반면에 종속 변수는 연구자가 알고 싶어하는 변수입니다. 연구자의 목표는 독립변수를 조정하여 변화시킬 때 종속변수가 어떻게 변화하는지 알아내는 것 입니다. 이 때문에 종속변수를 반응 변수 (Response variable), 결과 변수 (Outcome variable)이라고 부르기도 합니다. 

## MAE
* Mean absolute error
* -통계에서 평균 절대 오차는 두 연속 변수의 차이를 측정 한 것입니다

# 판다스, 맷플롯립
## 판다스
1. 시리즈(Series): 시리즈 클래스는 1차원 배열의 값(values)에 각 값에 대응되는 인덱스(index)를 부여할 수 있는 구조를 갖고 있습니다.
2. 데이터프레임(DataFrame): 은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스(index)와 열방향 인덱스(column)가 존재합니다. 즉, 행과 열을 가지는 자료구조입니다. 시리즈가 인덱스(index)와 값(values)으로 구성된다면, 데이터프레임은 열(columns)까지 추가되어 열(columns), 인덱스(index), 값(values)으로 구성됩니다.
3. 패널(Panel)

## 넘파이
* Numpy(보통 "넘파이"라고 발음.)는 수치 데이터를 다루는 Python 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.

## 사이킷런
*  머신러닝 학습용 패키지다. 대부분의 머신러닝 모형을 제공하므로 파이썬으로 머신러닝을 공부하는 데 최적의 학습 도구다.
* https://book.coalastudy.com/data-science-lv1/week3/stage3

### Training set
* 모델의 학습에 사용되는 데이터

### Validation set
* 모델 제작 과정 중, 학습된 모델의 성능을 측정하기 위한 데이터
### Test set 모델의 최종 성능을 평가하기 위한 데이터
* 모델의 최종 성능을 평가하기 위한 데이터


## 맷플롯립
* Matplotlib는 데이터를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이해를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.

## Seaborn¶
* Seaborn("시본"이라고 읽는다) 패키지는 Matplotlib 패키지에서 지원하지 않는 고급 통계 차트를 그리는 통계용 시각화 기능을 제공한다.



# 신경망 알고리즘
* Artificial neural network (ANN)는 딥 러닝의 가장 핵심적인 기술로써, 신경 세포인 neuron을 추상화한 artificial neuron으로 구성된 네트워크이다. ANN은 일반적으로 어떠한 형태의 function이든 근사할 수 있는 universal function approximator로도 알려져 있다. 이 글에서는 ANN을 구성하는 가장 작은 요소인 artificial neuron부터 multi-layer ANN과 이를 학습시키기 위한 algorithm에 대해 서술한다.
* 일반적으로 사용되는 기본적인 인공신경망 알고리즘인 다층인공신경망(multi-layer neural network)의 경우 아래 그림과 같이 입력층(input layer), 은닉층(hidden layer), 그리고 출력층(output layer),이렇게 세가지 층으로 구분이 됩니다. 그리고 각 층들은 노드들로 구성되어 있습니다. 아래 그림의 예에서는 입력층은 4개의 노드, 은닉층은 3개의 노드, 그리고 출력층은 1개의 노드를 가지고 있습니다.
* 입력층은 예측값(출력변수)을 도출하기 위한 예측변수(입력변수)의 값들을 입력하는 역할을 합니다. 만약 n개의 입력 값들이 있다면 입력층은 n개의 노드를 가지게 됩니다. 은닉층은 모든 입력노드부터 입력값을 받아 가중합을 계산하고, 이 값을 전이함수에 적용하여 출력층에 전달하게 됩니다. 각 입력노드와 은닉노드들은 모두 가중치를 가지는 망으로 연결되어 있으며 은닉노드와 출력노드도 마찬가지로 연결되어 있습니다.
* 이 가중치는 연결강도로 표현되며 랜덤으로 초기에 주어졌다가 예측 값을 가장 잘 맞추는 값으로 조정되게 됩니다. 전이함수는 비선형함수를 사용하게 되며, 이러한 전이함수를 통하여 출력층에 예측 값이 전달되기 때문에 인공신경망이 비선형 모델로서 역할을 할 수 있게 됩니다.
* https://blog.lgcns.com/1359

## 의사결정트리
* 의사결정나무는 데이터를 분석하여 이들 사이에 존재하는 패턴을 예측 가능한 규칙들의 조합으로 나타내며, 그 모양이 ‘나무’와 같다고 해서 의사결정나무라 불립니다. 질문을 던져서 대상을 좁혀나가는 ‘스무고개’ 놀이와 비슷한 개념입니다. 한번 예를 들어볼까요?
* 의사결정나무는 분류(classification)와 회귀(regression) 모두 가능합니다. 범주나 연속형 수치 모두 예측할 수 있다는 말입니다. 의사결정나무의 범주예측, 즉 분류 과정은 이렇습니다. 새로운 데이터가 특정 terminal node에 속한다는 정보를 확인한 뒤 해당 terminal node에서 가장 빈도가 높은 범주에 새로운 데이터를 분류하게 됩니다. 운동경기 예시를 기준으로 말씀드리면 날씨는 맑은데 습도가 70을 넘는 날은 경기가 열리지 않을 거라고 예측합니다.


## 텍스트와 이미지 딥러닝 기법
* 텍스트 인식 기능, 이미지 딥러닝: 


# SPRING 
## EJB

## POJO

## IOC

## FACTORY 패턴

## SINGLE톤

## FRONT CONTROLLER



# MVC 패턴 로직
1. 프리젠테이션 계층 
 * ◆ 역할 : 프리젠테이션 계층은 말 그대로 사용자 인터페이스에 불과하다. 식당을 예로 들면 손님이 접하게 되는 메뉴판과 전달될 음식을 차려놓는 식탁에 해당한다. 
 * ◆ 기능 : 사용자가 선택할 수 있는 기능이 표시되어 있어야 하고, 요청에 필요한 부가적인 정보 전달을 위한 입력 양식이 있어야 한다. 또한 전달된 자료를 효과적으로 보여주기 위한 프리젠테이션 로직이 포함된다. 하지만 비즈니스 로직이나 퍼시스턴스 계층에서 처리하는 일을 직접 수행하거나(스크립트 릿 사용), 각 계층의 컴포넌트와 직접적인 통신이 있어선 안된다. 
 * 모든 요청은 제어 계층을 통해 처리되어야 한다는 뜻이다. 고급 레스토랑(엔터프라이즈 시스템)에서는 웨이터(지배인)를 통해서만 요구를 전달하고, 그 결과를 전해들어야 한다. 직접 주방장에게 주문을 하거나 자기가 직접 요리를 하는 것은 자기 집(프로토타입)이나 동네 자장면 가게(소규모 웹 애플리케이션)에서나 가능한 일이다. 
 * ◆ 대안 기술 : 현재 가장 주류를 이루는 기술은 JSP 1.2와 JSTL과 같은 태그 라이브러리를 결합하는 방식이다. 과도기적인 형태로 벨로시티와 타일즈 태그 라이브러리가 결합된 형태도 현재 주목을 받고 있다. 하지만 점차적으로 JSF에 기반한 JSP 2.0에 주류 기술로 옮겨갈 가능성이 크고, 프리젠테이션 계층 개발에 있어서도 JSF를 지원하는 IDE를 채택하는 경우가 늘어날 것이다. 
 * ◆ 주요 패턴 : Composite View 패턴 



2. 제어 계층 
 * ◆ 역할 : 제어 계층은 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 컨트롤러를 제공한다. 식당으로 치자면 지배인의 역할과 종업원의 역할을 병행하는 것이라고 볼 수 있다. 
 * ◆ 기능 : 전체 시스템의 설정 상태를 유지해야 하며, 그를 통해 어떤 요청이 들어왔을 때 어떤 로직이 처리해야 하는지를 결정한다. 사용자 요청을 검증하고 로직에 요청을 전달하는 일과 로직에서 전달된 응답을 적절한 뷰에 연결짓는 것 역시 제어 계층의 몫이다. 
 * 손님이 바다가재 요리를 요청했을 때 종업원은 그 요리가 서비스 가능한 것인지 또한 누구에게 시키면 되는지를 알고 있어야 한다는 뜻이다. 요청을 전달받은 요리사가 바다가재 요리를 주면 그것을 식탁까지 운반해 주는 것 역시 종업원의 몫이다. UI 검증, 요청 및 응답 전달, 로직에서 던져진 예외 처리, 도메인 모델을 뷰와 연결하기 등의 고유 기능 외에는 어떤 기능도 포함하지 않는다. 
 * ◆ 대안 기술 : 현재 WAF들은 대부분 제어 계층의 핵심 기능을 포함한다. 터빈이나 에스프레소 등이 선전하고 있지만, 스트럿츠와 웹워크가 대세라고 생각된다. 당분간 별다른 대안 기술이 등장할 가능성은 적다. 오히려 스트럿츠를 확장시켜 자사 고유의 프레임워크로 최적화 시키는 작업이 활발히 진행될 것이다. 
 * ◆ 주요 패턴 : Front Controller 패턴, Service to Worker 패턴(또는 Command 패턴), Intercepting Filter 패턴, Application Controller & Context Object 패턴 


3. 비즈니스 로직 계층 
 * ◆ 역할 : 비즈니스 로직은 말 그대로 핵심 업무를 어떻게 처리하는지에 대한 방법을 기술하는 곳이다. 식당에서 종업원이 고객의 요구를 전달해 주면, 재료를 이용해 요리를 만드는 요리사라고나 할까? 비즈니스 로직 계층은 애플리케이션에서 가장 재사용될 확률이 높은 요소이기 때문에 신경 써서 설계해야 한다. 
 * ◆ 기능 : 비즈니스 로직에는 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증 외에도 다양한 부가적인 구현이 추가된다. 트랜잭션 처리라든가, 다른 계층들과 통신하기 위한 인터페이스를 제공한다거나, 해당 계층의 객체들간의 관계를 관리하는 것 등이 그것이다. 
 * 비즈니스 로직 계층에 있어야 할 코드들이 프리젠테이션 계층이나 퍼시스턴스 계층에 여기저기 흩어져 있는 애플리케이션을 찾아보기란 그리 어려운 일이 아니다. 이런 구조는 각각의 계층을 모호하게 만들어 유지보수시 많은 시간을 필요로 하게 만든다. 
 * 가장 신경 써서 개발해야 할 비즈니스 로직에 그동안 신경을 쓰지 못했다는 것. 프리젠테이션 계층과 퍼시스턴스 계층 사이의 다리 역할을 충실히 하도록 함으로써 애플리케이션에 유연성을 더하는 것. 그것이 스프링이 탄생하게 된 배경이라고 할 수 있다. 
 * ◆ 대안 기술 : 지금까지 비즈니스 로직의 구현은 크게 EJB를 사용하는 것과 일반 자바 객체(POJO)를 사용하는 것으로 나눌 수 있었다. EJB를 사용하는 경우 개발자들의 많은 불만이 EJB 3.0을 사용함으로써 해결되리라 예상된다. 하지만 해외를 중심으로 해서 EJB를 사용하건, 사용하지 않건 비즈니스 로직들을 체계적으로 관리하는 IoC 컨테이너에 대한 관심이 증가하고 있는 추세이다. IoC 컨테이너에 대해서는 뒤에서 다시 자세히 살펴보도록 하겠다. 
 * ◆ 주요 패턴 : Business Delegate 패턴, Session Facade 패턴, Service Locator 패턴, Application Service 패턴, EJB Home Factory 패턴 

4. 퍼시스턴스 계층 
 * ◆ 역할 : 퍼시스턴스 계층은 데이터 처리를 담당하는 계층이다. 주로 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행하게 된다. 식당으로 보자면 주방장이 사용할 재료를 담당하는 재료 담당자라고나 할까? 이 데이터는 주로 데이터베이스에서 처리되는 경우가 많아, 영속성을 의미하는 퍼시스턴스 계층이란 용어를 사용했다. 하지만 데이터가 처리되는 다른 업무 시스템이나, 웹 서비스, XML, 파일 시스템 등을 모두 고려한다면 레거시 개념을 갖는 EIS 계층이란 표현이 더 적합할 것이다. 
 * ◆ 기능 : 이 계층에서 수행하는 일은 관계형 정보를 저장하고, 수정/삭제하는 것과, 그러한 일을 수행하는 데 필요한 질의문을 관리하는 것, 그리고 가져온 관계형 정보를 객체화시키는 일이다. 
 * ◆ 대안 기술 : EJB 사용에 있어서 개발자들이 가장 불만스러워 하는 것은 CMP 방식의 엔티티 빈일 것이다. 그러한 불만은 객체 관계 맵핑(ORM)을 이용한 JDO라는 대안기술을 탄생시켰고, 또한 하이버네이트라는 또 하나의 오픈소스 기술을 실무로 끌여들였다. JDBC를 이용한 DAO 객체를 구성하는 방법도 소규모 애플리케이션에서는 여전히 인기를 끌고 있다. EJB 3.0과 JDO/하이버네이트, 그리고 JDBC를 이용한 POJO 방식 중 어떤 것이 개발자들에게 낙점될 지는 아직 미지수다. 
 * ◆ 주요 패턴 : Data Access Object 패턴, Domain Store 패턴, Sequence Blocks 


5. 도메인 모델 계층 
 * ◆ 역할 : 도메인 모델은 각 계층 사이에 전달되는 실질적인 비즈니스 객체라고 할 수 있다. 식당을 예로 든다면, 음식이 담긴 그릇이라고 비유할 수 있겠다. 
 * ◆ 기능 : 도메인 모델 계층은 흔히 데이터 전송 객체(DTO) 형태로 개발자가 직접 제작해서, 리퀘스트나 세션과 같은 컨텍스트에 담아 넘기게 된다. 하지만 데이터베이스의 모든 정보를 일일이 객체로 만드는 것은 귀찮을 뿐 아니라, 계층간의 통신 과정에서 데이터가 유실될 위험도 있기 때문에 최근에는 도메인 모델을 서비스로 제공하여 자동화하는 경우가 많다. 
 * ◆ 주요 패턴 : Data Transfer Object 패턴, Value List Handler 패턴 
 * 지금까지 엔터프라이즈 시스템을 구축하기 위해 일반적으로 사용되는 다섯 계층에 대해 간단히 정리해 보았다. 뻔한 이야기들을 길게 늘여 쓴 이유는 2가지 사실을 강조하기 위해서이다. 첫째, 각각의 계층은 저마다의 분명한 역할이 존재하며, 그 역할을 충실히 수행할 수많은 대안기술(Alternative)들 사이에서 개발자는 무엇을 선택할 지 결정을 내려야 한다. 둘째, 각각의 기술들은 독립적으로도 충분한 가치를 지니고 있지만, 가장 장점을 발휘하는 제 위치에서 서로 연계되어 사용될 때 그 시너지 효과가 더욱 크다. 





# 자바

## Generic
* 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움이 줄어든다. 자연스럽게 코드도 더 간결해진다. 예를 들면, Collection에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다. 이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다. 
* 또한 api를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.

## wrapper
* 기본 자료형(Primitive data type)에 대한 클래스 표현을 Wrapper class라고 한다. Integer, Float, Boolean 등이 Wrapper class의 예이다. 
* int를 Integer라는 객체로 감싸서 저장해야 하는 이유가 있을까? 일단 컬렉션에서 제네릭을 사용하기 위해서는 Wrapper class를 사용해줘야 한다. 또한 null 값을 반환해야만 하는 경우에는 return type을 Wrapper class로 지정하여 null을 반환하도록 할 수 있다. 
* 하지만 이러한 상황을 제외한 일반적인 상황에서는 Wrapper class를 사용해야 하는 이유는 객체지향적인 프로그래밍을 위한 프로그래밍이 아니고서야 없다. 일단 해당 값을 비교할 때, Primitive data type인 경우에는 ==로 바로 비교해줄 수 있다. 하지만 Wrapper class인 경우에는 .intValue() 메소드를 통해 해당 Wrapper class의 값을 가져와 비교해줘야 한다.

## autoboxing
* JDK 1.5 부터는 AutoBoxing과 AutoUnBoxing을 제공한다. 이 기능은 각 Wrapper class에 상응하는 Primitive data type일 경우에만 가능하다.
```java
List<Integer> lists = new ArrayList<>();
lists.add(1);
```
* 우린 Integer라는 Wrapper class로 설정한 collection에 데이터를 add할 때 Integer 객체로 감싸서 넣지 않는다. 자바 내부에서 AutoBoxing해주기 때문이다.



## OOP 설계 원칙(SOLID)

### SRP(The Single Responsibility Principle); 단일 책임 원칙
* 한 클래스는 하나의 역할만 맡는다. 
* Responsibility: Method
* 어떤 클래스(메소드, 컴포넌트)가 변경되는 이유는 유일해야 한다.

### OCP(Open Close) 개방-폐쇄 원칙
* 확장에 대해 열려있고 수정에 대해 닫혀있다.
  - 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
  - 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
* interface, protocol, standard, HTTP 표준을 rendering 하는 각종 browser 들
* 운전자 -> 자동차 -> 마티즈/소나타(사용자는 마티즈, 소나타를 볼 수 없다.)
* 자바 애플리 케이션 <> JDBC 인터페이스 <> JDBC 드라이버(오라클, MySQL, MS-SQL)

### LSP(Liskov Substitution); 리스코프 교체 원칙
* 이미 언어 상에서 구현되어 있음
* 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 
* 기반 클래스의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
  서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다.
  펭귄은 동물의 한 종류이다.(상속)
* 상위 분류는 하위분류의 종류여야 한다. 하위타입은 그것의 기반 타입에 대해 치환 가능해야 한다.
* 구현 클래스는 인터페이스가 될 수 있어야 한다.
  펭귄은 날 수 있어야 한다.(인터페이스)
  Base Class의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
* 위키피디아 논문: 하위형에서 선행 조건은 강화될 수 없다.
  하위형에서 후행 조건은 약화될 수 없다.
  하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

### ISP(Interface Segregation); 인터페이스 격리 원칙
* 클라이언트는 자신이 쓰지 않는 인터페이스에 의존하지 않는다.(그러니 인터페이스를 더 작게 나눈다.)
* 로버트 마틴: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

### DIP(Dependency Inversion); 의존 관계 역전 원칙
* 상위 수준 모듈이 하위 수준 모듈에 의존하면 안 된다.
* 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙
* 로버트 마틴: 자주 변경되는 구체 클래스에 의존하지 말아야 한다.
* 자동차 -> 타이어(인터페이스) > 스노우타이어

## DAO
- Data Access Object 의 약자로 데이터베이스의 data에 접근하기 위한 객체입니다.
- DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용합니다.
- DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많습니다.
- 그래서 현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드뭅니다.
- 출처: https://lemontia.tistory.com/591 [안녕하세요]

## DTO(Data Transfer Object), VO 차이
- 여기서 말하는 계층간의 의미는 Controller, View, Business Layer, Persistent Layer 
-       전송되는 데이터의 컨테이너이다.
-       VO와 동일하게 데이터를 저장하여 사용하도록 하는 부분에서 필요하다.
-       VO와 비교를 하여 보면 DTO는 같은 시스템에서 사용되는 것이 아닌 다른 시스템으로 전달하는 작업을 처리하는 객체이다.
-       Layer간의 통신 용도로 오가는 객체를 말하기도 한다.
-       현재의 개발 환경에서 보통 데이터는 다음과 같이 흐름으로 이동한다.
- n   서버 측 : Database Column Data -> DTO -> API(JSON or XML) -> Client
- n   클라이언트 측 : Server -> API(JSON or XML) -> DTO -> View or Local Database System

## VO(Value Object)
-       데이터 그 자체로 의미 있는 것을 담고 있는 객체이다.
-       DTO와 동일한 개념이나 차이점은 Read–Only 속성 객체이다.
-       간단한 독립체( Entity )를 의미하는 작은 객체를 의미한다. 
-       관계데이터베이스의 레코드에 대응되는 자바클래스이다.
- n   형태는 Database레코드를 구성하는 필드들을 VO의 Attribute로 하고 해당 변수에 접근 할 수 있는 Getter와 Setter 메소드의 조합으로 클래스를 형성되어진 클래스이다.
- n   거의 불변성을 가지고 equals()로 비교할 때 객체의 모든 값을 비교해야 한다.

### 차이
   - VO : 사용 되는 값이 객체로 표현 되며, 값 변경이 없는 경우를 말한다.
-       DTO : 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용하기 한다.
- 예를 들어 외부 시스템과 데이터 통신을 할 경우에는 DTO로, DB에서 가져오는 Data는 VO로 정의해서 사용한다고 약속을 하면, 향후 DTO/VO를 수정할 경우 좀 더 고민할 여지가 생길것 같다.
- DTO와 VO의 공통점은 넣어진 데이터를 getter를 통해 사용하므로 주 목적은 같습니다. 그러나 DTO의 경우는 가변의 성격을 가진 클래스 입니다(setter 활용). 그에반해 VO는 불변의 성격을 가졌기에 차이점이 있습니다. 



### 예제
```JAVA
DTO a = new DTO(1);

DTO b = new DTO(1);

이라고 했을 때 a != b 이지만,

VO a = VO(1);

VO b = VO(1); 이라고 했을때는 a == b라고 정의하는 형태입니다.

출처: https://itmore.tistory.com/entry/자바-VO-DTO-차이점사용하는-방식이-같다고-똑같다고-생각하지-말자 [IT모아]
```

# 서버

## 세션
* 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다.
* 페이지를 이동해도 사용자의 로그인 상태를 유지하는 기능을 생각해 봅시다. 앞서 살펴본 쿠키를 이용해서 사용자의 아이디와 비밀번호를 쿠키에 저장한다고 가정해 봅시다. 페이지를 이동하여도 쿠키를 통해 아이디와 비밀번호를 서버에 전달해서 서버에서는 사용자를 식별하여 해당 사용자의 로그인 상태를 유지시킬 수 있습니다. 하지만 이렇게 쿠키만을 이용하여 인증을 구현하면 쿠키가 유출, 조작 될 수 있는 보안상 매우 큰 문제가 됩니다. 개인 소유가 아닌 컴퓨터에서 사용할 경우 누구나 그 사용자의 비밀번호를 확인할 수 있고 HTTP로 개인 정보를 주고 받는 것은 매우 위험합니다.
* Session은 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONID(session id)를 저장합니다. 서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장합니다. 보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용합니다.
* 세션 기간 조정 안하면 많은 VMWare가 켜져 있어 서버가 느려질 우려


### 세션의 동작 순서
* 클라이언트가 서버에 처음으로 Request를 보냄 (첫 요청이기 때문에 session id가 존재하지 않음)
* 서버에서는 session id 쿠키 값이 없는 것을 확인하고 새로 발급해서 응답
* 이후 클라이언트는 전달받은 session id 값을 매 요청마다 헤더 쿠키에 넣어서 요청
* 서버는 session id를 확인하여 사용자를 식별
* 클라이언트가 로그인을 요청하면 서버는 session을 로그인한 사용자 정보로 갱신하고 새로운 session id를 발급하여 응답
* 이후 클라이언트는 로그인 사용자의 session id 쿠키를 요청과 함께 전달하고 서버에서도 로그인된 사용자로 식별 가능
* 클라이언트 종료 (브라우저 종료) 시 session id 제거, 서버에서도 세션 제거


### 세션의 특징
* 세션 아이디는 브라우저 단위로 저장되고 브라우저 종료시 소멸됩니다.
* 로그인한 사용자에 대해서만 세션을 생성하는 것이 아닙니다. 따라서 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성됩니다.
* 사용자가 로그인 했는지, 닉네임 등의 사용자가 요청 할 때 마다 필요한 청보들을 세션에 담아두면 사용자 디비에 접근할 필요가 없어서 효율적입니다.

### 세션 보안
* 누군가 어떤 사용자의 세션 아이디를 훔친다면 그 사용자처럼 로그인할 수 있게 됩니다. https를 이용해서 통신 하는 것이 좋고 cookie와 마찬가지로 session의 옵션으로 secure을 true로 주면 https에서만 세션 정보를 주고받을 수 있고 HttpOnly을 true를 주면 js를 통해서 세션 쿠키를 사용할 수 없도록 강제할 수 있습니다.


## 쿠키의 룰
1. 같은 도메인에서만 한정
* 자동적으로 보냄
* 자동적으로 세팅
* 페이스북이 만든 쿠키는 페이스북안에서만 보내질 수 있지만 페이스북의 좋아요 버튼이 들어간 링크에의 쿠키가 페북으로 들어감

### 쿠키
* 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터라고 했습니다. 쿠키의 데이터 형태는 Key 와 Value로 구성되고 String으로만 이루어져 있습니다. 4KB 이상 저장할 수는 없습니다.
* 쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것입니다. (쿠키가 없다면 다음 페이지로 정보를 파라미터로 넘겨줘야 합니다.)
  * ID 저장, 로그인 상태 유지
  * 7일간 다시 보지 않기. (쿠키에 체크한 날짜를 기록하여 다시 방문 했을 때의 시간과 시차를 이용하여 계산)
  * 최근 검색한 상품들을 광고에서 추천
  * 쇼핑몰 장바구니 기능

### 세션과 쿠키의 차이
- 쿠키의 경우는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말한다
- 예를 들자면 ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는데에 사용한다. (IE 인터넷 옵션에서 검색 기록 삭제할때 임시 파일, 열어본 페이지 목록, 쿠키, 저장된 암호 및 웹 양식 정보 삭제라고 되어있지 아니한가)
- 세션은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는것을 말한다.

### HTTP Session 동작 순서
1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.
2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.
3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.

## 클러스터링
* 클러스터란 여러 대의 서버를 네트워크로 연결하여 전체적으로 하나의 서버처럼 보이게 하는 기술이다.
* 클러스터를 구성하면 한 대의 서버가 고장이 나도 다른 서버에서 처리를 계속할 수 있어서 서비스의 신뢰성 확보 가능
* 클러스터 구성은 스토리지의 소유 방법에 따라 공유 스토리지 구성과 데이터 미러 구성으로 크게 나뉜다.

1.  공유 스토리지 구성
* 즉 서버 개수 + 공유 스토리지로 구성
* 여러 대의 서버가 공유하는 스토리지를 마련하여 장애 시에 데이터의 무결성을 확보하는 방
* 공유 스토리지를 마련할 필요가 있지만 확장성이 높아 대규모 시스템에서 많이 채택한다.

2. 데이터 미러 구성
* 모든 서버가 같은 내용을 복사하여 가지고 있음
* 로컬 디스크 볼륨의 복사본을 네트워크로 보냄으로써 장애 시 데이터의 무결성을 확보하는 방식이다.
* 저가로 구축할 수 있어서 소규모 시스템에서 채택한다.

## 하트비트로 서로의 상태를 감시
* 클러스터 구성에서는 클라이언트로부터 오는 트래픽을 가상 IP 주소라는 논리적인 IP 주소로 받는다.
* 클러스터는 이 가상 IP 주소를 액티브 서버로 보냄으로써 서비스의 다중성을 확보한다.
* 액티브 1대 /스탠바이 1대 인 경우 액티브는 하트비트 네트워크라는 전용 네트워크로 스탠바이 서버의 상태를 감시한다.
* 액티브 서버는 장애를 감지하면 가상 IP 주소를 스탠바이 서버에게 전달한다.
* 가상 IP 주소를 넘겨받은 스탠바이 서버는 이제 액티브 서버가 되어 클라이언트로부터 오는 트래픽을 받게 된다.


# 웹
## Get 방식
* GET 방식은 전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송하며 파라미터의 길이가 256바이트를 넘을 수 없지만 본문(Body)이 필요 없기 때문에 전송 속도가 POST 방식에 비해 빠르다.


## Post 방식
* POST 방식은 파라미터 값들을 요청 메시지의 본문(Body)에 담아서 전송하기 때문에 길이의 제약이 없다.
⎼ HTTP 헤더 속으로 정보가 감춰지고 반드시 HTML 폼을 통해서만 사용할 수 있다.

#  데이터베이스
## Transaction
* 트랜잭션(Transaction)은 데이터베이스의 완전성을 보장하기 위한 것입니다.
* 상태를 변화시키기 해서 수행하는 하나의 작업의 단위를 뜻합니다.


### 원자성 (Atomicity)
* all or nothing
 * 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 것을 의미한다.
 * 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

### 일관성 (Consistency)
 * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
 * 일관성 있는 데이터베이스 상태라는 것은 다양한 제약 조건(constraints, cascades, triggers)등에 만족한다는 것이다. - Software Level

### 독립성 (Isolation)
 * 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
 * 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.

### 지속성 (Durability)
 * 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. - Hardware Level
 * 전력문제, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
 * 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
 * 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.


### 트랜잭션(Transaction)을 사용하며 주의해야 할점?
* 언제나 얻는 것이 있으면 잃는 것도 있다.
* 트랜잭션은 데이터를 완전성을 보장하기 위해 많은 자원들을 사용하게 된다. 자원을 사용하며 Lock을 걸게 되면 다른 사용자들은 Lock이 해제될 때까지 기다려야한다. 기다린다는 것은 성능에 좋지 않다는 의미이다. 따라서 Transaction의 범위를 최소화하여 적용하는 것이 좋다.

## 로킹
* 상호배제와 접근제어 기능
* Lock을 걸어 그 Lock을 건 트랜잭션만이 Lock을 해제 할 수 있다.
* 하나의 Transaction이 사용하는 DB내의 data를 다른 Transaction이 접근하지 못하게 Lock을 설정하여  다른 Transaction이 접근하지 못하도록 한다. 실행 완료 후엔 Lock을 해제한다.

### 로킹의 특징
* 로킹 단위가 크면 로크 수가 적어 관리하기 쉽지만 병행성 수준이 낮아진다.
* 로킹 단위가 작으면 로크 수가 많아 관리하기는 복잡하지만 병행성 수준이 높아집니다.

### 2단계 로킹 규약(Two-Phase Locking Protocol)
 * 트랜잭션은 lock만 수행할 수 있고, unlock은 수행할 수 없는 확장 단계가 있다.
 * 
 * 확장단계(Growing Phase)
 * Lock을 설정하는 단계
 * 새로운 lock 연산만 수행할 수 있고 unlock 연산은 수행할 수 없는 단계
 * 축소단계(Shirinking Phase)
 * Lock을 해제하는 단계
 * unlock 연산만 실행할 수 있고 일단 unlock 연산을 실행하면 lock 연산은 실행할 수 없는 단계
 * 교착상태(Deadlock)이 발생할 수있다.
 * 
 * 2단계 로킹 규약 준수 o –> 직렬가능 
 * 2단계 로킹 규약 준수 x –> 직렬가능성을 보장 할 수없다. 직렬이 가능할수도, 가능하지 않을수도…


## 오라클
- MySQL과 달리 오라클은 대용량 데이터 베이스라고 하는데, 대용량 데이터 타입(CLOB; 4GB까지 가능) 까지 가질 수 있다.


## to_char 규칙
- 자바, C언어, 자바스크립트 등 언어마다 날짜 format이 다른데 그때마다 변환하기는 복잡하니 언어끼리는 String으로 교환하고 마지막에 오라클에서 to_char로 바꿔날짜로 바꿔주면 다른 코드들도 짧아지고 편해진다.
- 넘겨주기 전 언어가 Comparable, Serializable 등 기능을 가진 언어여야 함.(객체지향 언어는 대부분 보유; PHP같은 언어는 안됨)
- ① 형식 모델은 단일 따옴표로 묶어야 하며 대소문자를 구분한다. 
- ② 형식 모델은 임의의 유효한 날짜 형식 요소를 포함할 수 있지만 쉼표를 사용하여 날짜값을 형식 모델과 구분해야 한다. 
- ③ 자동으로 출력의 일 및 월 이름은 공백으로 채워진다. 
- ④ 채워진 공백을 제거하거나 선행 0 fmt . 을 출력하지 않으려면 채우기 모드 요소를 사용한다
