# 자기소개
## 장점
* 습관 정리

* 항상 사례를 준비하고 한단어, 한문장으로 토픽을 요약할 수 있어야한다.!!


*  의존 관계
 * : 의존 관계를 DL, DI를 통해 확보한다. 객체 지향 프로그래밍은 객체간의 관계가 중요하다. 그래서 항상 Has, Use, Is 관계로 연결되어 있다. 이러한 의존 관계를 외부 조립기기로부터 받는 것이 IOC이다.

*  AOP : 시스템을 핵심과 공통으로 나눈다. 
 * 예제) 메서드에 걸리는 시간을 로깅처리를 할 때. 수백가지의 메서드에 각각의 로깅처리를 할 때, 공통관심사항을 별도의 클래스에서 정의하고 pointcut으로 대상을 지정하고, advice로 적용시점을 정해서 execution한다.
 * 공통사항들이 별도의 클래스에서 정의되기 때문에, 결합도가 낮아진다. 


* 라이브러리 : 재사용할 수 있는 클래스들의 모임
* API : 소스코드는 공개하지 않고, 사용할 수 있도록 하게 하는 것.
* FrameWork : 틀, 뼈대 --> 토대, 기반 제공 --> 다양한 컴포넌트와 개발 패턴을 제공한다 --> 어플리케이션의 분석 설계 구현, 테스트에 필요한 기반을 제공한다 --> 반완전 어플리케이션(대충 다 만들어져 있다. 못채운 부분은 회사마다 다른부분이다)
- Component : 뇌세포와 뇌!!를 항상 기억하기.   자동차를 하나 만들 때, 바퀴, 거울, 핸들, 엔진 등 각각의 부분을 Component화 해서 하나의 완성된 자동차를 만든다. 이것이 Component Base Development이다. 그래서 특정 부분이 고장나면 그 부분만 고치면 된다.
-Framework : 자동차 만드는 것이 거의 다 비슷하니까, 아예 틀을 만들어서 생산할 수 있게한다.

# '웹 크롤링', '스크래핑'

# 크롤링
* (2) 크롤링 크롤링은 웹 사이트를 정기적으로 돌며 정보를 추출하는 기술이다. 크롤링하는 프로그램을 크롤러 또는 스파이더라고 한다. 
* 크롤링으로 웹 정보를 추출할 때는 반드시 하나의 특정 웹 페이지의 URL 주소를 명시해주어야 한다. 가장 먼저 방문하는 URL은 중요한 역할을 하는데 뒤이어 크롤링 되어야할 웹 페이지의 URL은 웹 페이지가 링크하고 있는 웹 페이지를 순차적으로 방문한다. 

# 스크레핑
* (3) 스크레이핑 스크레이핑은 웹 사이트에 있는 특정 정보를 추출하는 기술이다. 스크레이핑은 웹에서 자료를 추출 하는 것 뿐만 아니라 구조도 분석한다. 스크레이핑은 로그인해서 필요한 웹 페이지에 접근 하는 기술이 필요하다. 
* 시스템이나 웹사이트에 있는 정보(데이터) 중에서 필요한 정보를 추출 및 가공하여 제공하는 소프트웨어 기술입니다. 이는 고객이 한 번만 자신의 정보 제공을 인증하게 되면 컴퓨터가 대신하여 필요한 고객 정보들을 자동으로 추출하여 제공하는 것을 말합니다. 

## 뱅크 샐러드
* 뱅크샐러드라는 하나의 애플리케이션을 통해 고객은 자신의 카드사 및 은행, 보험정보들을 한번에 조회할 수 있습니다.

## 스크래핑 종류
* 금융위는 또 서버에 저장하고 관리해 문제가 있다고 거론하는데 이는 서버형 스크래핑이다. 이를 이용하는 업체는 일부인데, 기술력을 보유한 스크래핑 개발업체는 이 방식을 지양하고 있다. 서버형 보다는 클라이언트형 스크래핑을 활용한다. 스마트폰 보급률이 높기 때문이다. 스마트폰에 저장된 개인 인증서를 스크래핑 엔진이 있는 업체에게 곧바로 가기 때문에 제3자가 개인정보를 보거나 유출하기 힘들다. 또 최근 정보 유출 사고 사례 중 스크래핑에 의한 경우는 없었다."
* "API는 무조건 안정적이며 스크래핑은 안정적이지 않다는 비교는 하기 어렵다. 스크래핑은 지속적으로 보안성을 높이는 기술을 개발하고 업그레이드해왔다. 다만 스크래핑은 대상 사이트의 보안정책을 준수하지만, 통신프로토콜을 적용한 API방식은 보안성이 뛰어난 것은 사실이다.


# 은행
## OTP
* OTP(One Time Password)발생기는 전자금융 거래에서 사용되는 일회용 비밀번호 생성 기기로 1분마다 새로운 비밀번호가 생성되어 해킹이나 외부노출의 위험으로부터 안전하게 서비스를 이용하실 수 있습니다.
* 보안카드 불편성 해결(앞자리 뒷자리, 비밀번호 3개 입력),  OTP는 6자리 비밀번호 그대로 입력
* 1분마다 새롱누 6자리 비밀번호 생성

## OTP 단점
* 하지만, 전원문제로 소진이 되면 보안카드 보다 훨씬 더 불편함을 발생할 수 있는데 이를 감추었다고 할 수 있다. 이 같은 상황은 국내 은행들이 발행하는 OTP 비밀번호 발생기는 3V 배터리가 내장되어 밀봉된 형태로, 배터리가 소진하면 재사용이 불가하고, 은행으로부터 새로운 기기를 수령해야 하며, 결과적으로 OTP도 새롭게 등록해야 합니다.
* 반면, 영국은행에서 지급되는 OTP는 국내은행과는 다른 형태의 기기를 제공한다. 사실상 우리의 공인인증서 역할을 함께 한다고 할 수 있다. 그 차이점은 단말기에 '사용자 확인(Identify), 서명(sign), Response등 복합적인 기능을 한꺼번에 처리가 가능하다. 그리고, 우리 개인용 OTP와는 달리, 키패드도 내장되어 있어서, 필요한 번호를 입력함으로써 보안성을 높였다고 할 수 있다.



# N
## thin client
 CPU, 메모리 등 필수적인 하드웨어 장치만 탑재해 네트워크로 연결된 중앙서버에서 모든 업무를 관리하도록 설계된 업무용 PC를 일컫는다.

## vm


## RDP

## Spice

# 가상화 업체 VDI 개발 현황
 
## 가. Citrix
- Citrix의 XenDesktop은 XenServer를 이용하여 공용 또는 전용 VM(Virtual Machine)을 제공하며, 사용자 단말에서 구동되는 XenClient나 스트리밍 VHD(Virtual Hard Disk) 방식을 지원하는 XenApp을 이용한 원격 또는 스트리밍 방식을 지원한다.
 
## 나. VMware
- VMware의 VMware View는 서버 가상화 기술인 vSphere와 통합되어 RDP과 PCoIP 원격 디스플레이 프로토콜을 지원한다. 또한 오프라인으로 가상 데스크톱을 사용할 수 있는 로컬 모드 View는 온라인 가상 데스크톱과 동기화시키는 방식을 사용한다.
 
## 다. Microsoft
- Microsoft는 가상화 플랫폼인 Hyper-V에 RDS(Remote Desktop Services)와 RDVH(Remote Desktop Virtualization Host)를 통합하고 원격 디스플레이 프로토콜로는 RDP를 지원해 가상 데스크톱 인프라 기술을 제공한다.
 
## 라. Oracle
- Oracle에서는 가상 데스크톱 인프라 기술로 Sun Ray 가상 데스크톱 세션 관리 기술과 가상화 플랫폼인 Oracle VDI 하이퍼바이저 기술을 개발하였다. Oracle의 기술은 VMware vCenter, Microsoft Hyper-V, Microsoft RDS를 지원한다.
 
## 마. 공개 SW
- 공개 SW 커뮤니티 중심의 개발 사례로는 RedHat이 오픈 소스 원격 디스플레이 프로토콜인 SPICE(Simple Protocol for Independent Computing Environments)를 데스크톱 가상화에 적용하였으며, Ulteo에서는 Debian과 Ubuntu 기반의 오픈 소스 VDI 솔루션을 제공한다. 
CloudStack.com은 클라우드 IaaS(Infrastructure as a Service) 플랫폼 솔루션을 통한 VDI 클라우드 인프라 구축을 지원하고 있다.


# 회기분석
* 회귀분석은 독립변수와 종속변수 사이의 구체적인 함수식을 찾아내고, 독립변수로부 터 종속변수를 예측하는 데 그 목적이 있다.
* 선형회귀, 다중회귀분석

## 독립변수
- 독립변수는 연구자가 의도적으로 변화시키는 변수를 말합니다.
- 독립변수는 영어로 Independent variable입니다. 말 그대로 독립적인 변수입니다. 통계에서 독립적이라는 말은 다른 변수에 영향을 받지 않는다는 뜻입니다. 따라서 독립변수는 다른 변수에 영향을 받지 않습니다. 오히려 종속 변수에 영향을 주는 변수 입니다. 
* 회귀분석에서 다른 변수에 영향을 주는 원인에 해당하는 변수를 독립변수(independent variable) 또는 설명변수(explanatory variable)라고 하며

## 종속변수
- 영향을 받는 결과에 해당하는 변 수를 종속변수(dependent variable) 또는 반응변수(response variable)라고 한다. 
- 종속변수는 연구자가 독립변수의 변화에 따라 어떻게 변하는지 알고 싶어하는 변수를 말합니다.
- 그렇다면 종속변수는 무엇일까요? 종속변수는 영어로 Dependent variable 입니다. 말 그대로 종속적인 또는 의존적인 변수입니다. 즉 독립변수에 영향을 받아서 변화하는 변수를 종속변수라고 생각하시면 됩니다. 
- 조금 어렵나요? 더욱 쉽게 설명하면 독립변수는 연구자가 마음대로 조정할 수 있는 변수입니다. 왜 일까요? 바로 독립변수가 어떻게 변화하느냐에 따라 종속변수가 어떻게 변화하는지 보고 싶기 때문이죠. 이 때문에 독립변수는 원인변수 (Explanatory variable), 예측 변수 (Predictor variable)라고 부르기도 합니다. 반면에 종속 변수는 연구자가 알고 싶어하는 변수입니다. 연구자의 목표는 독립변수를 조정하여 변화시킬 때 종속변수가 어떻게 변화하는지 알아내는 것 입니다. 이 때문에 종속변수를 반응 변수 (Response variable), 결과 변수 (Outcome variable)이라고 부르기도 합니다. 

## MAE
* Mean absolute error
* -통계에서 평균 절대 오차는 두 연속 변수의 차이를 측정 한 것입니다

# 판다스, 맷플롯립
## 판다스
1. 시리즈(Series): 시리즈 클래스는 1차원 배열의 값(values)에 각 값에 대응되는 인덱스(index)를 부여할 수 있는 구조를 갖고 있습니다.
2. 데이터프레임(DataFrame): 은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스(index)와 열방향 인덱스(column)가 존재합니다. 즉, 행과 열을 가지는 자료구조입니다. 시리즈가 인덱스(index)와 값(values)으로 구성된다면, 데이터프레임은 열(columns)까지 추가되어 열(columns), 인덱스(index), 값(values)으로 구성됩니다.
3. 패널(Panel)

## 넘파이
* Numpy(보통 "넘파이"라고 발음.)는 수치 데이터를 다루는 Python 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.

## 사이킷런
*  머신러닝 학습용 패키지다. 대부분의 머신러닝 모형을 제공하므로 파이썬으로 머신러닝을 공부하는 데 최적의 학습 도구다.
* https://book.coalastudy.com/data-science-lv1/week3/stage3

### Training set
* 모델의 학습에 사용되는 데이터

### Validation set
* 모델 제작 과정 중, 학습된 모델의 성능을 측정하기 위한 데이터
### Test set 모델의 최종 성능을 평가하기 위한 데이터
* 모델의 최종 성능을 평가하기 위한 데이터


## 맷플롯립
* Matplotlib는 데이터를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이해를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.

## Seaborn¶
* Seaborn("시본"이라고 읽는다) 패키지는 Matplotlib 패키지에서 지원하지 않는 고급 통계 차트를 그리는 통계용 시각화 기능을 제공한다.



# 신경망 알고리즘
* Artificial neural network (ANN)는 딥 러닝의 가장 핵심적인 기술로써, 신경 세포인 neuron을 추상화한 artificial neuron으로 구성된 네트워크이다. ANN은 일반적으로 어떠한 형태의 function이든 근사할 수 있는 universal function approximator로도 알려져 있다. 이 글에서는 ANN을 구성하는 가장 작은 요소인 artificial neuron부터 multi-layer ANN과 이를 학습시키기 위한 algorithm에 대해 서술한다.
* 일반적으로 사용되는 기본적인 인공신경망 알고리즘인 다층인공신경망(multi-layer neural network)의 경우 아래 그림과 같이 입력층(input layer), 은닉층(hidden layer), 그리고 출력층(output layer),이렇게 세가지 층으로 구분이 됩니다. 그리고 각 층들은 노드들로 구성되어 있습니다. 아래 그림의 예에서는 입력층은 4개의 노드, 은닉층은 3개의 노드, 그리고 출력층은 1개의 노드를 가지고 있습니다.
* 입력층은 예측값(출력변수)을 도출하기 위한 예측변수(입력변수)의 값들을 입력하는 역할을 합니다. 만약 n개의 입력 값들이 있다면 입력층은 n개의 노드를 가지게 됩니다. 은닉층은 모든 입력노드부터 입력값을 받아 가중합을 계산하고, 이 값을 전이함수에 적용하여 출력층에 전달하게 됩니다. 각 입력노드와 은닉노드들은 모두 가중치를 가지는 망으로 연결되어 있으며 은닉노드와 출력노드도 마찬가지로 연결되어 있습니다.
* 이 가중치는 연결강도로 표현되며 랜덤으로 초기에 주어졌다가 예측 값을 가장 잘 맞추는 값으로 조정되게 됩니다. 전이함수는 비선형함수를 사용하게 되며, 이러한 전이함수를 통하여 출력층에 예측 값이 전달되기 때문에 인공신경망이 비선형 모델로서 역할을 할 수 있게 됩니다.
* https://blog.lgcns.com/1359

## 의사결정트리
* 의사결정나무는 데이터를 분석하여 이들 사이에 존재하는 패턴을 예측 가능한 규칙들의 조합으로 나타내며, 그 모양이 ‘나무’와 같다고 해서 의사결정나무라 불립니다. 질문을 던져서 대상을 좁혀나가는 ‘스무고개’ 놀이와 비슷한 개념입니다. 한번 예를 들어볼까요?
* 의사결정나무는 분류(classification)와 회귀(regression) 모두 가능합니다. 범주나 연속형 수치 모두 예측할 수 있다는 말입니다. 의사결정나무의 범주예측, 즉 분류 과정은 이렇습니다. 새로운 데이터가 특정 terminal node에 속한다는 정보를 확인한 뒤 해당 terminal node에서 가장 빈도가 높은 범주에 새로운 데이터를 분류하게 됩니다. 운동경기 예시를 기준으로 말씀드리면 날씨는 맑은데 습도가 70을 넘는 날은 경기가 열리지 않을 거라고 예측합니다.





# 자바

## Generic
* 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움이 줄어든다. 자연스럽게 코드도 더 간결해진다. 예를 들면, Collection에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다. 이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다. 
* 또한 api를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.

## wrapper
* 기본 자료형(Primitive data type)에 대한 클래스 표현을 Wrapper class라고 한다. Integer, Float, Boolean 등이 Wrapper class의 예이다. 
* int를 Integer라는 객체로 감싸서 저장해야 하는 이유가 있을까? 일단 컬렉션에서 제네릭을 사용하기 위해서는 Wrapper class를 사용해줘야 한다. 또한 null 값을 반환해야만 하는 경우에는 return type을 Wrapper class로 지정하여 null을 반환하도록 할 수 있다. 
* 하지만 이러한 상황을 제외한 일반적인 상황에서는 Wrapper class를 사용해야 하는 이유는 객체지향적인 프로그래밍을 위한 프로그래밍이 아니고서야 없다. 일단 해당 값을 비교할 때, Primitive data type인 경우에는 ==로 바로 비교해줄 수 있다. 하지만 Wrapper class인 경우에는 .intValue() 메소드를 통해 해당 Wrapper class의 값을 가져와 비교해줘야 한다.

## autoboxing
* JDK 1.5 부터는 AutoBoxing과 AutoUnBoxing을 제공한다. 이 기능은 각 Wrapper class에 상응하는 Primitive data type일 경우에만 가능하다.
```java
List<Integer> lists = new ArrayList<>();
lists.add(1);
```
* 우린 Integer라는 Wrapper class로 설정한 collection에 데이터를 add할 때 Integer 객체로 감싸서 넣지 않는다. 자바 내부에서 AutoBoxing해주기 때문이다.

# Hashmap, Hashtable, TreeMap, LinkedHashmap
* Hashmap: 키나 값에 null값 가능, thread safe 하지 않음; Hashtable 반대

## hashmap
* O(1)
* key 값을 중복이 불가능 하고 value는 중복이 가능. value에 null값도 사용 가능하다.


## Treemap
* O(logn) 성능을 보인다.
* TreeMap은 SortedMap 인터페이스를 구현하고 있어 Key 값을 기준으로 정렬이 되어 있는데, 이는 Comparator를 구현하여 정렬 순서를 변경할 수 있다.


## LinkedHashMap
* doulbly-linked list로 저장됨(linked-list 자료구조로 저장된다는 거군요.)
* linked-list므로 당연하게도, 넣은 순서대로 빠져나옵니다.
* HashMap과 마찬가지로 다중쓰레드 사용시에 synchronized가 되지 않습니다.


## OOP 설계 원칙(SOLID)

### SRP(The Single Responsibility Principle); 단일 책임 원칙
* 한 클래스는 하나의 역할만 맡는다. 
* Responsibility: Method
* 어떤 클래스(메소드, 컴포넌트)가 변경되는 이유는 유일해야 한다.

### OCP(Open Close) 개방-폐쇄 원칙
* 확장에 대해 열려있고 수정에 대해 닫혀있다.
  - 이것은 모듈의 동작을 확장할 수 있다는 것을 의미한다. 애플리케이션의 요구 사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해 모듈을 확장할 수 있다. 즉, 모듈이 하는 일을 변경할 수 있다.
  - 모듈의 소스 코드나 바이너리 코드를 수정하지 않아도 모듈의 기능을 확장하거나 변경할 수 있다. 그 모듈의 실행 가능한 바이너리 형태나 링크 가능한 라이브러리(예를 들어 윈도의 DLL이나 자바의 .jar)를 건드릴 필요가 없다.
* interface, protocol, standard, HTTP 표준을 rendering 하는 각종 browser 들
* 운전자 -> 자동차 -> 마티즈/소나타(사용자는 마티즈, 소나타를 볼 수 없다.)
* 자바 애플리 케이션 <> JDBC 인터페이스 <> JDBC 드라이버(오라클, MySQL, MS-SQL)

### LSP(Liskov Substitution); 리스코프 교체 원칙
* 이미 언어 상에서 구현되어 있음
* 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 
* 기반 클래스의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
  서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다.
  펭귄은 동물의 한 종류이다.(상속)
* 상위 분류는 하위분류의 종류여야 한다. 하위타입은 그것의 기반 타입에 대해 치환 가능해야 한다.
* 구현 클래스는 인터페이스가 될 수 있어야 한다.
  펭귄은 날 수 있어야 한다.(인터페이스)
  Base Class의 포인터나 참조값을 사용하는 코드에서는 실제로 어떤 클래스인지 몰라도 쓸 수 있어야 한다.
* 위키피디아 논문: 하위형에서 선행 조건은 강화될 수 없다.
  하위형에서 후행 조건은 약화될 수 없다.
  하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

### ISP(Interface Segregation); 인터페이스 격리 원칙
* 클라이언트는 자신이 쓰지 않는 인터페이스에 의존하지 않는다.(그러니 인터페이스를 더 작게 나눈다.)
* 로버트 마틴: 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.

### DIP(Dependency Inversion); 의존 관계 역전 원칙
* 상위 수준 모듈이 하위 수준 모듈에 의존하면 안 된다.
* 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙
* 로버트 마틴: 자주 변경되는 구체 클래스에 의존하지 말아야 한다.
* 자동차 -> 타이어(인터페이스) > 스노우타이어

## DAO
- Data Access Object 의 약자로 데이터베이스의 data에 접근하기 위한 객체입니다.
- DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용합니다.
- DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많습니다.
- 그래서 현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드뭅니다.
- 출처: https://lemontia.tistory.com/591 [안녕하세요]

## DTO(Data Transfer Object), VO 차이
- 여기서 말하는 계층간의 의미는 Controller, View, Business Layer, Persistent Layer 
-       전송되는 데이터의 컨테이너이다.
-       VO와 동일하게 데이터를 저장하여 사용하도록 하는 부분에서 필요하다.
-       VO와 비교를 하여 보면 DTO는 같은 시스템에서 사용되는 것이 아닌 다른 시스템으로 전달하는 작업을 처리하는 객체이다.
-       Layer간의 통신 용도로 오가는 객체를 말하기도 한다.
-       현재의 개발 환경에서 보통 데이터는 다음과 같이 흐름으로 이동한다.
- n   서버 측 : Database Column Data -> DTO -> API(JSON or XML) -> Client
- n   클라이언트 측 : Server -> API(JSON or XML) -> DTO -> View or Local Database System

## VO(Value Object)
-       데이터 그 자체로 의미 있는 것을 담고 있는 객체이다.
-       DTO와 동일한 개념이나 차이점은 Read–Only 속성 객체이다.
-       간단한 독립체( Entity )를 의미하는 작은 객체를 의미한다. 
-       관계데이터베이스의 레코드에 대응되는 자바클래스이다.
- n   형태는 Database레코드를 구성하는 필드들을 VO의 Attribute로 하고 해당 변수에 접근 할 수 있는 Getter와 Setter 메소드의 조합으로 클래스를 형성되어진 클래스이다.
- n   거의 불변성을 가지고 equals()로 비교할 때 객체의 모든 값을 비교해야 한다.

### 차이
   - VO : 사용 되는 값이 객체로 표현 되며, 값 변경이 없는 경우를 말한다.
-       DTO : 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용하기 한다.
- 예를 들어 외부 시스템과 데이터 통신을 할 경우에는 DTO로, DB에서 가져오는 Data는 VO로 정의해서 사용한다고 약속을 하면, 향후 DTO/VO를 수정할 경우 좀 더 고민할 여지가 생길것 같다.
- DTO와 VO의 공통점은 넣어진 데이터를 getter를 통해 사용하므로 주 목적은 같습니다. 그러나 DTO의 경우는 가변의 성격을 가진 클래스 입니다(setter 활용). 그에반해 VO는 불변의 성격을 가졌기에 차이점이 있습니다. 



### 예제
```JAVA
DTO a = new DTO(1);

DTO b = new DTO(1);

이라고 했을 때 a != b 이지만,

VO a = VO(1);

VO b = VO(1); 이라고 했을때는 a == b라고 정의하는 형태입니다.

출처: https://itmore.tistory.com/entry/자바-VO-DTO-차이점사용하는-방식이-같다고-똑같다고-생각하지-말자 [IT모아]
```

# 서버

## 세션
* 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다.
* 페이지를 이동해도 사용자의 로그인 상태를 유지하는 기능을 생각해 봅시다. 앞서 살펴본 쿠키를 이용해서 사용자의 아이디와 비밀번호를 쿠키에 저장한다고 가정해 봅시다. 페이지를 이동하여도 쿠키를 통해 아이디와 비밀번호를 서버에 전달해서 서버에서는 사용자를 식별하여 해당 사용자의 로그인 상태를 유지시킬 수 있습니다. 하지만 이렇게 쿠키만을 이용하여 인증을 구현하면 쿠키가 유출, 조작 될 수 있는 보안상 매우 큰 문제가 됩니다. 개인 소유가 아닌 컴퓨터에서 사용할 경우 누구나 그 사용자의 비밀번호를 확인할 수 있고 HTTP로 개인 정보를 주고 받는 것은 매우 위험합니다.
* Session은 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONID(session id)를 저장합니다. 서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장합니다. 보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용합니다.
* 세션 기간 조정 안하면 많은 VMWare가 켜져 있어 서버가 느려질 우려


### 세션의 동작 순서
* 클라이언트가 서버에 처음으로 Request를 보냄 (첫 요청이기 때문에 session id가 존재하지 않음)
* 서버에서는 session id 쿠키 값이 없는 것을 확인하고 새로 발급해서 응답
* 이후 클라이언트는 전달받은 session id 값을 매 요청마다 헤더 쿠키에 넣어서 요청
* 서버는 session id를 확인하여 사용자를 식별
* 클라이언트가 로그인을 요청하면 서버는 session을 로그인한 사용자 정보로 갱신하고 새로운 session id를 발급하여 응답
* 이후 클라이언트는 로그인 사용자의 session id 쿠키를 요청과 함께 전달하고 서버에서도 로그인된 사용자로 식별 가능
* 클라이언트 종료 (브라우저 종료) 시 session id 제거, 서버에서도 세션 제거


### 세션의 특징
* 세션 아이디는 브라우저 단위로 저장되고 브라우저 종료시 소멸됩니다.
* 로그인한 사용자에 대해서만 세션을 생성하는 것이 아닙니다. 따라서 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성됩니다.
* 사용자가 로그인 했는지, 닉네임 등의 사용자가 요청 할 때 마다 필요한 청보들을 세션에 담아두면 사용자 디비에 접근할 필요가 없어서 효율적입니다.

### 세션 보안
* 누군가 어떤 사용자의 세션 아이디를 훔친다면 그 사용자처럼 로그인할 수 있게 됩니다. https를 이용해서 통신 하는 것이 좋고 cookie와 마찬가지로 session의 옵션으로 secure을 true로 주면 https에서만 세션 정보를 주고받을 수 있고 HttpOnly을 true를 주면 js를 통해서 세션 쿠키를 사용할 수 없도록 강제할 수 있습니다.


## 쿠키의 룰
1. 같은 도메인에서만 한정
* 자동적으로 보냄
* 자동적으로 세팅
* 페이스북이 만든 쿠키는 페이스북안에서만 보내질 수 있지만 페이스북의 좋아요 버튼이 들어간 링크에의 쿠키가 페북으로 들어감

### 쿠키
* 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터라고 했습니다. 쿠키의 데이터 형태는 Key 와 Value로 구성되고 String으로만 이루어져 있습니다. 4KB 이상 저장할 수는 없습니다.
* 쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것입니다. (쿠키가 없다면 다음 페이지로 정보를 파라미터로 넘겨줘야 합니다.)
  * ID 저장, 로그인 상태 유지
  * 7일간 다시 보지 않기. (쿠키에 체크한 날짜를 기록하여 다시 방문 했을 때의 시간과 시차를 이용하여 계산)
  * 최근 검색한 상품들을 광고에서 추천
  * 쇼핑몰 장바구니 기능

### 세션과 쿠키의 차이
- 쿠키의 경우는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말한다
- 예를 들자면 ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는데에 사용한다. (IE 인터넷 옵션에서 검색 기록 삭제할때 임시 파일, 열어본 페이지 목록, 쿠키, 저장된 암호 및 웹 양식 정보 삭제라고 되어있지 아니한가)
- 세션은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는것을 말한다.

### HTTP Session 동작 순서
1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.
2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.
3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.

## 클러스터링
* 클러스터란 여러 대의 서버를 네트워크로 연결하여 전체적으로 하나의 서버처럼 보이게 하는 기술이다.
* 클러스터를 구성하면 한 대의 서버가 고장이 나도 다른 서버에서 처리를 계속할 수 있어서 서비스의 신뢰성 확보 가능
* 클러스터 구성은 스토리지의 소유 방법에 따라 공유 스토리지 구성과 데이터 미러 구성으로 크게 나뉜다.

1.  공유 스토리지 구성
* 즉 서버 개수 + 공유 스토리지로 구성
* 여러 대의 서버가 공유하는 스토리지를 마련하여 장애 시에 데이터의 무결성을 확보하는 방
* 공유 스토리지를 마련할 필요가 있지만 확장성이 높아 대규모 시스템에서 많이 채택한다.

2. 데이터 미러 구성
* 모든 서버가 같은 내용을 복사하여 가지고 있음
* 로컬 디스크 볼륨의 복사본을 네트워크로 보냄으로써 장애 시 데이터의 무결성을 확보하는 방식이다.
* 저가로 구축할 수 있어서 소규모 시스템에서 채택한다.

## 하트비트로 서로의 상태를 감시
* 클러스터 구성에서는 클라이언트로부터 오는 트래픽을 가상 IP 주소라는 논리적인 IP 주소로 받는다.
* 클러스터는 이 가상 IP 주소를 액티브 서버로 보냄으로써 서비스의 다중성을 확보한다.
* 액티브 1대 /스탠바이 1대 인 경우 액티브는 하트비트 네트워크라는 전용 네트워크로 스탠바이 서버의 상태를 감시한다.
* 액티브 서버는 장애를 감지하면 가상 IP 주소를 스탠바이 서버에게 전달한다.
* 가상 IP 주소를 넘겨받은 스탠바이 서버는 이제 액티브 서버가 되어 클라이언트로부터 오는 트래픽을 받게 된다.


# 웹
## Get 방식
* GET 방식은 전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송하며 파라미터의 길이가 256바이트를 넘을 수 없지만 본문(Body)이 필요 없기 때문에 전송 속도가 POST 방식에 비해 빠르다.


## Post 방식
* POST 방식은 파라미터 값들을 요청 메시지의 본문(Body)에 담아서 전송하기 때문에 길이의 제약이 없다.
⎼ HTTP 헤더 속으로 정보가 감춰지고 반드시 HTML 폼을 통해서만 사용할 수 있다.

#  데이터베이스
## Transaction
* 트랜잭션(Transaction)은 데이터베이스의 완전성을 보장하기 위한 것입니다.
* 상태를 변화시키기 해서 수행하는 하나의 작업의 단위를 뜻합니다.


### 원자성 (Atomicity)
* all or nothing
 * 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 것을 의미한다.
 * 원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

### 일관성 (Consistency)
 * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
 * 일관성 있는 데이터베이스 상태라는 것은 다양한 제약 조건(constraints, cascades, triggers)등에 만족한다는 것이다. - Software Level

### 독립성 (Isolation)
 * 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
 * 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.

### 지속성 (Durability)
 * 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. - Hardware Level
 * 전력문제, 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
 * 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
 * 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.


### 트랜잭션(Transaction)을 사용하며 주의해야 할점?
* 언제나 얻는 것이 있으면 잃는 것도 있다.
* 트랜잭션은 데이터를 완전성을 보장하기 위해 많은 자원들을 사용하게 된다. 자원을 사용하며 Lock을 걸게 되면 다른 사용자들은 Lock이 해제될 때까지 기다려야한다. 기다린다는 것은 성능에 좋지 않다는 의미이다. 따라서 Transaction의 범위를 최소화하여 적용하는 것이 좋다.


## 오라클
- MySQL과 달리 오라클은 대용량 데이터 베이스라고 하는데, 대용량 데이터 타입(CLOB; 4GB까지 가능) 까지 가질 수 있다.


## to_char 규칙
- 자바, C언어, 자바스크립트 등 언어마다 날짜 format이 다른데 그때마다 변환하기는 복잡하니 언어끼리는 String으로 교환하고 마지막에 오라클에서 to_char로 바꿔날짜로 바꿔주면 다른 코드들도 짧아지고 편해진다.
- 넘겨주기 전 언어가 Comparable, Serializable 등 기능을 가진 언어여야 함.(객체지향 언어는 대부분 보유; PHP같은 언어는 안됨)
- ① 형식 모델은 단일 따옴표로 묶어야 하며 대소문자를 구분한다. 
- ② 형식 모델은 임의의 유효한 날짜 형식 요소를 포함할 수 있지만 쉼표를 사용하여 날짜값을 형식 모델과 구분해야 한다. 
- ③ 자동으로 출력의 일 및 월 이름은 공백으로 채워진다. 
- ④ 채워진 공백을 제거하거나 선행 0 fmt . 을 출력하지 않으려면 채우기 모드 요소를 사용한다
