

# 은행
## OTP
* OTP(One Time Password)발생기는 전자금융 거래에서 사용되는 일회용 비밀번호 생성 기기로 1분마다 새로운 비밀번호가 생성되어 해킹이나 외부노출의 위험으로부터 안전하게 서비스를 이용하실 수 있습니다.
* 보안카드 불편성 해결(앞자리 뒷자리, 비밀번호 3개 입력),  OTP는 6자리 비밀번호 그대로 입력
* 1분마다 새롱누 6자리 비밀번호 생성

# N
## thin client
 CPU, 메모리 등 필수적인 하드웨어 장치만 탑재해 네트워크로 연결된 중앙서버에서 모든 업무를 관리하도록 설계된 업무용 PC를 일컫는다.

## vm


## RDP

## Spice

# 가상화 업체 VDI 개발 현황
 
## 가. Citrix
- Citrix의 XenDesktop은 XenServer를 이용하여 공용 또는 전용 VM(Virtual Machine)을 제공하며, 사용자 단말에서 구동되는 XenClient나 스트리밍 VHD(Virtual Hard Disk) 방식을 지원하는 XenApp을 이용한 원격 또는 스트리밍 방식을 지원한다.
 
## 나. VMware
- VMware의 VMware View는 서버 가상화 기술인 vSphere와 통합되어 RDP과 PCoIP 원격 디스플레이 프로토콜을 지원한다. 또한 오프라인으로 가상 데스크톱을 사용할 수 있는 로컬 모드 View는 온라인 가상 데스크톱과 동기화시키는 방식을 사용한다.
 
## 다. Microsoft
- Microsoft는 가상화 플랫폼인 Hyper-V에 RDS(Remote Desktop Services)와 RDVH(Remote Desktop Virtualization Host)를 통합하고 원격 디스플레이 프로토콜로는 RDP를 지원해 가상 데스크톱 인프라 기술을 제공한다.
 
## 라. Oracle
- Oracle에서는 가상 데스크톱 인프라 기술로 Sun Ray 가상 데스크톱 세션 관리 기술과 가상화 플랫폼인 Oracle VDI 하이퍼바이저 기술을 개발하였다. Oracle의 기술은 VMware vCenter, Microsoft Hyper-V, Microsoft RDS를 지원한다.
 
## 마. 공개 SW
- 공개 SW 커뮤니티 중심의 개발 사례로는 RedHat이 오픈 소스 원격 디스플레이 프로토콜인 SPICE(Simple Protocol for Independent Computing Environments)를 데스크톱 가상화에 적용하였으며, Ulteo에서는 Debian과 Ubuntu 기반의 오픈 소스 VDI 솔루션을 제공한다. 
CloudStack.com은 클라우드 IaaS(Infrastructure as a Service) 플랫폼 솔루션을 통한 VDI 클라우드 인프라 구축을 지원하고 있다.


# 회기분석
* 회귀분석은 독립변수와 종속변수 사이의 구체적인 함수식을 찾아내고, 독립변수로부 터 종속변수를 예측하는 데 그 목적이 있다.
* 선형회귀, 다중회귀분석

## 독립변수
- 독립변수는 연구자가 의도적으로 변화시키는 변수를 말합니다.
- 독립변수는 영어로 Independent variable입니다. 말 그대로 독립적인 변수입니다. 통계에서 독립적이라는 말은 다른 변수에 영향을 받지 않는다는 뜻입니다. 따라서 독립변수는 다른 변수에 영향을 받지 않습니다. 오히려 종속 변수에 영향을 주는 변수 입니다. 
* 회귀분석에서 다른 변수에 영향을 주는 원인에 해당하는 변수를 독립변수(independent variable) 또는 설명변수(explanatory variable)라고 하며

## 종속변수
- 영향을 받는 결과에 해당하는 변 수를 종속변수(dependent variable) 또는 반응변수(response variable)라고 한다. 
- 종속변수는 연구자가 독립변수의 변화에 따라 어떻게 변하는지 알고 싶어하는 변수를 말합니다.
- 그렇다면 종속변수는 무엇일까요? 종속변수는 영어로 Dependent variable 입니다. 말 그대로 종속적인 또는 의존적인 변수입니다. 즉 독립변수에 영향을 받아서 변화하는 변수를 종속변수라고 생각하시면 됩니다. 
- 조금 어렵나요? 더욱 쉽게 설명하면 독립변수는 연구자가 마음대로 조정할 수 있는 변수입니다. 왜 일까요? 바로 독립변수가 어떻게 변화하느냐에 따라 종속변수가 어떻게 변화하는지 보고 싶기 때문이죠. 이 때문에 독립변수는 원인변수 (Explanatory variable), 예측 변수 (Predictor variable)라고 부르기도 합니다. 반면에 종속 변수는 연구자가 알고 싶어하는 변수입니다. 연구자의 목표는 독립변수를 조정하여 변화시킬 때 종속변수가 어떻게 변화하는지 알아내는 것 입니다. 이 때문에 종속변수를 반응 변수 (Response variable), 결과 변수 (Outcome variable)이라고 부르기도 합니다. 

## MAE
* Mean absolute error
* -통계에서 평균 절대 오차는 두 연속 변수의 차이를 측정 한 것입니다

# 판다스, 맷플롯립
## 판다스
1. 시리즈(Series): 시리즈 클래스는 1차원 배열의 값(values)에 각 값에 대응되는 인덱스(index)를 부여할 수 있는 구조를 갖고 있습니다.
2. 데이터프레임(DataFrame): 은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스(index)와 열방향 인덱스(column)가 존재합니다. 즉, 행과 열을 가지는 자료구조입니다. 시리즈가 인덱스(index)와 값(values)으로 구성된다면, 데이터프레임은 열(columns)까지 추가되어 열(columns), 인덱스(index), 값(values)으로 구성됩니다.
3. 패널(Panel)

## 넘파이
* Numpy(보통 "넘파이"라고 발음.)는 수치 데이터를 다루는 Python 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.

## 사이킷런
*  머신러닝 학습용 패키지다. 대부분의 머신러닝 모형을 제공하므로 파이썬으로 머신러닝을 공부하는 데 최적의 학습 도구다.
* https://book.coalastudy.com/data-science-lv1/week3/stage3

### Training set
* 모델의 학습에 사용되는 데이터

### Validation set
* 모델 제작 과정 중, 학습된 모델의 성능을 측정하기 위한 데이터
### Test set 모델의 최종 성능을 평가하기 위한 데이터
* 모델의 최종 성능을 평가하기 위한 데이터


## 맷플롯립
* Matplotlib는 데이터를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이해를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.

## Seaborn¶
* Seaborn("시본"이라고 읽는다) 패키지는 Matplotlib 패키지에서 지원하지 않는 고급 통계 차트를 그리는 통계용 시각화 기능을 제공한다.



# 신경망 알고리즘
* Artificial neural network (ANN)는 딥 러닝의 가장 핵심적인 기술로써, 신경 세포인 neuron을 추상화한 artificial neuron으로 구성된 네트워크이다. ANN은 일반적으로 어떠한 형태의 function이든 근사할 수 있는 universal function approximator로도 알려져 있다. 이 글에서는 ANN을 구성하는 가장 작은 요소인 artificial neuron부터 multi-layer ANN과 이를 학습시키기 위한 algorithm에 대해 서술한다.
* 일반적으로 사용되는 기본적인 인공신경망 알고리즘인 다층인공신경망(multi-layer neural network)의 경우 아래 그림과 같이 입력층(input layer), 은닉층(hidden layer), 그리고 출력층(output layer),이렇게 세가지 층으로 구분이 됩니다. 그리고 각 층들은 노드들로 구성되어 있습니다. 아래 그림의 예에서는 입력층은 4개의 노드, 은닉층은 3개의 노드, 그리고 출력층은 1개의 노드를 가지고 있습니다.
* 입력층은 예측값(출력변수)을 도출하기 위한 예측변수(입력변수)의 값들을 입력하는 역할을 합니다. 만약 n개의 입력 값들이 있다면 입력층은 n개의 노드를 가지게 됩니다. 은닉층은 모든 입력노드부터 입력값을 받아 가중합을 계산하고, 이 값을 전이함수에 적용하여 출력층에 전달하게 됩니다. 각 입력노드와 은닉노드들은 모두 가중치를 가지는 망으로 연결되어 있으며 은닉노드와 출력노드도 마찬가지로 연결되어 있습니다.
* 이 가중치는 연결강도로 표현되며 랜덤으로 초기에 주어졌다가 예측 값을 가장 잘 맞추는 값으로 조정되게 됩니다. 전이함수는 비선형함수를 사용하게 되며, 이러한 전이함수를 통하여 출력층에 예측 값이 전달되기 때문에 인공신경망이 비선형 모델로서 역할을 할 수 있게 됩니다.
* https://blog.lgcns.com/1359

## 의사결정트리
* 의사결정나무는 데이터를 분석하여 이들 사이에 존재하는 패턴을 예측 가능한 규칙들의 조합으로 나타내며, 그 모양이 ‘나무’와 같다고 해서 의사결정나무라 불립니다. 질문을 던져서 대상을 좁혀나가는 ‘스무고개’ 놀이와 비슷한 개념입니다. 한번 예를 들어볼까요?
* 의사결정나무는 분류(classification)와 회귀(regression) 모두 가능합니다. 범주나 연속형 수치 모두 예측할 수 있다는 말입니다. 의사결정나무의 범주예측, 즉 분류 과정은 이렇습니다. 새로운 데이터가 특정 terminal node에 속한다는 정보를 확인한 뒤 해당 terminal node에서 가장 빈도가 높은 범주에 새로운 데이터를 분류하게 됩니다. 운동경기 예시를 기준으로 말씀드리면 날씨는 맑은데 습도가 70을 넘는 날은 경기가 열리지 않을 거라고 예측합니다.


## 텍스트와 이미지 딥러닝 기법
* 텍스트 인식 기능, 이미지 딥러닝: 


# SPRING ?
## EJB

## POJO

## IOC

## FACTORY 패턴

## SINGLE톤

## FRONT CONTROLLER



# MVC 패턴 로직
1. 프리젠테이션 계층 
 * ◆ 역할 : 프리젠테이션 계층은 말 그대로 사용자 인터페이스에 불과하다. 식당을 예로 들면 손님이 접하게 되는 메뉴판과 전달될 음식을 차려놓는 식탁에 해당한다. 
 * ◆ 기능 : 사용자가 선택할 수 있는 기능이 표시되어 있어야 하고, 요청에 필요한 부가적인 정보 전달을 위한 입력 양식이 있어야 한다. 또한 전달된 자료를 효과적으로 보여주기 위한 프리젠테이션 로직이 포함된다. 하지만 비즈니스 로직이나 퍼시스턴스 계층에서 처리하는 일을 직접 수행하거나(스크립트 릿 사용), 각 계층의 컴포넌트와 직접적인 통신이 있어선 안된다. 
 * 모든 요청은 제어 계층을 통해 처리되어야 한다는 뜻이다. 고급 레스토랑(엔터프라이즈 시스템)에서는 웨이터(지배인)를 통해서만 요구를 전달하고, 그 결과를 전해들어야 한다. 직접 주방장에게 주문을 하거나 자기가 직접 요리를 하는 것은 자기 집(프로토타입)이나 동네 자장면 가게(소규모 웹 애플리케이션)에서나 가능한 일이다. 
 * ◆ 대안 기술 : 현재 가장 주류를 이루는 기술은 JSP 1.2와 JSTL과 같은 태그 라이브러리를 결합하는 방식이다. 과도기적인 형태로 벨로시티와 타일즈 태그 라이브러리가 결합된 형태도 현재 주목을 받고 있다. 하지만 점차적으로 JSF에 기반한 JSP 2.0에 주류 기술로 옮겨갈 가능성이 크고, 프리젠테이션 계층 개발에 있어서도 JSF를 지원하는 IDE를 채택하는 경우가 늘어날 것이다. 
 * ◆ 주요 패턴 : Composite View 패턴 



2. 제어 계층 
 * ◆ 역할 : 제어 계층은 프리젠테이션 계층과 비즈니스 로직 계층을 분리하기 위한 컨트롤러를 제공한다. 식당으로 치자면 지배인의 역할과 종업원의 역할을 병행하는 것이라고 볼 수 있다. 
 * ◆ 기능 : 전체 시스템의 설정 상태를 유지해야 하며, 그를 통해 어떤 요청이 들어왔을 때 어떤 로직이 처리해야 하는지를 결정한다. 사용자 요청을 검증하고 로직에 요청을 전달하는 일과 로직에서 전달된 응답을 적절한 뷰에 연결짓는 것 역시 제어 계층의 몫이다. 
 * 손님이 바다가재 요리를 요청했을 때 종업원은 그 요리가 서비스 가능한 것인지 또한 누구에게 시키면 되는지를 알고 있어야 한다는 뜻이다. 요청을 전달받은 요리사가 바다가재 요리를 주면 그것을 식탁까지 운반해 주는 것 역시 종업원의 몫이다. UI 검증, 요청 및 응답 전달, 로직에서 던져진 예외 처리, 도메인 모델을 뷰와 연결하기 등의 고유 기능 외에는 어떤 기능도 포함하지 않는다. 
 * ◆ 대안 기술 : 현재 WAF들은 대부분 제어 계층의 핵심 기능을 포함한다. 터빈이나 에스프레소 등이 선전하고 있지만, 스트럿츠와 웹워크가 대세라고 생각된다. 당분간 별다른 대안 기술이 등장할 가능성은 적다. 오히려 스트럿츠를 확장시켜 자사 고유의 프레임워크로 최적화 시키는 작업이 활발히 진행될 것이다. 
 * ◆ 주요 패턴 : Front Controller 패턴, Service to Worker 패턴(또는 Command 패턴), Intercepting Filter 패턴, Application Controller & Context Object 패턴 


3. 비즈니스 로직 계층 
 * ◆ 역할 : 비즈니스 로직은 말 그대로 핵심 업무를 어떻게 처리하는지에 대한 방법을 기술하는 곳이다. 식당에서 종업원이 고객의 요구를 전달해 주면, 재료를 이용해 요리를 만드는 요리사라고나 할까? 비즈니스 로직 계층은 애플리케이션에서 가장 재사용될 확률이 높은 요소이기 때문에 신경 써서 설계해야 한다. 
 * ◆ 기능 : 비즈니스 로직에는 핵심 업무 로직의 구현과 그에 관련된 데이터의 적합성 검증 외에도 다양한 부가적인 구현이 추가된다. 트랜잭션 처리라든가, 다른 계층들과 통신하기 위한 인터페이스를 제공한다거나, 해당 계층의 객체들간의 관계를 관리하는 것 등이 그것이다. 
 * 비즈니스 로직 계층에 있어야 할 코드들이 프리젠테이션 계층이나 퍼시스턴스 계층에 여기저기 흩어져 있는 애플리케이션을 찾아보기란 그리 어려운 일이 아니다. 이런 구조는 각각의 계층을 모호하게 만들어 유지보수시 많은 시간을 필요로 하게 만든다. 
 * 가장 신경 써서 개발해야 할 비즈니스 로직에 그동안 신경을 쓰지 못했다는 것. 프리젠테이션 계층과 퍼시스턴스 계층 사이의 다리 역할을 충실히 하도록 함으로써 애플리케이션에 유연성을 더하는 것. 그것이 스프링이 탄생하게 된 배경이라고 할 수 있다. 
 * ◆ 대안 기술 : 지금까지 비즈니스 로직의 구현은 크게 EJB를 사용하는 것과 일반 자바 객체(POJO)를 사용하는 것으로 나눌 수 있었다. EJB를 사용하는 경우 개발자들의 많은 불만이 EJB 3.0을 사용함으로써 해결되리라 예상된다. 하지만 해외를 중심으로 해서 EJB를 사용하건, 사용하지 않건 비즈니스 로직들을 체계적으로 관리하는 IoC 컨테이너에 대한 관심이 증가하고 있는 추세이다. IoC 컨테이너에 대해서는 뒤에서 다시 자세히 살펴보도록 하겠다. 
 * ◆ 주요 패턴 : Business Delegate 패턴, Session Facade 패턴, Service Locator 패턴, Application Service 패턴, EJB Home Factory 패턴 

4. 퍼시스턴스 계층 
 * ◆ 역할 : 퍼시스턴스 계층은 데이터 처리를 담당하는 계층이다. 주로 데이터의 생성/수정/삭제/선택(검색)과 같은 CRUD 연산을 수행하게 된다. 식당으로 보자면 주방장이 사용할 재료를 담당하는 재료 담당자라고나 할까? 이 데이터는 주로 데이터베이스에서 처리되는 경우가 많아, 영속성을 의미하는 퍼시스턴스 계층이란 용어를 사용했다. 하지만 데이터가 처리되는 다른 업무 시스템이나, 웹 서비스, XML, 파일 시스템 등을 모두 고려한다면 레거시 개념을 갖는 EIS 계층이란 표현이 더 적합할 것이다. 
 * ◆ 기능 : 이 계층에서 수행하는 일은 관계형 정보를 저장하고, 수정/삭제하는 것과, 그러한 일을 수행하는 데 필요한 질의문을 관리하는 것, 그리고 가져온 관계형 정보를 객체화시키는 일이다. 
 * ◆ 대안 기술 : EJB 사용에 있어서 개발자들이 가장 불만스러워 하는 것은 CMP 방식의 엔티티 빈일 것이다. 그러한 불만은 객체 관계 맵핑(ORM)을 이용한 JDO라는 대안기술을 탄생시켰고, 또한 하이버네이트라는 또 하나의 오픈소스 기술을 실무로 끌여들였다. JDBC를 이용한 DAO 객체를 구성하는 방법도 소규모 애플리케이션에서는 여전히 인기를 끌고 있다. EJB 3.0과 JDO/하이버네이트, 그리고 JDBC를 이용한 POJO 방식 중 어떤 것이 개발자들에게 낙점될 지는 아직 미지수다. 
 * ◆ 주요 패턴 : Data Access Object 패턴, Domain Store 패턴, Sequence Blocks 


5. 도메인 모델 계층 
 * ◆ 역할 : 도메인 모델은 각 계층 사이에 전달되는 실질적인 비즈니스 객체라고 할 수 있다. 식당을 예로 든다면, 음식이 담긴 그릇이라고 비유할 수 있겠다. 
 * ◆ 기능 : 도메인 모델 계층은 흔히 데이터 전송 객체(DTO) 형태로 개발자가 직접 제작해서, 리퀘스트나 세션과 같은 컨텍스트에 담아 넘기게 된다. 하지만 데이터베이스의 모든 정보를 일일이 객체로 만드는 것은 귀찮을 뿐 아니라, 계층간의 통신 과정에서 데이터가 유실될 위험도 있기 때문에 최근에는 도메인 모델을 서비스로 제공하여 자동화하는 경우가 많다. 
 * ◆ 주요 패턴 : Data Transfer Object 패턴, Value List Handler 패턴 
 * 지금까지 엔터프라이즈 시스템을 구축하기 위해 일반적으로 사용되는 다섯 계층에 대해 간단히 정리해 보았다. 뻔한 이야기들을 길게 늘여 쓴 이유는 2가지 사실을 강조하기 위해서이다. 첫째, 각각의 계층은 저마다의 분명한 역할이 존재하며, 그 역할을 충실히 수행할 수많은 대안기술(Alternative)들 사이에서 개발자는 무엇을 선택할 지 결정을 내려야 한다. 둘째, 각각의 기술들은 독립적으로도 충분한 가치를 지니고 있지만, 가장 장점을 발휘하는 제 위치에서 서로 연계되어 사용될 때 그 시너지 효과가 더욱 크다. 





# 자바
## DAO
- Data Access Object 의 약자로 데이터베이스의 data에 접근하기 위한 객체입니다.
- DataBase 접근을 하기 위한 로직과 비지니스 로직을 분리하기 위해 사용합니다.
- DAO의 경우는 DB와 연결할 Connection 까지 설정되어 있는 경우가 많습니다.
- 그래서 현재 많이 쓰이는 Mybatis 등을 사용할 경우 커넥션풀까지 제공되고 있기 때문에 DAO를 별도로 만드는 경우는 드뭅니다.
- 출처: https://lemontia.tistory.com/591 [안녕하세요]

## DTO(Data Transfer Object), VO 차이
- 여기서 말하는 계층간의 의미는 Controller, View, Business Layer, Persistent Layer 
-       전송되는 데이터의 컨테이너이다.
-       VO와 동일하게 데이터를 저장하여 사용하도록 하는 부분에서 필요하다.
-       VO와 비교를 하여 보면 DTO는 같은 시스템에서 사용되는 것이 아닌 다른 시스템으로 전달하는 작업을 처리하는 객체이다.
-       Layer간의 통신 용도로 오가는 객체를 말하기도 한다.
-       현재의 개발 환경에서 보통 데이터는 다음과 같이 흐름으로 이동한다.
- n   서버 측 : Database Column Data -> DTO -> API(JSON or XML) -> Client
- n   클라이언트 측 : Server -> API(JSON or XML) -> DTO -> View or Local Database System

## VO(Value Object)
-       데이터 그 자체로 의미 있는 것을 담고 있는 객체이다.
-       DTO와 동일한 개념이나 차이점은 Read–Only 속성 객체이다.
-       간단한 독립체( Entity )를 의미하는 작은 객체를 의미한다. 
-       관계데이터베이스의 레코드에 대응되는 자바클래스이다.
- n   형태는 Database레코드를 구성하는 필드들을 VO의 Attribute로 하고 해당 변수에 접근 할 수 있는 Getter와 Setter 메소드의 조합으로 클래스를 형성되어진 클래스이다.
- n   거의 불변성을 가지고 equals()로 비교할 때 객체의 모든 값을 비교해야 한다.

### 차이
   - VO : 사용 되는 값이 객체로 표현 되며, 값 변경이 없는 경우를 말한다.
-       DTO : 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용하기 한다.
- 예를 들어 외부 시스템과 데이터 통신을 할 경우에는 DTO로, DB에서 가져오는 Data는 VO로 정의해서 사용한다고 약속을 하면, 향후 DTO/VO를 수정할 경우 좀 더 고민할 여지가 생길것 같다.
- DTO와 VO의 공통점은 넣어진 데이터를 getter를 통해 사용하므로 주 목적은 같습니다. 그러나 DTO의 경우는 가변의 성격을 가진 클래스 입니다(setter 활용). 그에반해 VO는 불변의 성격을 가졌기에 차이점이 있습니다. 



### 예제
```JAVA
DTO a = new DTO(1);

DTO b = new DTO(1);

이라고 했을 때 a != b 이지만,

VO a = VO(1);

VO b = VO(1); 이라고 했을때는 a == b라고 정의하는 형태입니다.

출처: https://itmore.tistory.com/entry/자바-VO-DTO-차이점사용하는-방식이-같다고-똑같다고-생각하지-말자 [IT모아]
```

# 서버

## 세션
* 세션이란 일정 시간동안 같은 사용자(정확하게 브라우저를 말한다)로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이라고 한다.
* 페이지를 이동해도 사용자의 로그인 상태를 유지하는 기능을 생각해 봅시다. 앞서 살펴본 쿠키를 이용해서 사용자의 아이디와 비밀번호를 쿠키에 저장한다고 가정해 봅시다. 페이지를 이동하여도 쿠키를 통해 아이디와 비밀번호를 서버에 전달해서 서버에서는 사용자를 식별하여 해당 사용자의 로그인 상태를 유지시킬 수 있습니다. 하지만 이렇게 쿠키만을 이용하여 인증을 구현하면 쿠키가 유출, 조작 될 수 있는 보안상 매우 큰 문제가 됩니다. 개인 소유가 아닌 컴퓨터에서 사용할 경우 누구나 그 사용자의 비밀번호를 확인할 수 있고 HTTP로 개인 정보를 주고 받는 것은 매우 위험합니다.
* Session은 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONID(session id)를 저장합니다. 서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장합니다. 보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용합니다.
* 세션 기간 조정 안하면 많은 VMWare가 켜져 있어 서버가 느려질 우려


### 세션의 동작 순서
* 클라이언트가 서버에 처음으로 Request를 보냄 (첫 요청이기 때문에 session id가 존재하지 않음)
* 서버에서는 session id 쿠키 값이 없는 것을 확인하고 새로 발급해서 응답
* 이후 클라이언트는 전달받은 session id 값을 매 요청마다 헤더 쿠키에 넣어서 요청
* 서버는 session id를 확인하여 사용자를 식별
* 클라이언트가 로그인을 요청하면 서버는 session을 로그인한 사용자 정보로 갱신하고 새로운 session id를 발급하여 응답
* 이후 클라이언트는 로그인 사용자의 session id 쿠키를 요청과 함께 전달하고 서버에서도 로그인된 사용자로 식별 가능
* 클라이언트 종료 (브라우저 종료) 시 session id 제거, 서버에서도 세션 제거


### 세션의 특징
* 세션 아이디는 브라우저 단위로 저장되고 브라우저 종료시 소멸됩니다.
* 로그인한 사용자에 대해서만 세션을 생성하는 것이 아닙니다. 따라서 로그아웃하면 새로운 사용자로 인식해서 새로운 세션이 생성됩니다.
* 사용자가 로그인 했는지, 닉네임 등의 사용자가 요청 할 때 마다 필요한 청보들을 세션에 담아두면 사용자 디비에 접근할 필요가 없어서 효율적입니다.

### 세션 보안
* 누군가 어떤 사용자의 세션 아이디를 훔친다면 그 사용자처럼 로그인할 수 있게 됩니다. https를 이용해서 통신 하는 것이 좋고 cookie와 마찬가지로 session의 옵션으로 secure을 true로 주면 https에서만 세션 정보를 주고받을 수 있고 HttpOnly을 true를 주면 js를 통해서 세션 쿠키를 사용할 수 없도록 강제할 수 있습니다.



### 쿠키
* 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터라고 했습니다. 쿠키의 데이터 형태는 Key 와 Value로 구성되고 String으로만 이루어져 있습니다. 4KB 이상 저장할 수는 없습니다.
* 쿠키가 있기 때문에 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있는 것입니다. (쿠키가 없다면 다음 페이지로 정보를 파라미터로 넘겨줘야 합니다.)
  * ID 저장, 로그인 상태 유지
  * 7일간 다시 보지 않기. (쿠키에 체크한 날짜를 기록하여 다시 방문 했을 때의 시간과 시차를 이용하여 계산)
  * 최근 검색한 상품들을 광고에서 추천
  * 쇼핑몰 장바구니 기능

### 세션과 쿠키의 차이
- 쿠키의 경우는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말한다
- 예를 들자면 ID나 비밀번호를 저장하거나 방문한 사이트를 저장하는데에 사용한다. (IE 인터넷 옵션에서 검색 기록 삭제할때 임시 파일, 열어본 페이지 목록, 쿠키, 저장된 암호 및 웹 양식 정보 삭제라고 되어있지 아니한가)
- 세션은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는것을 말한다.

### HTTP Session 동작 순서
1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.
2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.
3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.


# 웹
## Get 방식
* GET 방식은 전송할 파라미터 값들을 시작 라인의 URL 정보에 붙여서 같이 전송하며 파라미터의 길이가 256바이트를 넘을 수 없지만 본문(Body)이 필요 없기 때문에 전송 속도가 POST 방식에 비해 빠르다.


## Post 방식
* POST 방식은 파라미터 값들을 요청 메시지의 본문(Body)에 담아서 전송하기 때문에 길이의 제약이 없다.
⎼ HTTP 헤더 속으로 정보가 감춰지고 반드시 HTML 폼을 통해서만 사용할 수 있다.

#  데이터베이스
## 오라클
- MySQL과 달리 오라클은 대용량 데이터 베이스라고 하는데, 대용량 데이터 타입(CLOB; 4GB까지 가능) 까지 가질 수 있다.


## to_char 규칙
- 자바, C언어, 자바스크립트 등 언어마다 날짜 format이 다른데 그때마다 변환하기는 복잡하니 언어끼리는 String으로 교환하고 마지막에 오라클에서 to_char로 바꿔날짜로 바꿔주면 다른 코드들도 짧아지고 편해진다.
- 넘겨주기 전 언어가 Comparable, Serializable 등 기능을 가진 언어여야 함.(객체지향 언어는 대부분 보유; PHP같은 언어는 안됨)
- ① 형식 모델은 단일 따옴표로 묶어야 하며 대소문자를 구분한다. 
- ② 형식 모델은 임의의 유효한 날짜 형식 요소를 포함할 수 있지만 쉼표를 사용하여 날짜값을 형식 모델과 구분해야 한다. 
- ③ 자동으로 출력의 일 및 월 이름은 공백으로 채워진다. 
- ④ 채워진 공백을 제거하거나 선행 0 fmt . 을 출력하지 않으려면 채우기 모드 요소를 사용한다
