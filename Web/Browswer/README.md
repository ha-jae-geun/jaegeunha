# [브라우저에서 페이지 나타나는 순서](https://bearjin90.tistory.com/m/19)

# [Reflow, Repaint](https://webclub.tistory.com/346)

# [Reflow와 Repaint의 관계](https://boxfoxs.tistory.com/408)
* 조건 Reflow가 일어나야 Repaint가 일어나는것은 아닙니다. background-color, visibility와 같이 레이아웃에는 영향을 주지 않는 스타일 속성이 변경되었을 때는 Reflow를 수행할 필요가 없기 때문에 Repaint만 수행하게 됩니다.

출처: https://boxfoxs.tistory.com/408 [박스여우 - BoxFox]

출처: https://boxfoxs.tistory.com/408 [박스여우 - BoxFox]

# [브라우저에 URL 입력했을 때](https://deveric.tistory.com/m/97)
```java
"브라우저에 도메인을 입력하면 → DNS서버에 IP주소를 요청 → 수신한 IP주소에 해당하는 웹서버에 접속"

1. 로컬PC의 hosts파일 확인 ( 브라우저에 캐싱되어 있는지 먼저 확인하자 )


 로컬PC의 C:\Windows\System32\drivers\etc 경로(윈도우 설치 경로에 따라 
 조금 차이가 있을 수 있음)에는 hosts라는 파일이 있다. 이 파일을 메모장으로 열어보면, 
 IP주소와 도메인 주소를 설정할 수가 있다. 이 파일은 PC의 자체 DNS역할을 하며, 
 브라우저는 가장 먼저 이 파일을 확인하여 입력한 도메인의 매핑정보가 존재하는지 확인한다.


2. DHCP&ARP

  대부분 가정집에서는 DHCP로 인터넷 접속을 하고 있을 것이다.
  DHCP는 Dynamic Host Configuration Protocol의 약자로, 
  호스트의 IP주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜이다. 
  사용자의 PC는 DHCP서버에서 사용자 자신의 IP주소, 가장 가까운 라우터의 IP주소, 
  가장 가까운 DNS서버의 IP주소를 받는다. 이후, 
  ARP 프로토콜을 이용하여 IP주소를 기반으로 가장 가까운 라우터의 MAC주소를 알아낸다.



3. IP 정보 수신

 2의 과정을 통해 외부와 통신할 준비를 마쳤으므로, 
 DNS Query를 DNS 서버에 송신한다. DNS 서버는 이에 대한 결과로, 웹 서버의 IP 주소를 사용자 PC에 돌려준다. 



4. 웹 서버 접속

 이제 웹 서버의 IP주소까지 알았다. Http Request를 위해, TCP Socket을 개방하고, 연결한다. 
 이 과정에서 3-Hand-Shaking이 일어난다. TCP 연결에 성공하면,
 Http Request가 TCP Socket을 통해 보내진다. 이에 대한 응답으로, 웹 페이지의 정보가 사용자의 PC로 들어온다.
```

# [UI 최적화](https://ui.toast.com/fe-guide/ko_PERFORMANCE)

# [크로스 브라우징](https://okayoon.tistory.com/entry/%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95cross-browsing)

# 크로미움 기반
```java
Brave
웹 사이트 트래커와 광고를 차단하며 대부분의 OS에서 사용가능하다.


오페라
과거부터 지금까지 많은 사용자를 유지하며 꾸준히 업데이트를 
이어오고 있는 오페라 역시 크로미움 기반으로 개발환경을 변경했다.

 
삼성브라우저
모바일 전용 브라우저로 삼성에서 개발 배포한 
삼성브라우저 역시 크로미움 기반의 브라우저다.

 
Cốc Cốc
베트남 브라우저 시장을 목표로 만들어진 브라우저로 
공개와 동시에 베트남 시장에서 상당한 점유율을 높이고 있다.

 

웨일
위에서 언급한 웨일 역시 크로미움 기반으로 
개발되었으며 네이버 서비스와 사용자 환경 개선에 중점을 둔 브라우저다.

 

엣지
얼마전 공개한 마이크로소프트 사의 
웹 브라우저 엣지 역시 크로미움 기반에서 개발되었다.


```

# [Brave -> 브레이브 브라우저](https://www.youtube.com/watch?v=lyljGJBK1hI)
* 보안에 중점(자바스크립트 창립자 브랜든 아이크가 만듬)
1. 광고 제거
2. 웹 트래커 제거
3. 사생활 보호
4. 크로미움 기반이라 속도도 빠름
5. 블록체인 기반 웹브라우저 정식 버전 출시
  * 브레이브에 포함된 수익화 시능이 이용자 프리이버시를 해치고 있음
  

# 넷스케이프
- MS에서 익스플로러를 windows 95 plus!에서 부터 끼워팔기 해서 넷스케이프 점유율이 50%까지 추락하였으며 이후에 windows 98에서 부터 끼워팔기를 해서 점유율을 떨어뜨려 개망하게 된 것입니다.


# 인터넷 익스플로우
- 11버전: trident, 12버전: msie

## [웹 표준](https://www.youtube.com/watch?v=T8r-6mMlzWg)
* 브라우저마다 차이가 없도록 웹표준을 정해놓음
* W3C(HTML, CSS 표준 정함) + ECMA(자바스크립트 관장) + IETF(국제 인터넷 표준화 기구)
* 인터넷 익스플로우는 브라우저 시장을 장악한 후 웹 표준을 잘 지키지 않았음
* 어떤 브라우저에서 지원하는 자바스크립트 버전까지 확인해야 함

## IE를 버전마다 크로스 브라우징하는 이유.
* 최신 버전으로 자동 업데이트가 되는 브라우저가 많으나 IE는 해당되지 않는다.
* IE는 사용자가 직접 업데이트를 진행해야 하며, 윈도우 버전에 따라 최대 버전이 한정되어 있다.


# 크롬
- 크롬은 빠른 속도와, 구글과의 연동 기능으로 평이 좋고 널리 쓰이는 브라우저입니다. 구글에서 받쳐주는 브라우저이기 때문에, 각종 미디어 코덱의 지원도 빵빵하고, 구글 계열의 제품들인 구글 닥스, Gmail, 행아웃, 유튜브, 애드센스, 구글 지도 등과의 연계도 당연히 잘 될수밖에 없습니다. 또, 속도가 빠른 편이기도 합니다.
- 하지만, 이런 크롬에도 단점은 있겠죠? 크롬은 각 탭을 별개의 프로세스로 관리합니다. 그 말인 즉슨, 탭 두개를 열면 크롬 2개가 구동되는 메모리와 같다는 말이죠. 때문에 사양이 낮은 컴퓨터에서는 다른 브라우저에 비해 상당히 무겁게 느껴지는 브라우저인 것도 사실입니다.


## [구글 크롬 시크릿모드](https://www.youtube.com/watch?v=08wJD5gd3LE&list=PLLcbGhhl4sQBsbOznDyPShoZektZHf6g1&index=11)

## [윈도우 OS 오픈소스](https://www.youtube.com/watch?v=xRxsryZuQ9Q&list=PLLcbGhhl4sQBsbOznDyPShoZektZHf6g1&index=13)


# 파이어폭스
- 탭 브라우징에도 많이 신경을 쓴 부분이 보입니다. 글을 쓰다보면 이리저리 참고할 부분이 많은데, 이렇게 탭을 많이 열어놓고 참고해서 쓰고, 또 열다보면 어느새 열려있는 탭이 수십개가 되는 경우가 생깁니다. 이럴 때에 타 브라우저에 비해서 탭을 잘 관리하도록 도와주는 브라우저가 파이어폭스입니다. 탭을 좌우로 드래그해서 보기, 모든 탭 북마크 지정, 이 탭을 제외하고 모두 닫기, 닫은 탭 되돌리기.. 이런 기능들이 다른 브라우저들과 겹치는 기능일지도 모르겠지만, 실제로 사용할때에 가장 편리하다는 느낌을 받은 브라우저는 파이어폭스인것 같네요.
- 이런 파이어폭스의 단점이라면, 아무래도 큼지막한 회사 애플, 마이크로소프트, 구글에서 만드는 다른 브라우저들과 달리 비영리인 재단에서 만드는지라 유튜브에서 60fps 동영상도 지원하지 않는다는 기사를 얼마 전에 본 것 같습니다.
 
# 사파리
- 애플에서 개발하는 브라우저입니다. 따라서 아이폰/패드/팟 같은 애플의 모바일 기기에서는 기본으로 내장되어있기 때문에 점유율이 상당히 높지만, 본 글은 PC의 5대 브라우저에 대해 설명하는 글이기 때문에 PC를 기준으로 말씀드리겠습니다. 윈도우용의 경우에는, 솔직히 말하자면 타 브라우저보다 월등히 나은 점을 발견하기 힙듭니다. 사파리의 개발목적이 윈도우와는 먼 탓도 있고요. 또 개인용 컴퓨터에서 매킨토시를 쓰는 분들이 윈도우에 비해 많이 적기에, PC에서의 위상이 많이 크지는 않습니다. 하지만 5대 브라우저에 포함되는 만큼, 웹 프로그램 개발을 할 때에나 사이트를 만들 때에 절대 무시할수 없는 브라우저이기도 하죠.

# 오페라
- 오페라는 노르웨이의 오페라 소프트웨어에서 개발하고 배포하는 브라우저로, 가늘고 길게 연명해온 것이 특징이라고 할 수 있겠습니다. 또한 굉장히 다양한 플랫폼을 지원하고 있어서, 사파리와 마찬가지로 PC에서보다는 모바일/PDA 기기에서 영향력이 큰 브라우저이기도 합니다. 안드로이드에서의 오페라 미니, 아이패드에서의 오페라 코스트처럼 본래 오페라와 차이가 조금 있는 갈래들을 내기도 하고요.
- 우선 오페라는 다양한 환경, 특히 느린 네트워크에서 돌아가는 것에 상당히 신경을 써둔 브라우저입니다. 오페라 터보 기능(느린 네트워크에서 더 빨리 받을 수 있도록, 웹 페이지를 압축한 뒤 보내주어 로딩 속도를 빠르게 해주는 기능)이 그 대표적인 예라고 할 수 있겠지요. '오페라만의' 분위기나 개성이 강한 편이라, 고정 사용자층이 있는 편입니다.
 
## 브라우저 특징
1. html 지원하는 형태
2. 각 브라우저의 공통으로  레이아웃 지원



# 원격 네트워크
- 브라우저를 이용하지 않은 연동
- 브라우저를 이용한 연동은 ‘웹’이라는 말이 들어간다.

# 브라우저
* 익스플로어, 엣지, 파이어폭스, 크롬, 오페라, 사파리

## 시크릿 모드
* 입력정보를 보관하지 사용자 PC에 않음
  * 서버에서 추적이 가능하다고 해서 문제생김
* 캐시(임시파일)를 보관하지 않음
* 쿠키를 보관하지 않음


# 브라우저
```java
브라우저
 

브라우저란
브라우저는 서버에 자원을 요청(reqest)하고 그걸 응답(response)해 윈도우에 표시하는 역할을 합니다.

HTML 파일이나 CSS 파일, 이미지 등이 서버에서 넘어오면 파싱(Parsing)이란 작업을 거쳐 화면에 그려냅니다.

 

이 과정에서 '어떻게 해석할까?'의 방식은 브라우저마다 조금씩 다릅니다. 과거에는 다들 개성이 폭발했지만, 지금은 '그래도 표준 명세가
있어야지'라는 공감 아래 웹 표준을 바탕으로 브라우저가 동작합니다. 

참고로 앞으로의 HTML5 & DOM 표준은 WHATWG가 담당한다고 합니다. (출처 기사: "둘로 나뉜 웹 표준, 하나로 합쳐진다")

 

 

 

브라우저의 구조
 


 

 

사용자 인터페이스

웹 URL을 보여주는 주소 표시 줄, 앞/뒤로 가기, 새로고침, 북마크 표시 줄 등을 뜻합니다. 

 

브라우저 엔진

사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어합니다. 주어진 URL을 읽어들이며, 앞/뒤 페이지로 가거나 새로 고침을 하는 
등의 기초적인 액션을 담당합니다.

 

렌더링 엔진

HTML, CSS 등을 해석해주는 (아마 제가 제일 잘 친하게 지내야 할) 엔진입니다. 네트워크 계층의 데이터를 처리하고 웹 컨텐츠를 화면에 표시해 줍니다. Gecko, Trident, WebKit 등 다양한 렌더링 엔진이 존재합니다.

 

네트워킹

HTTP 리퀘스트와 같은 네트워크 통신을 담당합니다.

 

자바스크립트 해석기

자바스크립트 코드를 해석하고 실행시켜줍니다.

 

UI 백엔드

콤보박스, 윈도우 등 의 기본적인 위젯을 그려줍니다. OS에서 제공하는 UI 메서드를 사용합니다.

 

자료 저장소(Data Persistence)

로컬/세션 스토리지, 쿠키, WebSQL 등의 다양한 브라우저 API로 이루어져 있습니다.

 

 

 

 

렌더링 엔진
친해져야 할 상대를 알았으니(?) 렌더링 엔진이 어떻게 제 마크업과 스타일링을 이해하는지 살펴봅니다.

(아래 용어는 WebKit 기준입니다)

 

1. HTML을 파싱해 DOM 트리를 구성합니다.

2. CSS를 파싱해 CSSOM 트리를 구성합니다.

3. 두 트리를 합쳐서 렌더 트리를 만듭니다.

4. 렌더 트리에서 레이아웃을 실행해 각 노드의 형태를 계산합니다.

5. 렌더 트리의 각 노드를 화면에 페인팅합니다.

 

이 과정이 빠르면 빠를수록 당연히 좋겠죠?

문서가 클수록 브라우저가 수행해야 하는 작업도 더 많아지며, 스타일이 복잡할수록 페인팅에 걸리는 시간도 늘어납니다.

 

 

 

 

 

HTML 파싱
파싱은 제가 준 HTML을 보고 브라우저가 DOM 트리를 만드는 과정입니다.

즉, HTML과 DOM은 다릅니다. HTML은 '여기다가 헤더 만들거고, 그 아래에 타이틀 넣을 거야'라는 요구서같은 거고, DOM은 그걸 보고 
브라우저가 실제로 뚝딱뚝딱 만들어 낸 결과물입니다.

 

HTML의 파싱 과정은 꽤나 '너그럽다'고 합니다. (가끔 닫는 태그 빼먹어도 잘 나올 때 있었던 것 같기도...)

이렇게 너그럽게 실수를 봐주었기에 HTML이 인기가 있었던 건지도 모른다고 하네요.

 

 


HTML 파싱 과정
 

토큰
HTML 내용은 '토큰화'라는 과정을 거칩니다.

토큰화는 대부분의 프로그래밍 언어에서 일반적인 파싱 프로세스로, 이해하기 쉽도록 코드를 여러 토큰으로 분할하는 것을 말합니다.

 

 


브라우저는 태그를 만나면 토큰을 만들어냅니다(emits a token).

<html><head><meta charset="utf-8"/></head><body>Hello</body></html>
예를 들어, <html>를 보면 "시작 태그가 있구나"하고 html 시작 토큰을 만듭니다.

이후 <head>를 보면 "얘도 시작 태그야."라며 head 시작 토큰을 만듭니다. 이런 식으로 mata 토큰, head 종료 토큰을 만들어가다가 
Hello를 보면 문자 토큰을 만듭니다.

 

 


이렇게 토큰 작업이 이루어지는 동안 이 토큰들을 '노드'로 바꾸는 작업도 진행됩니다.

위의 html 토큰은 html 노드가 되고, head 토큰은 head 노드가 되는 거죠.

 

이 과정에서 노드간의 관계성이 생깁니다.

head 시작 토큰은 html 종료 토큰 전에 오기 때문에 head는 html의 자식이 되는 셈이죠. 트리 형태의 구조가 생긴다고 보면 됩니다.

 

 


 

이런 식으로 토큰을 다 소모하면 마침내 DOM이 만들어지게 됩니다. 

 

 

 

노드
트리 구조에서 트리를 구성하는 객체를 노드(node)라고 부릅니다. 영어사전에 검색하면 node는 '나무줄기의 마디'를 뜻한다고 하네요.

HTML의 모든 것은 다 노드입니다. 심지어 독타입 선언도요! 텍스트, 주석도 물론 노드예요.

 

그중에 document node는 root node, 말그대로 뿌리인 노드입니다. 이를 시작점으로 노드들은 가지처럼 뻗어난 형태를 가집니다.

이렇게 아래로 뻗어나가면서 위에 있는 노드는 부모가 되고, 아래 있는 노드는 자식이 됩니다.

자식이 없는 노드는 leaf node라고도 합니다. (이름 참 잘 지었네요)

 

이처럼 DOM은 노드라는 가지와 잎이 난 하나의 나무라고 볼 수 있겠습니다.

 

 

 

DOM
DOM(Document Object Model)이란 HTML 및 XML 문서를 위한 API입니다.

 

DOM은 document(웹페이지)의 문서의 논리적 구조를 노드의 계층 구조 트리로 나타냅니다.

개발자는 자바스크립트를 통해 DOM에 접근하고 조작할 수 있습니다.

HTML과 마찬가지로 DOM도 W3C에서 정한 명세가 있습니다.

 
```

