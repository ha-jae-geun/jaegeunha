# [서블릿](https://www.youtube.com/watch?v=cmwmamOQmPc&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=17)

# 역사
* 웹서버는 정적 데이터 처리에 특화
* 동적 데이터를 처리하는 CGI는 많은 사용자를 처리하기에는 무리
	* 왜냐하면 웹서버와 CGI 구현체 1개가 데이터를 주고 받을 때 구현체 1개 당 1개의 프로세스가 할당
* 서블릿(웹 서버 + 웹 컨테이너)
	* 개선: 프로세스를 Thread 처리로 바꿈
	* 많은 instance 생성에서 Singleton으로
 	* 웹 컨테이너: 요청이 들어오면 Thread를 생성하고 Servlet을 실행시킨다
		* Servlet Interface에 따라 Servlet을 관리한다
	* Servlet Instance
		* Init
		* Service: 실제 기능이 수행되는 곳
			* doGet, doPost, doDelete
		* Destroy: Servlet Instance가 사라진다
			* Container가 종료되는 시점에 destroy 된다
			* 특정 Servlet 로드/언로드 시에 사용
		* 각 메서드는 Servlet Container에서 호출한다
	* Web.xml
		* WAS에서 Servlet 객체 - URL Mapping 정보 알려줌
* Spring Web MVC
	* 이전에는 URL마다 Servlet을 생성하여 Web.xml로 서블릿을 관리했지만 Spring MVC는 DisPatcherSevlet 1개로 관리한다
	
# 서블릿
![서블릿](./image/servlet.JPG)
- 서버에서 실행되는 자바 프로그램(HTML in JAVA)

## 실행 순서
1. 웹 어플리케이션이 실행될 때: ServletContextListner 인터페이스의 contextinitialized 메소드 실행
2. 어노테이션 const 선처리 작업 
3. 해당 서블릿의 웹 서블릿 initParam 메소드 실행(1. web.xml에서 설정하거나 2. annotation으로 실행하거나)
4. do get/ do post
5. 종료 시 서블릿 destroy
6. annotation의  destroy
7. 웹 어플리케이션이 종료될 때: ServletContextListner 인터페이스의 contextDestroyed 메소드 실행

```java
1. annotation

2. 
<web-app>

    <!-- 1. aliases 설정 -->
    <servlet>
        <servlet-name>welcome</servlet-name>
	//매핑할 클래스 파일명을 패키지명을 포함하여 정확하게 입력
        <servlet-class>servlets.WelcomeServlet</servlet-class>
    </servlet>

    <!-- 2. 매핑 -->
    <servlet-mapping>
    	//입의의 이름 입력
        <servlet-name>welcome</servlet-name>
	//  /로 시작해야 한다
        <url-pattern>/welcome</url-pattern>
    </servlet-mapping>

</web-app>
https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html

```

## JSP가 나온 이유
*  HTML을 코딩하기 너무 어렵고 불편해서 HTML 내부에 Java코드를 삽입하는 형식이 JSP이다. 다시 말해 서블릿의 단점을 보완하고자 만든 서블릿 기반의 스크립트 기술이다. 서블릿을 이용하게 되면 웹프로그래밍을 할 수 있지만 자바에 대한 지식이 필요하며 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 등 비효율적인 측면들이 있다. 때문에 서블릿을 작성하지 않고도 간편하게 웹프로그래밍을 구현하게 만든 기술이 JSP(Java Server Pages)이다.
* 조금더 알아보자면 JSP(Java Server Pages)는 서블릿 기반의 '서버 스크립트 기술'이다.
* 여기서 스크립트 기술이란 ASP, PHP 처럼 미리 약속된 규정에 따라 간단한 키둬드를 조합하여 입력하면, 실행 시점에 각각의 키워드에 매핑이 되어 있는 어떤 코드로 변환 후에 실행되는 형태이다.
*  내용만 보게 된다면 서블릿이나 JSP나 만드는 방법에 차이가 있을 뿐 동일한 역할을 한다는 것을 알수 있다. 초기에 자바 웹개발은 서블릿을 이용한 개발이였다. 이후 JSP기술이 발표되면서 JSP형태의 개발이 유행하게 되고 지금에 와서 각각의 역할을 나누어 Servlet+JSP형태의 개발이 이루어지고 있다.
* JSP는 JSP기술의 장점을 최대한 활용 할 수 있는 웹에플리케이션 구조에서 사용자에게 결과를 보여주는 프리젠테이션 층을 담당하고 Servlet은 Servlet기술의 장점을 최대한 활용 할 수 있는 사용자의 요청을 받아 분석하고 비지니스 층과 통신하여 처리하고 처리한 결과를 다시 사용자에게 응답하는 컨트롤러 층을 담당한다.

## JSP와 서블릿의 차이점
### 서블릿
- 자바코드로 구현하고 컴파일하고 배포해야 한다.
- HTML태그로 문자열("")스크림으로 처리해야 한다.
- 코드가 수정되면 다시 컴파일하고 배포해야 한다.

### jsp 주석
* html의 주석은 브라우저에서 코드보기하면 보이지만 JSP는 서버에서 돌아가기 때문에 보이지 않는다.

### JSP 동작원리
1. 웹브라우저 요청
2. jsp에서 서블릿으로 변환
	* helloWorrld.js > helloWorld_jsp.java  로 변환
3. 웹브라우저 응답(HTML형태로 응답)
4. 서블릿 -> 클래스
	* helloWorld_jsp.java -> helloWorld_jsp.class

### JSP
- 키워드가 태그화 되어 서블릿에 비해 배우기 쉽다.
- 자바코드를 <%%>태그 안에 처리해주어야 한다.
- HTML처럼 태그를 사용하여 자바코드도 사용이 가능하다.
* JSP파일은 결국 서블릿으로 변환이 되어 실행된다. JSP파일이 Servlet으로 변환되는 과정은 오직 한번만 일어나므로 같은 페이지에 수많은 사용자의 요청이 있더라도 처리속도는 거의 떨어지지 않게 된다. 만약 JSP페이지의 코딩 내용이 변경된다면 다시 변환 과정을 거친다. 즉 JSP가 서블릿을 기반으로 하고 있기 때문에 JSP의 동작 방식을 이해하기 위해서는 Servlet에 대한 이해도도 필요하다.

## MVC 모델2
* 얼마전까지만 하더라도 JSP만 이용한 개발(Model1 방식)이 유행하다 현재는 유지보수단계에서 많은 단점을 느껴 각각의 역할을 나누어 서블릿과 JSP를 동시에 사용하여 개발하는 방식(Model2 방식)으로 개발하고 있어 현재는 Servlet과 JSP를 나누어 사용하고 있다. 그리하여 JSP는 HTML태그 사용이 용이하고 자바코드 사용이 불편하기 때문에 웹어플리케이션에서 사용자에게 결과를 보여주는 View(Client)를 담당하고 Servlet은 자바코드 작성이 편리하기 때문에 주로 화면과 통신하여 자료를 받아 가공하고 가공한 자료를 다시 화면에 전달하는 Controller역할을 하고 있다.
*  JSP와 Servlet 동시에 사용 MVC모델(View는 JSP, Controller는 Servlet을 사용)
*  프리젠테이션 로직과 비즈니스 로직 분리
(보여지는 부분은 HTML이 중심이 되는 JSP, 다른 자바클래스에게 데이터를 넘겨주는 부분은 Java코드가 중심이 되는 Servlet이 담당)
*  유지보수 용이 

### 모델
* 서비스클래스 or 자바빈
* 비지니스 로직을 처리하는 모든 것이 모델에 속한다. 컨트롤러부터 특정 로직에 대한 처리 요청(게시판 글쓰기, 회원 가입 등)이 들어오면 이를 수행하고 수행 결과를 컨트롤러에 반환한다.
* (request 객체나 session객체에 저장하기도 함)

### VIEW
* JSP페이지
* 클라이언트에 출력되는 화면을 말한다. 모델1과는 달리 로직 처리를 위한 코드가 내포되어있지 않다. 요청 결과의 출력 뿐만 아니라 컨트롤러에 요청을 보내는 용도로도 사용된다.
* (request객체나 session객체에 저장된 정보를 토대로 화면 출력)

### Controller
* Servlet
* MVC패턴(Model2)모든 흐름제어츨 맡는다. 브라우저로 요청이 들어오면 어떤 요청이 들어오는지 분석하여 이 요청을 처리하기 위한 모델을 사용하여 처리한다. 사용한 모델로 부터 처리결과를 받으면 추가로 처리하거나 가공해야 할 정보가 있다면 처리 후 request객체나 session객체에 저장하고, View(JSP페이지)를 선택하여 Foward나 redirect하여 클라이언트에 출력한다.

### MVC 모델 특징
```java

장점
~ 출력을 위한 뷰 코드와 로직처리를 위한 자바코드를 분리하기 때문에 JSP모델1에 비해 코드가 복잡하지 않다.
~ 뷰, 로직처리에 대한 분업이 용이하다.
~ 기능에 따라 분리되어 있기 때문에 유지보수가 용이하다.


단점
~ 구조가 복잡하여 습득이 어렵고 작업량이 많다.
~ Java에 대한 깊은 이해도가 필요하다.

```


## 서블릿의 동작 원리
* 서블릿은 서블릿 컨테이너라는 실행 환경에서만 동작할 수 있으며 서블릿의 특징은 다음과 같다. 
	1.  자바기반의 웹 컴포넌트로서 확장자를 갖는다 Java . 
	2. 클라이언트의 요청에 의해서 동적으로 실행되므로 다양한 클라이언트 요구 사항을 처리 할 수 있다. 
	3. 클라이언트는 브라우저를 이용한 지정을 통해서 서블릿에 요청이 가능하다 URL . 
	4. 서블릿의 응답 결과는 일반적으로 형식으로 서비스되므로 자바 코드를 이용해서 클라이언트에 HTML HTML 코드로 전송하는 추가 작업이 필요하다. 
	5. 서블릿은 반드시 웹 컨테이너에 의해서 관리되며 자바 스레드로 동작되기 때문에 효율적으로 사용이 기능하다. 
	6. 패턴의 역할로서 서블릿을 사용하고 패턴을 적용하여 웹 어플리케이션을 개발한다면 MVC Controller MVC 서블릿이 아닌 에서 코드를 작성한다 

## 일반적 서블릿 동작
1. 프로토콜에 독립적인 서블릿을 만들려면 서블릿을 상속한다. 
2. 서블릿은 요청을 처리하기 위해 자신의 service 메서드를 오버라이드 해야 한다. 
3. 요청 와 응답 에 대한 접근을 제공한다 request( ) response( ) . 
4. 요청 가 올 때마다 request( ) service 메서드를 자동으로 호출한다. 

## http 서블릿 동작
1. 클라이언트의 요청하고 서블릿 포트에서 요청 받는다 Handler 8080 . 
2. 서블릿 컨테이너에서 해당 서블릿 검색하고 컨테이너에서 request 객체와 response 객체를 생성하고 난 후 이나 어노테이션을 참조한다 web.xml . 
3. 서블릿의 스레드 생성 후 service 메서드 호출하고 service 메서드에서는 요청 방식에 따라 doGot 메서드나 doPost 메서드를 호출한다. 
4. 서블릿이 데이터베이스 작업을 해야 한다면 데이터베이스를 연결한다. 
5. 모든 작업이 완료 되었다면 doGot 메서드나 doPost 메서드에서 응답을 생성하고 응답으로 결과를 리턴한다.



## 서블릿의 응답처리
```java
1. 사용자의 요청 
URL ⎼어떤 사용자의 요청이 서블릿 요청이라는 것을 웹 서버가 알기 위해서는 사전에 웹 서버 측에 과 서블릿 
URL URL 클래스를 미리 매핑 시켜 놓은 배포 서술자 가 필요하다 (Deployment Descriptor) . 
⎼배포 서술자는 받은 사용자의 요청이 특정한 서블릿 클래스를 필요로 하는 서블릿 요청이며 웹 서버가 URL 알 수 있도록 
적어 놓은 파일이며 웹 서버가 배포 서술자를 통해 지금 받은 요청이 서블릿 요청이라는 것을 알게 되면 서블릿을 담당하는 
웹 컨테이너로 그 요청을 전달한다.

2. 객체와 객체 생성 
request response ⎼웹 컨테이너는 받은 요청을 처리하기 위해서는 요청을 처리하기 위한 HTIP HttpServletRequest 
인터페이스의 request 객체와 응답을 위한 HTIP HttpServletResponse 인터페이스의 response 객체를 생성한다.

3. 서블릿 인스턴스와 스레드 생성 
⎼request 객체와 response 객체가 생성된 뒤 사용자의 요청이 어떤 서블릿 클래스를 필요로 하는지를 배포 URL 서술자를 통해 알아내고 
각 서블릿 인스턴스는 웹 컨테이너 당 하나만 존재하기 때문에 init 메서드는 각 서블릿 당 한 번씩만 호출된다. 

(1) 인스턴스 미 존재 ⎼클래스가 웹 컨테이너에서 한 번도 실행된 적이 없거나 현재 메모리에 생성된 인스턴스가 없다면 
새로 인스턴스를 생성하기 위해 메모리에 로드하고 init 메서드를 실행하여 초기화 한 뒤 스레드를 하나 생성한다. 


(2) 인스턴스 존재 ⎼인스턴스가 존재할 경우에는 새로 인스턴스를 생성하지 않고 기존의 인스턴스에 스레드만 하나 새로 생성한다.
⎼인스턴스의 생성 흐름은 다음과 같다. 
① 클라이언트의 서비스를 요청하고 객체 생성의 유무 체크를 한번만 확인한다.
② 객체가 있으면 생성 안하고 객체가 없으면 객체를 생성하고 메모리에 올린다 (Yes) (No) . 
③ 호출자 를 실행한다 Invokoer( ) . 
④ 를 만들며 작업용 당 개만 생성한다 Thread request 
1 . ⑤ 생성된 에서 Thread service 메서드 응답 를 호출하는데 이는 스레드의 (response( )) run 메서드와 유사하다. 
⑥ 결과를 클라이언트에게 전달하는데 결과를 타입으로 보내며 웹 브라우저는 이다 MIME text/html . 


* service
service(): 최초 클라이언트의 요청을 받았을때, 컨테이너는 새로운 스레드를 생성하거나 스레드 풀로부터 서블릿을 가져와서 
서블릿의 service() 메소드를 호출한다. 클라이언트의 HTTP 메소드(GET, POST 등)를 참조하여 doGet() / doPost() 혹은 
다른 메소드를 호출할지 판단한다. 재정의는 하지 않으며 doGet()/ doPost() 를 재정의하여 HttpServlet의 service()가 이를 실행하도록 한다.
doGet(), doPost(): service() 메소드가 클라이언트의 HTTP 메소드(GET, POST등) 를 참조하여 doGet()/ doPost()를 호출한다.
여기서 doGet()/ doPost() 만 언급하는 이유는 이것말고 나머지 메소드는 사용할 경우가 거의 없기 때문이다. 
이 메소드 안에서 코딩작업을 하면된다. doGet()/ doPost() 둘중 하나는 반드시 재정의 해야 한다.


-4. 메서드 호출과 서블릿 클래스 실행 service 
⎼스레드가 생성되면 각 스레드에서 service 메서드가 호출된다. 
① 요청 방식이 방식일 경우 서블릿 클래스의 HTTP GET : doGet 메서드 
② 요청 방식이 방식일 경우 서블릿 클래스의 HTTP POST : doPost 메서드 ⎼doGet 메서드와 doPost 메서드는 
request 와 response 객체를 인자로 자동으로 호출되므로 개발자가 실제로 동적인 웹 페이지 생성을 할 수 있는 
코드를 작성해야 하는 부분이 바로 doGet 메서드와 doPost 메서드 부분이다.

응답과 스레드의 소멸 
⎼doGet 메서드 또는 doPost 메서드가 호출되어 사용자의 요청에 따른 동적인 웹 페이지를 생성하면 
그 결과물이 담긴 response 객체를 웹 컨테이너가 응답 형태로 바꾸어 웹 서버로 전송하게 되고 사용이 
HTTP (Response) 끝난 request 객체와 response 객체를 소멸시키고 스레드를 종료하게 된다. 

⎼웹 서버는 전송 받은 응답 메시지를 사용자의 브라우저로 전송하게 되고 사용자는 브라우저를 통해서 HTTP 동적으로 
생성된 페이지를 받아 보게 된다. ⎼배포 서술자를 통해 서블릿 요청임을 알게 되면 
웹 컨테이너는 서블릿 인스턴스의 유무를 검사해 없을 경우 인스턴스를 생성하고 초기화 한다 
생성된 인스턴스 내에 각각의 서블릿 요청마다 하나씩의 스레드를 생성하며 . 
생성된 스레드는 서비스 메서드를 호출한다. ⎼요청 방식이 인가 인가에 따라 각각 GET POST doGet 메서드와 doPost 메서드가 
자동으로 호출된다. 
⎼doGet 메서드 또는 doPost 메서드를 통해 처리된 결과가 response 객체에 담기고 웹 컨테이너는 
이를 HTTP 응답 메시지로 작성해 최종적으로 클라이언트의 브라우저에 전송되게 된다 
```

## 서블릿을 이용한 클라이언트에서 전송되는 요청 처리 
```java
6-1. 요청이 방식으로 전송되어 올 경우 
GET ⎼ 
방식으로 요청이 전송되어 올 경우는 GET doGet 메서드가 최종적으로 호출되기 때문에 해당 메서드에서 요청을 처리해준다. 
⎼서블릿에서 제공되는 HttpServletRequest 인터페이스에서 제공되는 String getParameter(String 메서드가 name) 존재하는데 
이 메서드는 이라는 요청에 전송되어 오는 파라미터 값도 처리하며 이름으로 전송되어 온 name 파라미터 값을 반환해주는 메서드이다.

6-2. 방식으로 요청이 전송되어 올 경우 POST ⎼ 
방식으로 요청을 처리할 경우도 방식으로 요청을 처리하는 경우와 거의 유사하며 단지 서블릿 쪽에서 POST GET 요청 처리를 수행할 때 
doGet 메서드가 아닌 doPost 메서드에서 요청이 처리된다. 

6-3. 하나의 파라미터 이름으로 다중 처리 
⎼HttpServletRequest 인터페이스에서 제공되는 String getParameter(String 메서드는 하나의 전송 파라미터
name) 이름으로 하나의 파라미터 값이 전송되는 경우에 사용한다면 하나의 파라미터 이름으로 여러 개의 값이 전송되어 올 때는 HttpServletRequest 인터페이스에서 제공되는 String[ ] getParameterValues(String 메서드를 paramName) 사용한다.
⎼ 방식은 현재 실행중인 페이지의 실행을 중단하고 다른 웹 자원이 대신 호출되도록 만드는 기능으로 
Redirect JSP 파라미터로 지정한 을 직접 호출하는 것이 아니라 웹 브라우저에 메시지를 보내 웹 브라우저가 을 가지고 
URL URL 웹 서버에 웹 자원을 다시 요청한다. 
⎼ 방식의 Redirect sendRedirect 메서드는 지정된 로 요청을 재전송하고 클라이언트 요청을 다른 페이지로 URL 보내며 형식은 다음과 같다.

```


##  서블릿 페이지 흐름 제어 
```java
1. 방식 Redirect ⎼ 
방식은 제어권을 다른 페이지로 넘길 때 클라이언트의 주소 표시줄의 이 변경되어 요청이 바뀌게 Redirect URL 된다. 
⎼ 방식으로 제어권을 받은 페이지에서는 영역이 달라 서블릿에서 영역에 공유한 Redirect JSP request  
request 속성값에 접근할 수 없다. ⎼요청과 응답이 한 번 더 일어나므로 를 이용해서 데이터 를 공유할 수 없다
Request Scope (Attribute) .


-2. 방식 Dispatcher 
⎼ 방식은 제어권을 다른 페이지로 넘길 때 주소 표시줄이 변경되지 않는다 Dispatcher . 
⎼ 방식으로 제어권을 받은 페이지에서는 하나의 요청이여서 영역을 공유하고 서버에서 다른 Dispatcher jsp  request   페이지를 호출한다. 
⎼ 방식은 방식과 다르게 가 살아있는 상태에서 수행을 넘기므로 같은 영역을 Dispatcher Redirect request request 공유하게 되고 
를 이용해서 데이터 를 공유할 수 있으므로 공유한 속성값에 접근할 수 Request Scope (Attribute) 있다. ⎼
방식은 요청 정보와 응답 정보가 유지되는 장점이 있기 때문에 모델 기반의 웹 프로그래밍에서 Dispatcher 
2 뷰 페이지에서 요청 영역에 공유되어 있는 속성값을 이용하여 페이지를 구성하는 데 유리하다.


7-3. 메서드와 메서드의 차이점 
sendRedirect forward ⎼sendRedirect 메서드는 을 웹 브라우저로 보내서 간접적으로 웹 자원을 호출하지만 
URL forward 메서드는 웹 서버 쪽에서 직접 호출한다. ⎼sendRedirect 메서드를 이용하면 다른 웹 서버에 있는 
웹 자원도 호출할 수 있지만 forward 메서드를 이용하면 같은 웹서버나 같은 웹 어플리케이션 디렉토리 내에 있는 
웹 자원만 호출할 수 있다. 
⎼sendRedirect 메서드를 이용하면 텍스트 문자열 데이터만 전달할 수 있지만 ( ) forward 메서드를 이용하면 
객체 형태의 모든 데이터를 전달 할 수 있다. ⎼sendRedirect 메서드를 통해 한글 데이터를 전달하기 위해서는 
인코딩을 해야 하지만 URL forward 메서드에서는 그런 작업이 필요치 않다
```

# 서버 페이지
- form -> 서버 페이지(자바는 서블릿; jsp) -> 데이터베이스
- 1. sun에서 개발한 서블릿: JSP 2. 개발자가 개발한 서블릿
- 입력폼(JSP)  -> 컨트롤러(커스텀 서블릿; 개발자가 개발)  ->  자바(모델) -> DB -> 모델 -> 컨트롤러(커스텀 서블릿; 개발자가 개발) -> 출력폼(JSP)
- 컨트롤러 역할까지 했던 예전과 달리 지금 JSP는 뷰 역할만 한다.
- 입력폼 -> 웹 서버 -> 웹 어플리케이션 서버 -> 데이터 베이스 -> 웹 어플리케이션 서버 -> 웹서버 -> 출력폼
- 톰켓 8부터는 별도의 설정하지 않아도 인코딩이 된다.	

## 입력폼
- 폼 제어: 자바 스크립트(jQuery가 역할)

## 커스텀 서블릿
- 커스텀 서블릿에서 jsp 출력폼으로 보내거나 모델로 보낼 때 1. 포워드(주소 변경 안함) 2. 리다이렉트 방식 사용(주소지 변경)
- 페이지 수마다 코드가 들어가야 하기 때문에 페이지 수만큼 코드가 길어진다.

## 데이터 유지권
- # 세션: 서버에 저장; 로그인에서 아이디 유지권에 사용
- # 쿠키: 클라이언트에서 유지
- 부하가 크기 때문에 특별한 경우가 아니면 사용하지 않는다.   

# 톰켓
- 톰켓 8부터는 별도의 설정하지 않아도 인코딩이 된다.
- 톰켓 7버전은 get방식일 때 별도의 설정을 해주어야 한다. 실무에서는 아직 7버전을 많이 사용한다.
- ⎼POST 방식은 문제가 없지만 GET 방식으로 전송된 파라미터에 대해서는 request.setCharacterEncoding( ) 메서드로 지정한 캐릭터 셋이 적용되지 않는다.
- ⎼Server 디렉토리의 server.xml 파일을 XML Editor로 열고 Source를 선택한 후 Connetctor 요소에 추가 할 코드를 추가하고 파일을 저장한 후 서버를 반드시 재 시작한다.
- ⎼추가 할 요소는 URIEncoding= “UTF-8” 와 useBodyEncodingForURI= “true” 로 두 요소를 모두 추가해주는 것이 인코딩에 효율적이므로 권장한다.
- <Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443" URIEncoding= “UTF-8” useBodyEncodingForURI= “true” />



# 확장자
- 상속의 개념
- 파일 확장자(영어: filename extension)는 컴퓨터 파일의 이름에서 파일의 종류와 그 역할을 표시하기 위해 사용하는 부분이다.
- 많은 운영 체제들은 파일 이름에서 마지막 점(.) 뒤에 나타나는 부분을 확장자로 인식한다. 

# MIME
- ⎼MIME은 Multipurpose Internet Mail Extensions의 약자로 일종의 인코딩 방식으로 이메일과 함께 동봉할 첨부 파일(attachment file)을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었기 때문에 이름이 Internet Mail Extension이며 이제는 웹을 통해서 여러 형태의 파일을 전달하는 데 두루 쓰이고 있다.
- ⎼MIME 타입은 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘으로 각 문서와 함께 올바른 MIME 타입을 전송하도록 서버가 정확히 설정하는 것이 중요하며 브라라우저들은 리소스를 내려 받았을 때 해야 할기본 동작이 무엇인지를 결정하기 위해 대게 MIME 타입을 사용한다.

# JSP
- JSP 라이브러리: C:\apache-8.5.39\apache-tomcat-8.5.39\lib
- JSP 클래스 저장:  -    
- - C:\workspace\jsptest\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\begin\org\apache\jsp\begin
- jsp가 만들어지면 자동으로 서블릿이 만들어진다. 
- 또 jsp 만들면 web.xml에 sevlet 매핑에 jsp가 있다. jsp도 사실상 서블릿이다.
	⎼JSP 에서는 서블릿과 달리 위의 코딩을 추가해 주어야 한다.
	⎼out 객체를 지우고 out 객체를 새로 만들어서 추가한다.
	⎼jsp 에서 다운로드를 위해 OutputStream 추상 클래스를 받아서 처리할 때 JSP 에서 servlet 으로 변환될 때 내부적으로 out 객체가 생성되므로 response.getOutputStream( ) 메서드 호출 시 생기는 out 객체와 jsp 에서 servlet 으로 변환될 때 생성되는 out 객체와 충돌이 일어나서 예외처리가 발생하므로 추가해 준다.
	⎼ServletOutputStream 추상 클래스를 만들면서 out 객체를 재정의 하려고 시도하기 때문에 기본객체로 있는 out 객체에서는 예외가 발생하지만 동작은 잘되지만 이벤트가 서버에 쌓이므로 추가 해주는 것을 권장한다.

## JSP 특징
1. 강력한 이식성
- 이식성은 JSP의 가장 큰 장점이다.
- JVM을 이용한 자바 언어의 특성상 어떤 운영체제에서도 어떤 JSP 컨테이너에서도 사용이 가능하므로 한번 작성한 코드를 별다른 수정 없이 다른 플랫폼으로 얼마든지 이식이 가능하다.

2. 서버 자원의 효율적인 사용
- 사용자가 웹 서버에 요청을 보내면 서버는 각 요청 당 하나의 프로세스를 생성하고 해당 프로세스를 통해 결과를 생산하면 프로세스가 종료되는 구조를 가지고 있었기 때문에 수많은 사용자가 접속할 경우 프로세스 생성에 너무 많은 서버 자원을 필요로 하게 되는데 이러한 문제점을 JSP는 Thread(스레드) 기반의 아키텍처를 사용하여 개선시켰다.
- 스레드 기반의 아키텍처에서는 최초의 요청이 웹 서버에 들어오면 서버는 그 요청에 맞는 JSP 페이지에 대한 서블릿 인스턴스를 단 한 번 생성하고 이후 같은 페이지를 요청하는 사용자가 있을 경우 이미 생성되어 있는 인스턴스에 스레드 단위로 요청을 전송하여 처리하기 때문에 서버 자원의 효율적인 사용이 가능하다.

3. JSTL과 커스텀 태그 등을 이용한 개발 용이성
- .JSP 개발에 있어서 가장 큰 문제점은 JSP 문서 내에 자바 형식의 문법과 태그 형식의 HTML 문법이 같은 페이지 내에 존재하기 때문에 JSP 문서의 코딩 양이 많아질수록 코드의 가독성이 떨어진다는 점이다.
- .JSP 2.0 이후로 JSTL(JSP Standard Tag Library)과 커스텀 태그에 대한 지원이 강화됨으로써 자바 형식의 문법을 태그 라이브러리 파일로 만들어서 JSP를 태그만으로 구성힐 수 있게 만드는 기능이 강력해져 요소들을 태그 형식으로 깔끔하게 정리함으로써 전제적인 JSP 코드의 길이를 대폭 줄일 수 있게 되었으며 코드의 가독성 및 유지 보수의 효율이 대폭 향상되었다.
4. 쓰레드를 이용한 분산처리:  많은 작업 요청을 효율적으로 처리 가능하여 처리속도가 빠르다.
5..자바언어를 기반으로 제작
- 자바언오를 기반으로 제작되었기 때문에 객체지향적인  특징과 플랫폼에 독립적인 장점을 얻을수 있다.
 6. .프레임워크와 완벽한 연동
- 대규모 어플리케이션을 구현할 때 사용되는 SPRING과 같은 프레임워크와 완벽하게 연동된다.




# WAR
* 패키징 된 웹 응용 프로그램

# 컨텍스트
* 하나의 웹 응용프로그램, 공통된 실행 


# 모델 1
1.  정의
- 모든 클라이언트 요청과 응답을 JSP가 담당하는 구조이다.
2. 개요
- JSP 로 구현한 기존 웹 어플리케이션은 모델1 구조로 웹 브라우저의 요청을 JSP 페이지가 받아서 처리하는구조이다.
- JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 보여주기 위한 출력 관련 코드가 뒤섞여 있는 구조로 웹 브라우저의 요청이 곧바로 JSP에 전달된다.
- 웹 브라우저의 요청을 받은 JSP 는 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업을 처리하고 그 결과를 클라이언트에 출력해준다.
- JSP 페이지에서 웹 브라우저가 요청한 것들을 처리한다는 것은 JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 보여줄 출력 관련 코드가 섞인다는 것을 의미한다.
- 하나의 JSP 페이지에서 서비스 클래스를 통해서 원하는 작업을수행하고 그 결과를 출력하는 경우가 많았는데 이것이 모델1 구조의 전형적인 예이다.
- 모델1 구조는 JSP 페이지 안에서 모든 정보를 표현(View)하고 저장(Model)하고 처리(Control)되므로 재사용이 힘들고 읽기도 힘들어 가독성이 떨어진다.
- 모델1 구조는 JSP 페이지에서 화면을 보여주는 기능도 하고 요청이 페이지로 들어올 때 요청에 관한 비즈니스 로직을 수행하는 것도 JSP 페이지에서 직접 이루어진다.
- 모델1 구조로 개발할 경우에 개발 시간은 짧아 질 수 있지만 유지보수 시 코드 분석이 어려워지고 디자이너가 디자인을 변경하려고 할 때 태그 외에 자바 코드들이 섞여 있기 때문에 해석하는 데 문제가 발생할 수 있다.
- 모델1 구조의 코드의 복잡성과 디자이너와 개발자 영역의 비분리 등은 프로젝트 규모가 커질수록 더 큰 걸림돌이 된다.

3. 장점
- 단순한 페이지 작성으로 쉽게 구현 가능하며 중소형 프로젝트에 적합하다.

4. 단점
- 웹 애플리케이션이 복잡해지면 유지보수 문제가 발생된다.


# 모델 2
1. 정의
- 클라이언트의 요청처리와 응답처리 및 비즈니스 로직 처리하는 부분을 모듈화 시킨 구조이다.

2. 개요
- 모델2 구조는 모델1 구조와 달리 웹 브라우저의 요청을 하나의 서블릿이 받게 되며 서블릿은 웹 브라우저의 요청을 알맞게 처리한 후 그 결과를 보여줄 JSP 페이지로 포워딩한다.
- 포워딩을 통해서 요청 흐름을 받은 JSP 페이지는 결과 화면을 클라이언트에 전송하여 서블릿이 비즈니스 로직 부분을 처리하게 되는 것 이다.
- 모델2 구조의 특징은 웹 브라우저의 모든 요청이 단일 진입점인 하나의 서블릿에서 처리된다는 점이다.
- 모델2 구조는 하나의 서블릿이 웹 브라우저의 모든 요청을 받기 때문에 서블릿은 웹 브라우저의 요청을 구분할 수 있는 방법을 필요로 하며 서블릿은 웹 브라우저의 요청을 처리한 후 웹 브라우저에 보여줄 JSP 를 선택하게 된다.
- 모델2 구조의 이러한 특징 때문에 MVC 패턴에 기반을 두어 웹 어플리케이션을 구현할 때는 모델2 구조를 주로 사용한다.
- 모델1 구조는 컨트롤러가 모델이나 뷰를 포함한 MV 형태를 띠고 있고 모델2는 완전한 MVC 형태를 적용하고 있다고 볼 수 있다.
- 모델2 구조는 디자인 부분과 비즈니스 로직 부분을 분리해서 개발하기 때문에 디자이너는 디자인 부분만 프로그래머는 로직 부분만 개발하는 것이 가능하다.
- 모델2 구조는 각 담당하는 부분의 페이지가 독립적이므로 디자이너는 JSP 페이지에 그리고 프로그래머는 java 클래스에 존재하므로 동시에 개발이 가능하여 프로젝트 규모가 커지면 오히려 프로젝트 생산성도 좋아진다.
- 모델2 구조 방식으로 개발하면 유지 보수 시 디자인을 변경하거나 로직을 변경할 때 자신이 개발한 부분에만 접근하여 변경할 수 있게 된다.
- 모델2 구조의 경우는 설계 단계가 까다로우므로 모델1 보다는 개발 기간이 더 길어지므로 일반적으로 규모가 그다지 크지 않은 프로젝트에서는 모델1 구조로 구현하는 것이 좋다.

3. 장점
- 처리작업의 분리로 인해 유지보수와 확장이 용이하다.

4. 단점
- 구조 설계를 위한 시간이 많이 소요되므로 개발 기간이 증가한다.


## 서버 페이지 표현
1. <% %>; 태그의 나머지; jsp, asp
- <%@ 지시어>
2. <? ?>; 태그의 질의어; php

# Servlet
- C:\apache-8.5.39\apache-tomcat-8.5.39\lib
- 웹에서 받은 데이터를 자바로 넘겨주는 역할

# WEB-INF
- 웹 애플리케이션 용으로 (servlet 규격으로) 따로 만들어진 디렉터리
- 웹을 중요한 파일들이 노출되지 않도록 만든 폴더


# Servlet
* 클라이언트 -> HTTP Request -> 컨테이너(객체 생성: HttpServletRequest, HttpServletResponse) -> 
    서블릿 분석(Web.xm) -> 찾은 서블릿 -> Service() -> doGet(), doPost() -> 객체 생성: HttpServletRequest, HttpServletResponse)
    -> HttpResponse

```java
사용자(클라이언트)가 URL을 클릭하면 HTTP Request를 Servlet Conatiner로 전송합니다.
HTTP Request를 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성합니다.
web.xml은 사용자가 요청한 URL을 분석하여 어느 서블릿에 대해 요청을 한 것인지 찾습니다.
해당 서블릿에서 service메소드를 호출한 후 클리아언트의 POST, GET여부에 따라 doGet() 또는 doPost()를 호출합니다.
doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다.
응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.
```

## CGI
```java
Q) CGI(Common Gateway Interface)란
CGI는 특별한 라이브러리나 도구를 의미하는 것이 아니고, 
별도로 제작된 웹서버와 프로그램간의 교환방식입니다.
CGI방식은 어떠한 프로그래밍언어로도 구현이가능하며,
별도로 만들어 놓은 프로그램에 HTML의 Get or Post 방법으로 클라이언트의 데이터를 환경변수로 전달하고, 
프로그램의 표준 출력 결과를 클라이언트에게 전송하는 것입니다.
즉, 자바 어플리케이션 코딩을 하듯 웹 브라우저용 출력 화면을 만드는 방법입니다.

* HTTP 프로토콜을 이용한 서버와 클라이언트의 통신 과정은?

클라이언트는 정보를 얻기 위해 서버로 HTTP 요청 메세지+매개변수를 전송하고, 
서버는 이를 해석하여 정적 자원에 대한 요청일 경우 자원을 반환해주고, 
그렇지 않은 경우 CGI 프로그램을 실행시켜 해당 결과를 리턴해줍니다.
이때 서버는 CGI 프로그램에게 클라이언트의 요청과 매개변수를 전달해주고, 
결과를 전달받기 위한 파이프라인을 연결합니다. 
그래서 CGI 프로그램은 입력에 대한 서비스를 수행하고, 
결과를 클라이언트에게 전달하기 위해 결과 페이지에 해당하는 MIME 타입의 컨텐츠데이터를 
웹 서버와 연결된 파이프라인에 출력하여 서버에 전달합니다. 서버는 파이프라인을 통해 CGI 프로그램에서 

출력한 결과 페이지의 데이터를 읽어, HTTP 응답헤더를 생성하여 데이터를 함께 반환해준다.

```

## JSP
* ⎼서블릿이 자바 코드에 의존적이라면 는 덜 의존적이라 프로그래밍하기가 더 쉽고 편하다 JSP . 
* 와 서블릿은 같은 처리 구조를 가지는데 는 페이지 요청이 있을 시에는 최초에 한 번 자바 코드로 변환된 JSP JSP 후 서블릿 클래스로 컴파일 된다. 
* 는 실행시 서블릿으로 변환되고 단 한번만 서블릿으로 변경되며 코드를 수정하기 전까지 재 변환 작업이 JSP 일어나지 않기 때문에 수행 속도는 나 서블릿 간에 별 차이가 없다 JSP .


## 서블릿 컨테이너
* 스레드(thread) 기반의 요청 처리 방식을 채택했기에 사용자가 많을수록 효율적으로 동작하는 강력한 기술이다. 
* 만일 한 시스템에 수많은 사용자가 접속해 모두 같은 프로그램 브라우저 을 실행하더라도 운영체제는 일일이 ( ) 모든 사용자에게 서로 다른 자원을 할당해 수많은 프로세스를 생성해야만 하는데 웹 서버는 같은 페이지에 대해 항상 다른 자원을 할당해야 하므로 자원 관리에 있어서 대단히 비효율적이게 된다 이러한 단점을 극복하고자 . 나온 기술이 스레드 기반의 서블릿이다 (Thread)
* ⎼웹 환경처럼 같은 페이지에 대해 많은 사용자가 요청을 보낼 경우 서블릿처럼 스레드 기반으로 처리하면 이미 메모리에 생성되어 있는 프로세스 서블릿 인스턴스의 자원을 참조하기만 하면 되므로 획기적인 성능의 향상을 ( ) 가져올 수 있다. 
* 하나의 프로세스에 할당 받은 자원의 한계와 효율성의 문제 때문에 서블릿 컨테이너가 이러한 스레드 수와 프로세스 수를 적절히 조절하게 된다. ⎼하나의 프로세스 내에 무한정 많은 수의 스레드를 생성할 수는 없기 때문이다. 

```java
아주쉽죠? 우리가 서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니고, 서블릿을 관리해주는 것이 필요한데 
그러한 역할을 하는 것이 바로 서블릿 컨테이너 입니다. 
예를 들어, 서블릿이 어떠한 역할을 수행하는 정의서라고 보면, 서블릿 컨테이너는 그 정의서를 보고 수행한다고 볼 수 있습니다. 
서블릿 컨테이너는 클라이언트의 요청(Request)을 받아주고 응답(Response)할 수 있게, 
웹서버와 소켓을 만들어 통신하며 대표적인 예로 톰캣(Tomcat)이 있습니다. 
톰캣은 실제로 웹서버와 통신하여 JSP(자바 서버 페이지)와 Servlet이 작동하는 환경을 제공해줍니다.

[Servlet Container 역할]
  1. 웹서버와의 통신 지원; 처음
서블릿 컨테이너는 서블릿과 웹서버가 손쉽게 통신할 수 있게 해줍니다. 일반적으로 우리는 소켓을 만들고 listen, 
accept 등을 해야하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해줍니다.
그래서 개발자가 서블릿에 구현해야 할 비지니스 로직에 대해서만 초점을 두게끔 도와줍니다.

  2. 서블릿 생명주기(Life Cycle) 관리; 끝
서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리합니다. 서블릿 클래스를 로딩하여 인스턴스화하고, 
초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출합니다. 
또한 서블릿이 생명을 다 한 순간에는 적절하게 Garbage Collection(가비지 컬렉션)을 진행하여 편의를 제공합니다.


  3. 멀티쓰레드 지원 및 관리; 2번째 시작
서블릿 컨테이너는 요청이 올 때 마다 새로운 자바 쓰레드를 하나 생성하는데, HTTP 서비스 메소드를
실행하고 나면, 쓰레드는 자동으로 죽게됩니다. 원래는 쓰레드를 관리해야 하지만 서버가 다중 쓰레드를
생성 및 운영해주니 쓰레드의 안정성에 대해서 걱정하지 않아도 됩니다.


  4. 선언적인 보안 관리; 관리
서블릿 컨테이너를 사용하면 개발자는 보안에 관련된 내용을 서블릿 또는 자바 클래스에 구현해 놓지 않아도 됩니다.
일반적으로 보안관리는 XML 배포 서술자에 다가 기록하므로, 보안에 대해 수정할 일이 생겨도 자바 소스 코드를 
수정하여 다시 컴파일 하지 않아도 보안관리가 가능합니다.
```

### Servelet 생명주기
```java
클라이언트의 요청이 들어오면 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고, 없을 경우 init()메소드를 호출하여 적재합니다. 
init()메소드는 처음 한번만 실행되기 때문에, 서블릿의 쓰레드에서 공통적으로 사용해야하는 것이 있다면 오버라이딩하여 구현하면 됩다. 
실행 중 서블릿이 변경될 경우, 기존 서블릿을 파괴하고 init()을 통해 새로운 내용을 다시 메모리에 적재합니다.
init()이 호출된 후 클라이언트의 요청에 따라서 service()메소드를 통해 요청에 대한 응답이 doGet()가 doPost()로 분기됩니다. 
이때 서블릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 처리하는 과정으로 생성된 HttpServletRequest, HttpServletResponse에 의해 request와 response객체가 제공됩니다.
컨테이너가 서블릿에 종료 요청을 하면 destroy()메소드가 호출되는데 마찬가지로 한번만 실행되며, 종료시에 처리해야하는 작업들은 destroy()메소드를 오버라이딩하여 구현하면 됩니다.
```
