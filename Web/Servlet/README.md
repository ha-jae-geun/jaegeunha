# 서블릿
![서블릿](./image/servlet.JPG)
- 서버에서 실행되는 자바 프로그램(HTML in JAVA)

## 실행 순서
1. 웹 어플리케이션이 실행될 때: ServletContextListner 인터페이스의 contextinitialized 메소드 실행
2. 어노테이션 const 선처리 작업 
3. 해당 서블릿의 웹 서블릿 initParam 메소드 실행(1. web.xml에서 설정하거나 2. annotation으로 실행하거나)
4. do get/ do post
5. 종료 시 서블릿 destroy
6. annotation의  destroy
7. 웹 어플리케이션이 종료될 때: ServletContextListner 인터페이스의 contextDestroyed 메소드 실행

```java
1. annotation

2. 
<web-app>

    <!-- 1. aliases 설정 -->
    <servlet>
        <servlet-name>welcome</servlet-name>
	//매핑할 클래스 파일명을 패키지명을 포함하여 정확하게 입력
        <servlet-class>servlets.WelcomeServlet</servlet-class>
    </servlet>

    <!-- 2. 매핑 -->
    <servlet-mapping>
    	//입의의 이름 입력
        <servlet-name>welcome</servlet-name>
	//  /로 시작해야 한다
        <url-pattern>/welcome</url-pattern>
    </servlet-mapping>

</web-app>
https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html

```

## JSP가 나온 이유
*  HTML을 코딩하기 너무 어렵고 불편해서 HTML 내부에 Java코드를 삽입하는 형식이 JSP이다. 다시 말해 서블릿의 단점을 보완하고자 만든 서블릿 기반의 스크립트 기술이다. 서블릿을 이용하게 되면 웹프로그래밍을 할 수 있지만 자바에 대한 지식이 필요하며 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 등 비효율적인 측면들이 있다. 때문에 서블릿을 작성하지 않고도 간편하게 웹프로그래밍을 구현하게 만든 기술이 JSP(Java Server Pages)이다.
* 조금더 알아보자면 JSP(Java Server Pages)는 서블릿 기반의 '서버 스크립트 기술'이다.
* 여기서 스크립트 기술이란 ASP, PHP 처럼 미리 약속된 규정에 따라 간단한 키둬드를 조합하여 입력하면, 실행 시점에 각각의 키워드에 매핑이 되어 있는 어떤 코드로 변환 후에 실행되는 형태이다.
*  내용만 보게 된다면 서블릿이나 JSP나 만드는 방법에 차이가 있을 뿐 동일한 역할을 한다는 것을 알수 있다. 초기에 자바 웹개발은 서블릿을 이용한 개발이였다. 이후 JSP기술이 발표되면서 JSP형태의 개발이 유행하게 되고 지금에 와서 각각의 역할을 나누어 Servlet+JSP형태의 개발이 이루어지고 있다.
* JSP는 JSP기술의 장점을 최대한 활용 할 수 있는 웹에플리케이션 구조에서 사용자에게 결과를 보여주는 프리젠테이션 층을 담당하고 Servlet은 Servlet기술의 장점을 최대한 활용 할 수 있는 사용자의 요청을 받아 분석하고 비지니스 층과 통신하여 처리하고 처리한 결과를 다시 사용자에게 응답하는 컨트롤러 층을 담당한다.

## JSP와 서블릿의 차이점
### 서블릿
- 자바코드로 구현하고 컴파일하고 배포해야 한다.
- HTML태그로 문자열("")스크림으로 처리해야 한다.
- 코드가 수정되면 다시 컴파일하고 배포해야 한다.

### jsp 주석
* html의 주석은 브라우저에서 코드보기하면 보이지만 JSP는 서버에서 돌아가기 때문에 보이지 않는다.

### JSP 동작원리
1. 웹브라우저 요청
2. jsp에서 서블릿으로 변환
	* helloWorrld.js > helloWorld_jsp.java  로 변환
3. 웹브라우저 응답(HTML형태로 응답)
4. 서블릿 -> 클래스
	* helloWorld_jsp.java -> helloWorld_jsp.class

### JSP
- 키워드가 태그화 되어 서블릿에 비해 배우기 쉽다.
- 자바코드를 <%%>태그 안에 처리해주어야 한다.
- HTML처럼 태그를 사용하여 자바코드도 사용이 가능하다.
* JSP파일은 결국 서블릿으로 변환이 되어 실행된다. JSP파일이 Servlet으로 변환되는 과정은 오직 한번만 일어나므로 같은 페이지에 수많은 사용자의 요청이 있더라도 처리속도는 거의 떨어지지 않게 된다. 만약 JSP페이지의 코딩 내용이 변경된다면 다시 변환 과정을 거친다. 즉 JSP가 서블릿을 기반으로 하고 있기 때문에 JSP의 동작 방식을 이해하기 위해서는 Servlet에 대한 이해도도 필요하다.

## MVC 모델2
* 얼마전까지만 하더라도 JSP만 이용한 개발(Model1 방식)이 유행하다 현재는 유지보수단계에서 많은 단점을 느껴 각각의 역할을 나누어 서블릿과 JSP를 동시에 사용하여 개발하는 방식(Model2 방식)으로 개발하고 있어 현재는 Servlet과 JSP를 나누어 사용하고 있다. 그리하여 JSP는 HTML태그 사용이 용이하고 자바코드 사용이 불편하기 때문에 웹어플리케이션에서 사용자에게 결과를 보여주는 View(Client)를 담당하고 Servlet은 자바코드 작성이 편리하기 때문에 주로 화면과 통신하여 자료를 받아 가공하고 가공한 자료를 다시 화면에 전달하는 Controller역할을 하고 있다.
*  JSP와 Servlet 동시에 사용 MVC모델(View는 JSP, Controller는 Servlet을 사용)
*  프리젠테이션 로직과 비즈니스 로직 분리
(보여지는 부분은 HTML이 중심이 되는 JSP, 다른 자바클래스에게 데이터를 넘겨주는 부분은 Java코드가 중심이 되는 Servlet이 담당)
*  유지보수 용이 

### 모델
* 서비스클래스 or 자바빈
* 비지니스 로직을 처리하는 모든 것이 모델에 속한다. 컨트롤러부터 특정 로직에 대한 처리 요청(게시판 글쓰기, 회원 가입 등)이 들어오면 이를 수행하고 수행 결과를 컨트롤러에 반환한다.
* (request 객체나 session객체에 저장하기도 함)

### VIEW
* JSP페이지
* 클라이언트에 출력되는 화면을 말한다. 모델1과는 달리 로직 처리를 위한 코드가 내포되어있지 않다. 요청 결과의 출력 뿐만 아니라 컨트롤러에 요청을 보내는 용도로도 사용된다.
* (request객체나 session객체에 저장된 정보를 토대로 화면 출력)

### Controller
* Servlet
* MVC패턴(Model2)모든 흐름제어츨 맡는다. 브라우저로 요청이 들어오면 어떤 요청이 들어오는지 분석하여 이 요청을 처리하기 위한 모델을 사용하여 처리한다. 사용한 모델로 부터 처리결과를 받으면 추가로 처리하거나 가공해야 할 정보가 있다면 처리 후 request객체나 session객체에 저장하고, View(JSP페이지)를 선택하여 Foward나 redirect하여 클라이언트에 출력한다.

### MVC 모델 특징
```java

장점
~ 출력을 위한 뷰 코드와 로직처리를 위한 자바코드를 분리하기 때문에 JSP모델1에 비해 코드가 복잡하지 않다.
~ 뷰, 로직처리에 대한 분업이 용이하다.
~ 기능에 따라 분리되어 있기 때문에 유지보수가 용이하다.


단점
~ 구조가 복잡하여 습득이 어렵고 작업량이 많다.
~ Java에 대한 깊은 이해도가 필요하다.

```


## 서블릿의 동작 원리
* 서블릿은 서블릿 컨테이너라는 실행 환경에서만 동작할 수 있으며 서블릿의 특징은 다음과 같다. 
	1.  자바기반의 웹 컴포넌트로서 확장자를 갖는다 Java . 
	2. 클라이언트의 요청에 의해서 동적으로 실행되므로 다양한 클라이언트 요구 사항을 처리 할 수 있다. 
	3. 클라이언트는 브라우저를 이용한 지정을 통해서 서블릿에 요청이 가능하다 URL . 
	4. 서블릿의 응답 결과는 일반적으로 형식으로 서비스되므로 자바 코드를 이용해서 클라이언트에 HTML HTML 코드로 전송하는 추가 작업이 필요하다. 
	5. 서블릿은 반드시 웹 컨테이너에 의해서 관리되며 자바 스레드로 동작되기 때문에 효율적으로 사용이 기능하다. 
	6. 패턴의 역할로서 서블릿을 사용하고 패턴을 적용하여 웹 어플리케이션을 개발한다면 MVC Controller MVC 서블릿이 아닌 에서 코드를 작성한다 

## 일반적 서블릿 동작
1. 프로토콜에 독립적인 서블릿을 만들려면 서블릿을 상속한다. 
2. 서블릿은 요청을 처리하기 위해 자신의 service 메서드를 오버라이드 해야 한다. 
3. 요청 와 응답 에 대한 접근을 제공한다 request( ) response( ) . 
4. 요청 가 올 때마다 request( ) service 메서드를 자동으로 호출한다. 

## http 서블릿 동작
1. 클라이언트의 요청하고 서블릿 포트에서 요청 받는다 Handler 8080 . 
2. 서블릿 컨테이너에서 해당 서블릿 검색하고 컨테이너에서 request 객체와 response 객체를 생성하고 난 후 이나 어노테이션을 참조한다 web.xml . 
3. 서블릿의 스레드 생성 후 service 메서드 호출하고 service 메서드에서는 요청 방식에 따라 doGot 메서드나 doPost 메서드를 호출한다. 
4. 서블릿이 데이터베이스 작업을 해야 한다면 데이터베이스를 연결한다. 
5. 모든 작업이 완료 되었다면 doGot 메서드나 doPost 메서드에서 응답을 생성하고 응답으로 결과를 리턴한다.



## 서블릿의 응답처리
```java
1. 사용자의 요청 
URL ⎼어떤 사용자의 요청이 서블릿 요청이라는 것을 웹 서버가 알기 위해서는 사전에 웹 서버 측에 과 서블릿 
URL URL 클래스를 미리 매핑 시켜 놓은 배포 서술자 가 필요하다 (Deployment Descriptor) . 
⎼배포 서술자는 받은 사용자의 요청이 특정한 서블릿 클래스를 필요로 하는 서블릿 요청이며 웹 서버가 URL 알 수 있도록 
적어 놓은 파일이며 웹 서버가 배포 서술자를 통해 지금 받은 요청이 서블릿 요청이라는 것을 알게 되면 서블릿을 담당하는 
웹 컨테이너로 그 요청을 전달한다.

2. 객체와 객체 생성 
request response ⎼웹 컨테이너는 받은 요청을 처리하기 위해서는 요청을 처리하기 위한 HTIP HttpServletRequest 
인터페이스의 request 객체와 응답을 위한 HTIP HttpServletResponse 인터페이스의 response 객체를 생성한다.

3. 서블릿 인스턴스와 스레드 생성 
⎼request 객체와 response 객체가 생성된 뒤 사용자의 요청이 어떤 서블릿 클래스를 필요로 하는지를 배포 URL 서술자를 통해 알아내고 
각 서블릿 인스턴스는 웹 컨테이너 당 하나만 존재하기 때문에 init 메서드는 각 서블릿 당 한 번씩만 호출된다. 

(1) 인스턴스 미 존재 ⎼클래스가 웹 컨테이너에서 한 번도 실행된 적이 없거나 현재 메모리에 생성된 인스턴스가 없다면 
새로 인스턴스를 생성하기 위해 메모리에 로드하고 init 메서드를 실행하여 초기화 한 뒤 스레드를 하나 생성한다. 


(2) 인스턴스 존재 ⎼인스턴스가 존재할 경우에는 새로 인스턴스를 생성하지 않고 기존의 인스턴스에 스레드만 하나 새로 생성한다.
⎼인스턴스의 생성 흐름은 다음과 같다. 
① 클라이언트의 서비스를 요청하고 객체 생성의 유무 체크를 한번만 확인한다.
② 객체가 있으면 생성 안하고 객체가 없으면 객체를 생성하고 메모리에 올린다 (Yes) (No) . 
③ 호출자 를 실행한다 Invokoer( ) . 
④ 를 만들며 작업용 당 개만 생성한다 Thread request 
1 . ⑤ 생성된 에서 Thread service 메서드 응답 를 호출하는데 이는 스레드의 (response( )) run 메서드와 유사하다. 
⑥ 결과를 클라이언트에게 전달하는데 결과를 타입으로 보내며 웹 브라우저는 이다 MIME text/html . 


* service
service(): 최초 클라이언트의 요청을 받았을때, 컨테이너는 새로운 스레드를 생성하거나 스레드 풀로부터 서블릿을 가져와서 
서블릿의 service() 메소드를 호출한다. 클라이언트의 HTTP 메소드(GET, POST 등)를 참조하여 doGet() / doPost() 혹은 
다른 메소드를 호출할지 판단한다. 재정의는 하지 않으며 doGet()/ doPost() 를 재정의하여 HttpServlet의 service()가 이를 실행하도록 한다.
doGet(), doPost(): service() 메소드가 클라이언트의 HTTP 메소드(GET, POST등) 를 참조하여 doGet()/ doPost()를 호출한다.
여기서 doGet()/ doPost() 만 언급하는 이유는 이것말고 나머지 메소드는 사용할 경우가 거의 없기 때문이다. 
이 메소드 안에서 코딩작업을 하면된다. doGet()/ doPost() 둘중 하나는 반드시 재정의 해야 한다.


-4. 메서드 호출과 서블릿 클래스 실행 service 
⎼스레드가 생성되면 각 스레드에서 service 메서드가 호출된다. 
① 요청 방식이 방식일 경우 서블릿 클래스의 HTTP GET : doGet 메서드 
② 요청 방식이 방식일 경우 서블릿 클래스의 HTTP POST : doPost 메서드 ⎼doGet 메서드와 doPost 메서드는 
request 와 response 객체를 인자로 자동으로 호출되므로 개발자가 실제로 동적인 웹 페이지 생성을 할 수 있는 
코드를 작성해야 하는 부분이 바로 doGet 메서드와 doPost 메서드 부분이다.

응답과 스레드의 소멸 
⎼doGet 메서드 또는 doPost 메서드가 호출되어 사용자의 요청에 따른 동적인 웹 페이지를 생성하면 
그 결과물이 담긴 response 객체를 웹 컨테이너가 응답 형태로 바꾸어 웹 서버로 전송하게 되고 사용이 
HTTP (Response) 끝난 request 객체와 response 객체를 소멸시키고 스레드를 종료하게 된다. 

⎼웹 서버는 전송 받은 응답 메시지를 사용자의 브라우저로 전송하게 되고 사용자는 브라우저를 통해서 HTTP 동적으로 
생성된 페이지를 받아 보게 된다. ⎼배포 서술자를 통해 서블릿 요청임을 알게 되면 
웹 컨테이너는 서블릿 인스턴스의 유무를 검사해 없을 경우 인스턴스를 생성하고 초기화 한다 
생성된 인스턴스 내에 각각의 서블릿 요청마다 하나씩의 스레드를 생성하며 . 
생성된 스레드는 서비스 메서드를 호출한다. ⎼요청 방식이 인가 인가에 따라 각각 GET POST doGet 메서드와 doPost 메서드가 
자동으로 호출된다. 
⎼doGet 메서드 또는 doPost 메서드를 통해 처리된 결과가 response 객체에 담기고 웹 컨테이너는 
이를 HTTP 응답 메시지로 작성해 최종적으로 클라이언트의 브라우저에 전송되게 된다 
```

## 서블릿을 이용한 클라이언트에서 전송되는 요청 처리 
```java
6-1. 요청이 방식으로 전송되어 올 경우 
GET ⎼ 
방식으로 요청이 전송되어 올 경우는 GET doGet 메서드가 최종적으로 호출되기 때문에 해당 메서드에서 요청을 처리해준다. 
⎼서블릿에서 제공되는 HttpServletRequest 인터페이스에서 제공되는 String getParameter(String 메서드가 name) 존재하는데 
이 메서드는 이라는 요청에 전송되어 오는 파라미터 값도 처리하며 이름으로 전송되어 온 name 파라미터 값을 반환해주는 메서드이다.

6-2. 방식으로 요청이 전송되어 올 경우 POST ⎼ 
방식으로 요청을 처리할 경우도 방식으로 요청을 처리하는 경우와 거의 유사하며 단지 서블릿 쪽에서 POST GET 요청 처리를 수행할 때 
doGet 메서드가 아닌 doPost 메서드에서 요청이 처리된다. 

6-3. 하나의 파라미터 이름으로 다중 처리 
⎼HttpServletRequest 인터페이스에서 제공되는 String getParameter(String 메서드는 하나의 전송 파라미터
name) 이름으로 하나의 파라미터 값이 전송되는 경우에 사용한다면 하나의 파라미터 이름으로 여러 개의 값이 전송되어 올 때는 HttpServletRequest 인터페이스에서 제공되는 String[ ] getParameterValues(String 메서드를 paramName) 사용한다.
⎼ 방식은 현재 실행중인 페이지의 실행을 중단하고 다른 웹 자원이 대신 호출되도록 만드는 기능으로 
Redirect JSP 파라미터로 지정한 을 직접 호출하는 것이 아니라 웹 브라우저에 메시지를 보내 웹 브라우저가 을 가지고 
URL URL 웹 서버에 웹 자원을 다시 요청한다. 
⎼ 방식의 Redirect sendRedirect 메서드는 지정된 로 요청을 재전송하고 클라이언트 요청을 다른 페이지로 URL 보내며 형식은 다음과 같다.

```


##  서블릿 페이지 흐름 제어 
```java
1. 방식 Redirect ⎼ 
방식은 제어권을 다른 페이지로 넘길 때 클라이언트의 주소 표시줄의 이 변경되어 요청이 바뀌게 Redirect URL 된다. 
⎼ 방식으로 제어권을 받은 페이지에서는 영역이 달라 서블릿에서 영역에 공유한 Redirect JSP request  
request 속성값에 접근할 수 없다. ⎼요청과 응답이 한 번 더 일어나므로 를 이용해서 데이터 를 공유할 수 없다
Request Scope (Attribute) .


-2. 방식 Dispatcher 
⎼ 방식은 제어권을 다른 페이지로 넘길 때 주소 표시줄이 변경되지 않는다 Dispatcher . 
⎼ 방식으로 제어권을 받은 페이지에서는 하나의 요청이여서 영역을 공유하고 서버에서 다른 Dispatcher jsp  request   페이지를 호출한다. 
⎼ 방식은 방식과 다르게 가 살아있는 상태에서 수행을 넘기므로 같은 영역을 Dispatcher Redirect request request 공유하게 되고 
를 이용해서 데이터 를 공유할 수 있으므로 공유한 속성값에 접근할 수 Request Scope (Attribute) 있다. ⎼
방식은 요청 정보와 응답 정보가 유지되는 장점이 있기 때문에 모델 기반의 웹 프로그래밍에서 Dispatcher 
2 뷰 페이지에서 요청 영역에 공유되어 있는 속성값을 이용하여 페이지를 구성하는 데 유리하다.


7-3. 메서드와 메서드의 차이점 
sendRedirect forward ⎼sendRedirect 메서드는 을 웹 브라우저로 보내서 간접적으로 웹 자원을 호출하지만 
URL forward 메서드는 웹 서버 쪽에서 직접 호출한다. ⎼sendRedirect 메서드를 이용하면 다른 웹 서버에 있는 
웹 자원도 호출할 수 있지만 forward 메서드를 이용하면 같은 웹서버나 같은 웹 어플리케이션 디렉토리 내에 있는 
웹 자원만 호출할 수 있다. 
⎼sendRedirect 메서드를 이용하면 텍스트 문자열 데이터만 전달할 수 있지만 ( ) forward 메서드를 이용하면 
객체 형태의 모든 데이터를 전달 할 수 있다. ⎼sendRedirect 메서드를 통해 한글 데이터를 전달하기 위해서는 
인코딩을 해야 하지만 URL forward 메서드에서는 그런 작업이 필요치 않다
```
