# 브라우저; 톰켓 이용 <>http; 컨트롤러(http 파라미터) <> 자바(모델, 서비스, DAO) <> DB 
- 컨트롤러가 자바면 JSP, C#이면 ASP, PHP면 PHP
- 자바에서 중간 연결체: 클래스 -> 웹과 연동을 하는 클래스: 서블릿이라고 부름
- jsp도 서블릿 역할; 컨트롤러 역할도 함
- 보내주는 방법: 1. 새로운 request 생성(redirect)  2. 기존의 request 유지(forward)
- 포워드 방식을 자주 사용

# 브라우저

## 넷스케이프
- MS에서 익스플로러를 windows 95 plus!에서 부터 끼워팔기 해서 넷스케이프 점유율이 50%까지 추락하였으며 이후에 windows 98에서 부터 끼워팔기를 해서 점유율을 떨어뜨려 개망하게 된 것입니다.


## 인터넷 익스플로우
- 11버전: trident, 12버전: msie

## 크롬
- 크롬은 빠른 속도와, 구글과의 연동 기능으로 평이 좋고 널리 쓰이는 브라우저입니다. 구글에서 받쳐주는 브라우저이기 때문에, 각종 미디어 코덱의 지원도 빵빵하고, 구글 계열의 제품들인 구글 닥스, Gmail, 행아웃, 유튜브, 애드센스, 구글 지도 등과의 연계도 당연히 잘 될수밖에 없습니다. 또, 속도가 빠른 편이기도 합니다.
- 하지만, 이런 크롬에도 단점은 있겠죠? 크롬은 각 탭을 별개의 프로세스로 관리합니다. 그 말인 즉슨, 탭 두개를 열면 크롬 2개가 구동되는 메모리와 같다는 말이죠. 때문에 사양이 낮은 컴퓨터에서는 다른 브라우저에 비해 상당히 무겁게 느껴지는 브라우저인 것도 사실입니다.




## 파이어폭스
- 탭 브라우징에도 많이 신경을 쓴 부분이 보입니다. 글을 쓰다보면 이리저리 참고할 부분이 많은데, 이렇게 탭을 많이 열어놓고 참고해서 쓰고, 또 열다보면 어느새 열려있는 탭이 수십개가 되는 경우가 생깁니다. 이럴 때에 타 브라우저에 비해서 탭을 잘 관리하도록 도와주는 브라우저가 파이어폭스입니다. 탭을 좌우로 드래그해서 보기, 모든 탭 북마크 지정, 이 탭을 제외하고 모두 닫기, 닫은 탭 되돌리기.. 이런 기능들이 다른 브라우저들과 겹치는 기능일지도 모르겠지만, 실제로 사용할때에 가장 편리하다는 느낌을 받은 브라우저는 파이어폭스인것 같네요.
- 이런 파이어폭스의 단점이라면, 아무래도 큼지막한 회사 애플, 마이크로소프트, 구글에서 만드는 다른 브라우저들과 달리 비영리인 재단에서 만드는지라 유튜브에서 60fps 동영상도 지원하지 않는다는 기사를 얼마 전에 본 것 같습니다.
 
# 사파리
- 애플에서 개발하는 브라우저입니다. 따라서 아이폰/패드/팟 같은 애플의 모바일 기기에서는 기본으로 내장되어있기 때문에 점유율이 상당히 높지만, 본 글은 PC의 5대 브라우저에 대해 설명하는 글이기 때문에 PC를 기준으로 말씀드리겠습니다. 윈도우용의 경우에는, 솔직히 말하자면 타 브라우저보다 월등히 나은 점을 발견하기 힙듭니다. 사파리의 개발목적이 윈도우와는 먼 탓도 있고요. 또 개인용 컴퓨터에서 매킨토시를 쓰는 분들이 윈도우에 비해 많이 적기에, PC에서의 위상이 많이 크지는 않습니다. 하지만 5대 브라우저에 포함되는 만큼, 웹 프로그램 개발을 할 때에나 사이트를 만들 때에 절대 무시할수 없는 브라우저이기도 하죠.

## 오페라
- 오페라는 노르웨이의 오페라 소프트웨어에서 개발하고 배포하는 브라우저로, 가늘고 길게 연명해온 것이 특징이라고 할 수 있겠습니다. 또한 굉장히 다양한 플랫폼을 지원하고 있어서, 사파리와 마찬가지로 PC에서보다는 모바일/PDA 기기에서 영향력이 큰 브라우저이기도 합니다. 안드로이드에서의 오페라 미니, 아이패드에서의 오페라 코스트처럼 본래 오페라와 차이가 조금 있는 갈래들을 내기도 하고요.
- 우선 오페라는 다양한 환경, 특히 느린 네트워크에서 돌아가는 것에 상당히 신경을 써둔 브라우저입니다. 오페라 터보 기능(느린 네트워크에서 더 빨리 받을 수 있도록, 웹 페이지를 압축한 뒤 보내주어 로딩 속도를 빠르게 해주는 기능)이 그 대표적인 예라고 할 수 있겠지요. '오페라만의' 분위기나 개성이 강한 편이라, 고정 사용자층이 있는 편입니다.
 
## 브라우저 특징
1. html 지원하는 형태
2. 각 브라우저의 공통으로  레이아웃 지원



# 원격 네트워크
- 브라우저를 이용하지 않은 연동
- 브라우저를 이용한 연동은 ‘웹’이라는 말이 들어간다.

# 브라우저
* 익스플로어, 엣지, 파이어폭스, 크롬, 오페라, 사파리

## 시크릿 모드
* 입력정보를 보관하지 않음
* 캐시(임시파일)를 보관하지 않음
* 쿠키를 보관하지 않음

# 웹 서버 (Web Server
 * 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(.html, .png, .css등)를 제공하는 서버
 * 클라이언트에서 요청이 올 때 가장 앞에서 요청에 대한 처리를 한다.
 * 클라이언트의 요청을 기다리고 요청에 대한 데이터를 만들어서 응답하는 역할 (정적 데이터)
 
## CASE
 * 정적 컨텐츠를 요청(request)했나?
 * 1. 정적 컨텐츠구나! 내가 제공해줄게 => .html, .png 등 응답(response)
 * 2. 정적 컨텐츠가 아니구나.. 웹서버에서 간단히 처리 못하겠군. WAS에게 처리를 부탁해야겠다! => 결국 WAS가 처리해준 컨텐츠를 받은 웹서버는 응답(response)을 해줌
 * 대표 : Apache, nginx
 
 
# WAS (Web Application Server)
 * 동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버 (DB조회, 로직처리가 요구되는 컨텐츠)
 * JSP,Servlet 구동 환경 제공
 * 컨테이너, 웹컨테이너, 서블릿 컨테이너라고도 부름
* JSP, servlet을 실행시킬 수 있는 소프트웨어 = 컨테이너
 
 
## 동작 프로세스
1. 웹서버로부터 요청이 오면 컨테이너가 받아서 처리
2. 컨테이너는 web.xml을 참조하여 해당 서블릿에 대한 쓰레드 생성하고 httpServletRequest와 httpServletResponse 객체를 생성하여 전달한다.
3. 컨테이너는 서블릿을 호출한다.
4. 호출된 서블릿의 작업을 담당하게 된 쓰레드(2번에서 만든 쓰레드)는 doPost()또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response객체에 담아 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response객체를 HTTPResponse형태로 바꿔 웹서버에 전달하고 생성되었던 쓰레드를 종료하고 httpServletRequest, httpServletResponse 객체를 소멸시킨다.
대표 : Tomcat, Jeus, JBoss
 
## Web Server가 필요한 이유?
 * 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
 * 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
 * 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
 * Web Server를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
 * 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
## WAS가 필요한 이유?
 * 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다.
 * 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
 * 이때, Web Server만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.
 * 하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
 * 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
 
## WAS와 웹 서버 차이
 * - 클라이언트 - WAS(웹서버 - 웹컨테이너: JSP, Servlet) - 데이터 베이
 * - 동적 컨텐츠 처리를 수행 가능한가 아닌가.
 * WAS는 정적,동적 처리 둘다 가능하지만 정적처리를 WAS가 하게되면 부하가 많이 걸려서 좋지 않음
 *  
 * * 톰캣(WAS)에는 아파치(웹서버)의 기능(웹서비스데몬, Httpd)를 포함하고 있다.
 * - 일반적인 WAS, Web Server 구조가 아닌 걸로 알고 있음.
 *  
 * * WAS, Web Server를 따로 두고 쓰는 이유가 성능때문이라고 하는 건 잘못되었다.
 * 톰캣5.5 이상부터는 httpd의 native모듈을 사용해서 정적파일을 처리하는 기능을 제공하는데 이것이 순수 아파치 Httpd만 사용하는 것과 비교해서 성능이 전혀 떨어지지 않기 때문이다.
 * 그럼에도 톰캣앞에 아파치를 두는 이유는 하나의 서버에서 php애플리케이션과 java애플리케이션을 함께 사용하거나, httpd 서버를 간단한 로드밸런싱을 위해서 사용해야 할 때 필요하기 때문.


## 로드밸런싱(Loadbalancing)
 * 로드 밸런싱이란 부하 분산을 위해서 가상(virtual) IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.
 * 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도 저하 등을 고려하여 적절히 분산처리하여 해결해 주는 서비스이다. 로드밸런싱을 해주는 소프트웨어 혹은 하드웨어 장비를 로드밸런서라고 한다. 로드밸런서의 주 목적은 동시에 오는 수 많은 커넥션을 처리하고 해당 커넥션이 요청 노드 중의 하나로 전달될 수 있게 하는 것이다. 그리고 단지 노드를 추가하는 것만으로 서비스가 확장성을 가질 수 있도록 한다. 오픈 소스 로드 밸런서 중 많이 사용되고 있는 것은 HAProxy 이다.

## 로드 밸런싱에서 사용하는 주요 기술은 다음과 같다.
 * NAT(Network Address Translation) : private IP를 public IP로 바꾸는데 사용하는 통신망의 주소변조기
 * DSR(Dynamic Source Routing protocol) : 로드밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념
 * Tunneling : 인터넷 상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념으로, 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제할 수 있다.
 * 
 * 로드밸런서를 사용할 때 어려운 문제 중 하나는 세션 데이터를 관리하는 것이다. 서버에 액세스 할 때마다 다른 세션을 사용한다면 특정 사용자의 정보를 일관성있게 유지할 수 없게 된다. 이러한 문제를 해결하기 위해 세션을 고정(session sticky)한다. 이 방법으로 특정 사용자의 요청이 전달될 노드를 고정시킬 수 있다. 하지만 이 방법도 문제가 있다. 고정된 세션의 노드에 장애가 발생하면 고정한 의미가 없어진다. 장애가 발생하여 비활성화된 노드에 대한 고려가 필요하다.

## 대용량 서비스를 운영하려면 부하 분산은 필수이다.
 * 대용량 트래픽을 장애없이 처리하려면 여러 대의 서버에 적절히 트래픽을 분배해야 한다.
 * 단지 몇 개의 노드만 있다면 라운드 로빈 DNS와 같은 방식이 합리적이다. 로드 밸런서 자체의 비용이 높고 불필요한 복잡함을 증가시킬 수 있기 때문이다.  DNS에서는 하나의 도메인 이름을 라운드 로빈 방식으로 여러 개의 IP 주소를 변환한다면 이것만으로 쉽게 부하 분산이 가능하다. 하지만 여기에 두 가지 단점이 존재한다. 첫째, 대부분의 클라이언트에서는 DNS 서버의 부하를 줄이고 성능을 향상시키기 위해 일정 시간 동안 캐싱하기 때문에 부하 분산이 균등하게 발생하지 않는다. 둘째, 특정 서버에 장애가 발생하더라도 장애 여부가 감지되지 않아 서비스에서 해당 서버를 제거할 수 없다.
 * 그렇기 때문에 대규모 시스템에는 다양한 알고리즘과 스케줄링이 사용되고 있다 이러한 알고리즘들은 네트워크 트래픽과 분산 요청을 제어하면서 자동 절체나 이상 노드 제거와 같은 신뢰성 관련한 기능을 제공한다.

## 클러스팅
 * - 여러 개의 컴퓨터를 연결한 병렬 시스템으로 마치 하나의 컴퓨터처럼 사용하는 것을 클러스터라고 한다. 클러스터링 환경에서는 특정 장비에 문제가 생기거나 특정 장비에서 실행중인 애플리케이션에 문제가 발생하더라도 전체 서비스에 영향을 미치지 않도록 제어가 가능하다.
 * 클러스터링은 기본적으로 Virtual IP(가상 IP)를 기반으로 구현된다. 서비스를 제공하는 실제 장비는 물리적인 IP를 갖고, 데이터의 처리는 Virtual IP를 통해 이루어진다. 내부 시스템은 철저하게 가려져 있는 것이 원칙이다.
 * 
 * 확장 면에서 비교
 * 둘 다 scale-out 방식, 즉 수평 방향으로 노드를 추가해서 성능을 업그레이드 하는 방법이다. 저렴한 노드를 여러개 묶어서 성능을 업그레이드 하며, scale-up 방식에 비해 비용을 줄일 수 있으며 유연한 구성이 가능하다. 로드밸런싱은 하나의 서비스를 하나 이상의 노드가 처리하는 식으로 작동한다.

### 어떤 점이 좋은가?
 * 1 . 저렴한 비용으로 다수의 서버를 증설하여 비용절감의 효과를 볼 수 있다.
 * 2. 1대의 서버 장애가 발생하여도 서비스 중단없이 다른 서버로 적절히 자동 분배되어 서비스가 계속 운용가능하다.
 * 3. 서버를 확장할 때에도 서비스 중단없이 서버 증설이 가능하다.


# 대칭키 기법
- https://soul0.tistory.com/372 
- 하나의 비밀키를 양쪽(client - server)가 모두 같이 사용하는 것이 문제
-     (암호화와 복호화에 같은 암호 키를 쓰는 알고리즘)
- 해커로부터 안전할 수 없다
- 알고리즘 방식으로 DES, 3-DES, AES, SEED, ARIA, MASK 등이 있다.

# 비대칭키
- 비대칭키 는 암/복호화 할때의 Key 값이 다르다 대표적으로 RSA 라는 암호화가 있으며
 암호화 할때의 키를 공개키(Public Key) 복호화 할때의 키를 ​개인키(Private Key) 라고 한다.
- 즉,  암호화 할때의 Key 와 복호화 할때의 Key 값이 같으면 “대칭키”  ​암호화 할때의 Key 와 복호화 할때의 Key 값이 다르면 “비대칭키” 라고 한다.
 




# 공개키 기법 (≒비대칭키 기법, ≒비밀키 암호화, ≒비대칭형 암호 알고리즘)
- 보내야 하는 데이터를 송신자가 수신자의 공개키로 암호화를 걸어 놓고 데이터를 받은 수신자가 자신의 개인키(=비밀키)로 복호화를 하는 방법
- 개인 키는 한쪽에만 속해 있기 때문에 개인 키가 사용된 것으로 나타난 모든 경우 해당 키의 소유자만이 그것을 사용했다고 결론지을 수 있다.
- 한 쌍(공개키 + 개인키)의 키 조합이 필요.
- 암호화에 사용된 키와 복호화에 사 용된는 키가 다름에도 수학적 원리에 의해 해독이 가능하도록 한 방식
- 알고리즘 방식으로 RSA, DSA 등이 있다.
- 공개키 기법은 시간이 오래 걸리는 단점을 극복하고자 공개키 암호화는 대칭키를 보내는 용도로만 사용
- 개인키만 잘 보관하면 완벽한 암호화 기법

## 공개키 과정
- 공개키로 암호화하면 개이키로만 풀 수 있다.
- 각 키는 매우 큰 숫자이므로 한 개의 키로 다른 키를 알아내기 어렵다.
상대방에게 내 공개키를 알려준다.
2. 상대방은 나에게 자신의 공개키를 알려준다.
3. 상대방은 나의 공개키를 이용해 암호화된 문서를 나에게 보낸다.
4. 나는 내 개인키로 이 암호문을 해독한다.
5. 내 대답은 상대방의 공개키로 암호화해서 보낸다.
6. 상대방은 자신의 개인키로 내 글을 해독한다. 

# 공개키 기법으로 암호화한 대칭키 기법 내용
- 표준 보안 방식 SSL 이라고 부름.
- Secure Socket Layer
- 접속한 사이트가 신뢰할 수 있는 지 확인하기 위한 인증서가 출현
- 대칭키 기법 + 공개키 기법 = 장점만을 살린 방법
- 여기서 사용되는 대칭키는 매번 랜덤으로 선택되는데, 이렇게되면 만약 대칭키가 누출되어도 다음번에는 다른 키가 사용되기 때문에 안전
# 인증서란? ( 사이트와 인증기관의 구분을 명확히 생각하도록 하자. )
- 모든 개인키는 오직 자기 자신만 소유한다. 즉, 통신을 위한 공개키를 대충에게 공개해야 한다.
- 공인 인증 기관 출현
- 공인 인증 기관은 인증서를 발행해 주지만, 주 목적은 요청한 사이트에게 해당하는 인증기관 개인키와 인증기관 공개키 쌍을 만든다. 사이트에는 인증기관 개인키로 암호화한 인증서(사이트 공개키 + 사이트정보)를 발행 / 웹 브라우저에는 인증기관 공개키를 발행하여 암복호화 할 수 있도록 구성
- 사이트 개인키(Private Key) 를 보증(SSL 통신)하기 위해서 그 쌍이 되는 사이트 공개키(Public Key)가 바로 인증서에 들어있음.
- 또한 '공인 인증 기관의 전자 서명'이 바로 인증서에 들어 있음.
- 즉, 인증서는 사이트 공개키 + 공인 인증 기관의 전자 서명
- 인증서는 공개된 위치에 저장해서 요청하는 사람에게 내려보내 줄 수 있는 시스템이 갖춰져 있다. (보통 공인 인증 기관의 LDAP 에 저장)
- 이를 PKI(Public key infrastructure) 라고 한다.

## 인증서의 Root CA
- SSL의 기본 구조는 당신이 인증서를 서명한 사람을 신뢰한다면, 서명된 인증서도 신뢰할 수 있다는 것
- 이것은 마치 트리(Tree)와 같은 구조를 이루면서 인증서끼리 서명하게 된다.
- 인증서를 발행한 기관을 Root Certification Authority(Root CA)라고 부르며, 널리 알려진 인증 기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 웹브라우저에 기본적으로 설치되어 있다.
- Root CA의 인증서는 누가 서명을 했을까? 모든 Root CA 인증서는 자체 서명(Self Signed)되어 있다.
- 여기서 서명이란 신뢰할 수 있다고 서명하는 것을 뜻함.

## 정리
 * Q: SSL 이란?
 * A: 데이터를 암호화 해서 주고 받는 것
 * 
 * Q: SSL은 어떤 키를 사용?
 * A: 실제 암호문을 주고받는 것은 양쪽이 같은 대칭키를 사용 (대칭키를 전송하기 위한 공개키를 사용과 햇갈리지 말자)
 * 
 * Q: 대칭키를 전달할 때 위험을 피하는 방법은?
 * A: 사이트의 공개키로 암호화해서 데이터를 전송
 * 
 * Q: 인증기관의 역할은?
 * A: 사이트의 공개키가 신뢰할 수 있는지 보증하는 역할
 * A: 인증기관의 개인키로 사이트의 공개키를 전자서명과 함께 암호화 = 인증서 (이는 인증기관의 공개키로만 풀 수 있기 때문에 인증기관에서 발급한 인증서가 신뢰할 수 있다고 판단할 수 있다.)
 * 
 * Q: 인증서란?
 * A: 사이트의 공개키와 사이트 정보(전자서명 등)을 인증기관 개인키로 암호화한 파일에 불과하다.
 
# 쿠키와 세션의 차이

# 쿠키
- 쿠키란 서버측에서 클라이언트측에 상태 정보를 저장하고 추출할 수 있는 메커니즘
- 클라이언트의 매 요청마다 웹 브라우저로부터 서버에게 전송되는 정보패킷의 일종
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 하드 디스크에 저장하였다가 필요 시 정보를 참조하거나 재사용할 수 있음.
 
## 쿠키의 원리
- 클라이언트가 브라우저를 통하여 웹페이지 접속(Web Server) -> 클라이언트가 요청한 웹 페이지(HTTP)를 전송하면서 쿠키설정(클라이언트의 상태정보 하드디스크 저장) -> 클라이언트 재 방문시 웹페이지 요청과 함께 쿠키값도 같이 전송

## 예제
-  방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
- 팝업에서 “오늘 이 창을 다시 보지 않음” 체크

## 쿠키의 제약 조건
- 클라이언트에 총 300개까지 쿠키를 저장할 수 있다
- - 하나의 도메인 당 20개의 값만을 가질 수 있다
- 하나의 쿠키 값은 4096Byte까지 저장 가능하다
- [주의]하나의 도메인에서 설정한 쿠키값이 20개를 초과하면 가장 적게 사용된 쿠키부터 지워짐. 또한 쿠키는 기존에 설정한 값이 있는 곳에 값을 저장하거나 배열형태의 쿠키에 단일 값을 저장하려고 할 때 아무런 경고 없이 덮어쓰기 때문에 주의를 해야 한다.

# 세션이란?
- 세션이란 클라이언트와 웹서버 간에 네트워크 연결이 지속적으로 유지되고 있는 상태를 말함
- HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속시마다 새로운 네트워크 연결이 이루어진다.
- -클라이언트가 웹서버에 요청하여 처음 접속하면 JSP(혹은ASP)엔진은 요청한 클라이언트에 대하여 유일한 ID를 부여하게 되는데, 이 ID를 세션이라 부른다.
- 이 ID는 쿠키를 사용하여 유지되며, 이 쿠키의 이름이 JSESSIONID 입니다. 서버는 JSESSIONID를 웹 브라우저에 전달하고, 클라이언트는 새로운 접속시 쿠키를 통해서 세션 ID값을 서버에 전달한다
- -세션 ID를 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 구분할 수 있는 유일한 수단이 된다
 
# 세션의 장점
- 각각의 클라이언트마다 고유의 ID 부여
- 세션 객체마다 저장해 둔 데이터를 이용하여 서로 다른 클라이언트의 요구에 맞게 서비스 제공
- 클라이언트 자신만의 고유한 페이지를 열어놓아서 생길 수 있는 보안상의 문제 해결 용이
 
## 쿠키와 세션의 차이점
- 쿠키(cookie)와 세션(session)은 기능상 비슷한 역할을 하고, 동작원리도 비슷하다. 왜냐하면, 일반적인 세션은 쿠키를 바탕으로 동작하기 때문이다. 그러나 가장 중요한 차이점은 저장되는 곳이 다르다는 것이다. 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다. 쿠키의 경우에는 서버의 자원을 전혀 사용하지 않지만, 세션의 경우에는 서버에 저장되기 때문에 서버의 자원을 사용할 수가 있다.쿠키와 세션의 만료 되는 기간도 다르다.

# CSS
## 우선순위
- css가 제일 우선순위가 높다.
- id가 class보다 우선순위가 높다.

## id 와 class 의 차이점

- id는 한페이지에 하나의 정의(style/css)로 하나의 태그(id="")만 사용할 수 있다. 즉 로고, 상단메뉴, 하단정보 같은 스타일을 정의할 때 id를 사용한다
- class는 한페이지에 반복적으로 사용되는 스타일을 정의할 수 있다.
- 반복적으로 사용되는 스타일에는 class를 이용하여 정의하고, 그 내부에 세부 스타일을 정의할 때 id를 사용해주면 효과적이다.

# block과 inline 차이
## inline
-  width/height 적용 불가
- margin/padding-top/bottom 적용 불가
- line-height 원하는 대로 적용 불가(span에 적용안되고 감싸고 있는 div 전체 크기에만 영향 등)


## block
- 반면 block은 무조건 한줄을 점유하고, 다음 태그는 다음 줄로 가버리죠.
- width/height 적용 가능
- margin/padding-top/bottom 적용 가능
- line-height 적용 가능
- 다만 고려해야 할 것이 있습니다.
- inline-block 끼리 공백이 생기게 되는데, 이때는 상위 div에 { font-size: 0; } 를 적용하면 해결이 됩니다.
- inline-block 끼리 높이가 안맞을시 상위 공백이 생기는데, 이때는 { vertical-align: ---; } 값으로 top 등을 줘서 맞춰주시면 됩니다. 
- 디테일한 보정이 필요하고 예민하신 분들은 inline-block 쓰시는게 낫고,
text 내의 특정 부분 스타일 등 간단한 것들은 그냥 inline 쓰시면 됩니다.







# font-family
- 파이썬 라이브러리에서 이미지의 한글 인식 위한 것.

# form
## action
- <form action="#"> </form>; 자기 자신 문서를 의미



# 자바스크립트
## null
- null 객체라고 함.
- ⎼str 변수의 내용을 검사하여 “”을 출력하고 null을 할당하는 것 보다 웹에서는 “”을 할당하는 것을 권장한다


## script
- head나 body 어디든 적어도 되나 특수한 경우엔 어떤 것에만 놓아야 하는 경우가 있음.


# document
## getElementById
- document.getElementById: id에 따라 찾기
- 만약 해당하는 id 를 가진 태그가없을경우 null 에러가 발생한다.


## getElementsByTagName() 함수 , 

- 이 함수는 태그의 있는 div, li, p 와 같은 특정 태그명을 가지고 있는 element 의 집합을 가져오는 함수이다.
- 따라서 반환되는 값은 HTML컬렉션 객체이며 for문 등을 사용하여 element 객체를 사용할수있다.

##  getElementsByClassName() 
- 이 함수는 태그의 class="" 속성을 사용하여 접근한다.

- 동일한 class명이 존재할수 있기때문에  ( id속성은 html 문서에 동일한 id속성이 존재하면 안된다..) 

- id 속성을 사용하여 접근하는 getElementById() 와 달리 getElementsByClassName() 은 컬렉션 객체를 반환한다.

- 따라서 for문을 사용하거나 특정 index에 위치한 element를 반환받아 사용할수있다. 사용예는 아래와 같다.


## innerHTML
- innerHTML 을 사용하면 HTML 문서안에는 태그의 내용을 가져오거나 변경할수있다.
- sample.innerHTML = "bye"


## write()
- document.write()는 문서안의 텍스트 또는 연산된 숫자를 넣을수있다.

## console.log
- console.log는 말그대로 콘솔에 로그를 남길때 사용하는데, 콘솔은 개발자모드(F12) 에서 확인할수있다. 주로 디버깅용도로 사용한다.

# Tern
- 웹 단축키; 매번 configure 가서 설정해 주어야 함.

# 타입
## 기본 타입
- 숫자
- 모든 숫자를 64bit 부동 소수점 형태로 저장하며 정수와 실수의 구분이 없다 
- 문자열
- 불린값
- undefined
- null

## 참조타입
- 객체
- 배열
- 함수
- 정규표현식

# 속성값
- 객체, 함수, 메소드 기능 포함

# 따옴표
- R: 큰 따옴표
- 자바 스크립트: 큰 따옴표
- 파이썬: 작은 따옴표; 
- 제이슨: 큰 따옴표

## ==
- ⎼동등 연산자는 1 == "1" 은 두 피연산자의 타입이 다르므로 같은 타입으로 변환해서 두 값이 같다고 판단해서 document 객체의 write 메서드로 true를 출력한다.  
- ⎼동등 연산자의 비교는 타입변환에 따른 결과를 얻을 수 있으므로 대부분의 자바 스크립트 코딩 가이드에서 동등 연산자로 비교하는 것을 추천하지 않는다. 

## ===  Strict Equal Operator
- a = 1;  b=”1”;  브라우저에서 같은값으로 인식 가능;  ==으로하면 같은값 인식
-  10 : document.write(a === b); ⎼일치 연산자는 1 === "1" 은 두 피연산자의 타입이 다르므로 document 객체의 write 메서드로 false를 출력한다.
- 값과 타입 둘다 비교

### undefined와 null 의 비교 
- undefined == null => true
- undefined === null => false


## 크롤링
- R, 자바 스크립트, 제이슨

## typeof
- typeof는 unary 오퍼레이터이다. unary 오퍼레이터로는 ! 라던가 - 등과 같이 인자를 하나만 받을 수 있는 연산자를 뜻한다. 즉, 함수가 아니고 연산자이기 때문에 괄호를 사용하면 안된다.

### null 확인법
- 자바 스크립트는 null이라는 객체이다.
- if(typeof yourVariable === 'object') { /* 오브젝트 처리 */}
- 하지만 위와 같이 하게 되면 만약 yourVariable이 null이라면 결과가 true로 나타난다. 따라서 null인 경우 false의 결과를 나타내고 싶다면,
- if(yourVariable != null && typeof yourVariable === 'object') {/*오브젝트 처리*/} 
- if(!!yourVariable && typeof yourVariable === 'object') {/*오브젝트 처리*/}


## instance of
- : instanceof 는 비교 연산자로 >,<,== 와 같이 두개의 인자를 받는 연산자로 앞의 비교 연산자들을 이용하는 기분으로 사용하면 된다. 하지만 결과로 리턴하는 것은 typeof와는 성질이 조금 다르다. instanceof는 해당하는 변수가 사용하고 있는 prototype의 chain을 2번째 인자와 쭉 비교해서 true/false 값을 리턴한다.
- 쉬운말로 하자면, 해당하는 변수의 클래스와 비교해서 리턴해주는, java에서 많이 쓰던것과 비슷하다고 볼 수 있다.
- 자바스크립트는 instanceof 연산자가 존재한다. 이 연산자는 생성된 인스턴스 객체가 어떤 생성자 함수를 사용하여 생성되었는지 확인하고 불리언값으로 반환하여 주는 유용한 연산자이다. 이 연산자를 사용해 생성자 함수를 확인하는 과정을 예제를 통하여 알아보고자 한다.


# 연산자
- 쉬프트연산자는 산술연산자보다 우선순위는 나르지만 계산 속도가 더 빠르다.
- 비트 연산자도 관계예산자보다 우선순위는 낮지만 속도가 더 빠르다.
# 객체 표기법
- 파이썬에서는 딕셔너리, 자바에서는 맵이라고 표현
- 객체 표기법 - 제이슨
- 몽고디비, 카산드라는 객체표기법 사용

## 예제
- var person = 
- {
- 		fname : "홍", 
- 		lname : "길동",
- 		age : 25
- };


# 배열리스트  []
- 자바에서는 리스트, 파이썬에서는 리스트라고 함.


# for문

## for in 반복문과 for of 반복문의 차이점
- for in 반복문 : 객체의 모든 열거 가능한 속성에 대해 반복
- for of 반복문 : [Symbol.iterator] 속성을 가지는 컬렉션 전용; 인덱스로 접근 가능
- for...in iterates over the enumerable properties of an object
- for...of iterates over the property values of objects
- basic for문과 for in은 반복변수에 index를 리턴하지만 forEach 와 for of 는 해당 값을 리턴하기 때문이죠.
- forEach는 위와같이 callback 함수가 필요합니다. 굳이 이걸 쓸 필요 없이 같은 기능을 하기 위해 나온것이 for of이죠.
- for ... of 문은 반복가능한 객체(Array, Map, Set, String, TypeArray, arguments 객체등)를 반복하는 문법입니다.





## for in
- for(var i = 0; i < array.length; i++){
-       alert(array[i]);
-    }

위와 아래 같은 역할 

- for(var i in array){
-       alert(array[i]);
-    }


# 함수
- 반복해서 호출해서 사용할 수가 있다.
- 메소드는 복제 기능이 없다(= 객체를 통해서 사용하는 것이 없다)
- 함수는 복제, 메소드는 상속을 통해 재사용성을 가진다.
- // 변수나 함수는 동급이다. 둘 다 객체다.
- // 변수는 정적 객체고 함수나 메소드는 동적 객체다.
- 같은 객체이기 때문에 함수를 변수에 복제 가능(프로토 타입)
	- 정적 객체지만 속성은 동적 객체를 가질 수 있음.


## 변수에 함수 복제
- 매개변수에 들어가기 위해서 변수에 복제
- function sot() {
	
- document.write("함소 호출");
- }

- var minsot = sot;

- minsot(); 

## 정적 객체에 동적 객체 바로 할당
- 매개변수에 들어가기 위해서 변수에 복제
- var minsot1 = function sot() {
	
- document.write("함소 호출");
- }

## 정적 객체에 동적 객체 바로 할당 2
- 매개변수에 들어가기 위해서 변수에 복제
- var sot = function sot() {
	
- document.write("함소 호출");
- }
- sot(); // 정적 객체와 동적 객체의 래퍼런스가 다르기 때문에 같은 이름 대입 가능


# 프로토타입 기반
- R, 자바 스크립트

# DB 언어
- SQL: 오라클, ms-sql, my-sql
- No-SQL: 몽고디비, 카산드라

# 스크립트 기반
- 파이썬, 루비, 자바스크립트, 몽고디비, 카산드라 : 인터프리터 식, 함수형 언어



# 프로토타입
- 복제 기능 담보
- 함수 1. 완전 복제(레퍼런스 복제) 2. 부분 복제(레퍼런스 변경)
1. 원래있던 객체 복제 2. 빈객체를 선언해서 생성하는 방법

# 프로토타입 객체
- 함수를 생성하면 동시에 생성되는 프로토타입을 new 키워드로 함수에서 찍어낸
모든 객체들이 이 프로토타입을 참조하기 때문입니다.
- JavaScript에서는 기본 데이터 타입인 boolean, number, string, 그리고 특별한 값인 null, undefined 빼고는 모두 객체입니다. 사용자가 정의한 함수도 객체이고, new라는 연산자를 통해 생성된 것도 객체입니다. 객체 안에는 proto(비표준) 속성이 있습니다. 이 속성은 객체가 만들어지기 위해 사용된 원형인 프로토타입 객체를 숨은 링크로 참조하는 역할을 합니다.

## 리스트, 그래프에서 프로토타입
- 프로토타입 방식으로 function을 var에 저장하여 사용하면 그때그때 함수를 호출할 필요가 없기 때문에 그래프가 빠르게 만들어진다.
- 리스트 같은 경우도 게시판처럼 한번만 만들 필요가 있는 것은 그때그때 호출해도 상관 없지만 여러번 호출이 필요할 경우 프로토타입을 사용한다.

## function과 prototype
- 먼저 함수를 선언하면 위와 같은 구조의 2개의 객체가 생성이 됩니다. 하나는 function 객체이고, 다른 하나는 prototype 객체입니다. 단순히 2개의 객체가 생성된 것만 아니라 두 객체는 서로 이어져 있는데 함수에서는 프로토타입 객체에 prototype이라는 내부변수로 접근 할 수 있고, 프로토타입에서는 constructor라는 변수로 함수에 접근 할 수 있게 됩니다. 서로를 참조하는 레퍼런스 변수를 통해 두 객체는 접근 뿐만 아니라 변경도 가능합니다.
- 함수는 프로토타입을 생성하지만, 함수 스스로가 프로토타입으로부터 값을 얻지 못함을 알 수 있습니다. 설정은 해놓고 쓸수 없다면 의미가 없죠. 그렇다면 프로토타입이 원형 이라는 자신의 이름값을 하기 위해서는 다른 방식접근해야 하는데 그 방법은 바로 인스턴스를 생성하는 것입니다.



# 원형
- {}, [], 문자열은 아님(‘’와 “” 둘다 존재)
- 스택 구조에 저장됨, 그리고 index를 통해 수정 가능


## 원형을 객체에 할당
 * = 
 * var people = {};
 * people.name = "홍길동";
 * 
 * 
 * people.setName = function() {
 * 	document.write(this.name);	
 * }
 * 	
 * 	people.getName = function() {
 * 		
 * 		return this.name;
 * 	}
 * 
 * 
 * people.sayInfo = function() {
 * 	document.write(this.getName);
 * }
 * 
 * 
 * - 원형에서 선언되었기 때문에 전역적 역할을 하게 된다.


# navigator

## userAgent 프로퍼티
- 인코딩 위해 필요


## minetype


# window.open
- width: 옵션


# this, self


# location
- action과 비슷

# 엑셀
- 무겁다, 엑셀필요, 지원범위 좁다

# xml
- 무겁다, 지원범위 좁다


# json
- ⎼ 안에서 배열을 값으로 사용할 경우에는 하나의 이름 안에 배열로 구성된 여러 개의 데이터 를 포함시킬 JSON 수 있지만 하나의 데이터는 오직 하나의 값으로만 구성되기 때문에 결국 단순한 키워드의 나열과 같은 경우 밖에 사용할 수 없다는 단점이 있다. 

## json 배열
- JSON 데이터에서의 배열 사용하는 방법과 계층 JSON 데이터 방법의 장점만 조합한 형태로 JSON 안에 새로운
- JSON이 포함되는 계층형 구조에서 각각의 데이터가 독립적 이라는 점을 배열로 보완하여 하나의 키 이름 안에서 여러 개의 데이터를 JSON으로 표현할 수 있다.
- 구성된 데이터는 하나의 키에 대응되는 값들이 배열로 구성되고 각 배열의 요소들이 동일한 구조의 JSON으로 구성된다.
- 하나의 JSON 키에 배열이 할당되어 있고 배열에 포함된 데이터들이 JSON 일 경우에 각 배열 요소들이 반드시
- 동일한 구조로 구성 될 필요는 없지만 규칙성 있는 JSON으로 배열이 구성될 경우는 프로그램의 처리 과정을 구성하는데 있어서 일정한 형식의 코드를 작성할 수 있다는 이점 때문에 대부분의 경우 배열의 각 요소는 동일한 구조를 갖는 JSON이 사용된다.
- 배열 안에 새로운 JSON을 포함하는 복합구조는 게시판과 같이 동일한 구조의 복합 데이터가 반복적으로 나타나는 형태에 적용 할 수 있고 이 복합구조가 Ajax에서 가장 많이 사용되는 데이터 구조이다.


## json 배열 읽기
- ⎼ 데이터의 기본 접근 방법은 객체명이름 의 형식지만 이름에 할당된 데이터가 배열이라면 그 배열의 JSON . 인덱스 번호까지 함께 명시 해 주어야 한다.
- 객체명이름 인덱스 . [ ];

## json 하위
- ⎼ 데이터 안에 새로운 데이터가 포함되어 있는 구조는 데이터가 계층적으로 구성될 수 있기 때문에 JSON JSON 데이터간의 포함관계를 표현하기가 쉽다는 장점이 있지만 하위 객체로 포함된 의 이름들이 독립적이기 JSON 때문에 하나의 객체 안에 존재하는 하위 객체들 간의 연관성이 적다는 단점도 지니고 있다.
- 객체명하위객체명이름

## json 하위 형태
- var 객체명 = { 
하위객체명 이름 값 이름 값 이름 값 :   { (key): (value), (key): (value), (key): (value) }, … 
하위객체명 이름 값 이름 값 이름 값 : { (key): (value), (key): (value), (key): (value) } … 
- };

# jQuery
 * jQuery 1.x
- 모든 브라우저 지원
- jquery-migrate-1.2.1, jquery-1.11.2 + min 파일

jQuery, migrate 차이

# 자바 스크립트
- 웹 솔루션 개발자: 폼 제어
- 스크립트 언어: 뷰, 자바, 파이썬: DB 연동
- 자바 스크립트 -> jQuery로 css, html 조종
- 즐겨찾기 -> 파이썬 라이브러리(크롤링; document) -> jQuery -> 탐색 기능

# jQuery
- : jquery는 모질라 소속이었던 John Resig이 개발한 라이브러리로 현재 가장 인기 있는 자바스크립트 라이브러리 중 하나로 꼽히고 있다. jquery 자체에 대한 이야기를 많이 하지는 않을 것이니 아직 jquery를 한번도 접해보지 않은 사람이라면 위의 사이트를 방문해서 간단하게 둘러보는 것도 괜찮을 것이다.
- 기존에 자바스크립트로 사용했던 DOM 탐색의 경우 끽해야 id 탐색, class 이름과 태그명으로 탐색했었는데 이러한 것들을 CSS 의 검색 스타일로 너무나 쉽게 적용을 해서 나타난 것이다.

# jQuery의 장점
- 그렇다면 jquery의 가장 큰 장점이 무엇이라고 생각하는가? jquery를 사용해본 사람이라면 단축된 문법이라던가 여러 가지 말을 하는 것보다는 '멀티 브라우져 지원'을 말할 것이다. 어느 브라우져에서나 동일하게 작동을 한다는 것은 자바스크립트 개발자로서는 너무나 매력적인 일이다. 특히 IE의 독자노선 행보로 인해 IE와 다른 브라우져들은 자바스크립트에서 지원하는 기능이 다르거나, 같은 기능이 있더라도 사용 방법이 다른 경우 jquery에서는 이것을 전부다 해결해준다는 것이 제일 큰 장점이라고 말할 수 있을 것이다.
- 멀티 브라우져에서의 ajax이용, 이벤트 설정, DOM 탐색이야말로 jquery의 핵심적인 기능인 것이다.
- 또 다른 장점은 바로 간단하게 이용할 수 있는 핵심 기능들을 포함하고 있다는 것이다. 다른 것보다도 아마 가장 많이 이용할 기능은 바로 toggleClass나 removeClass가 아닌가 생각한다. 일을 할 수 밖에 없게 되는 것을 toggleClass 하나로 해결하게 된 것이다. addClass는 그냥 += 을 이용하면 간단하게 해결되지만 제한된 상황이 아닌 용도에서 정규표현식을 잘 모르면 indexOf, replace, substring 등등 매우 복잡하고 무거운 함수를 만들어야 할 것이다.
- 특히, jquery-mobile을 이용해본 사람이라면 모든 모바일 단말에서의 똑같은 UI와 동작으로 인해 그 매력에 빠졌을지도 모른다. 단순히 attribute를 설정해주는 것만으로 UI들이 바로바로 적용되는 놀라운 기능들을 소개해주고 있다. 물론, 그 디자인을 보게 되면 너무나 투박하기 짝이 없기는 하지만 말이다.



## jQuery 단점
- 하지만 언제나 만능은 없는 법. jquery도 단점은 있기 마련이다. 무엇보다도 jquery라는 라이브러리를 이용하기 위해 새로운 API를 학습해야한 다는 것이 큰 이슈일 것이다. 이는 jquery를 한번도 접해보지 않은 사람이 처음으로 jquery를 보고 겪게 되는 그 충격을 기억하고 있다면, 공감할 수 있을 것이다. 게다가 그것에 자바스크립트라는 언어를 잘 모를 때, 겉핥기 정도로 밖에 모를 때 이것은 큰 이슈일 것이다. 심지어는 jquery를 자바스크립트가 아닌 새로운 하나의 언어로 받아들이게 되는 지경이 될지도 모른다. (처음에 실제로 그렇게 느꼈었다. 이건 자바스크립트가 아닌것 같았다.) 게다가 API로 기존의 자바스크립트와는 상이하기 때문에 효과적으로 사용하기 위해서는 jquery API를 별도로 공부해야하기까지 한다.
- 뭐, 위의 단점은 충분히 극복이 가능한 단점이지만, jquery로 극복하지 못하는 아주 큰 단점이 하나 있다. 바로 퍼포먼스의 문제이다. 어플리케이션마다 다른 요구사항에 최적화를 하기 위해서는 직접 jquery를 파고 들어가야하는 경우도 있을지도 모른다. 물론 이러한 최적화는 라이브러리를 잘 구성해 놓은 jquery에서는 큰 고민이 아닐지도 모르지만, 그것보다도 더 큰 퍼포먼스의 문제는 32k나 되는 용량의 문제이다. gzip까지 했는데도 32k라는 용량을 왠만한 사이트 자바스크립트의 전체를 합친양 정도 될지도 모른다. 그런데 단순히 한두 기능을 사용하려고 jquery 전체를 가져오는 것은 너무나도 비효율적인 투자다.
- jquery의 $ selector는 document.querySelector와 document.querySelectorAll을 통해서도 충분히 구현이 가능하고, 멀티브라우져 ajax와 event 핸들러는 함수 몇가지만 이용하면 쉽게 구현이 가능하다. toggleClass와 removeClass 또는 regular expression을 이용하면 3-4줄이면 가능하다. 1k이면 충분히 해결하고도 남는 기능들만을 사용하기 위해 32배가 넘는 용량을 가져오는 것은 지양해야할 것이다. 또 다른 예로 document.getElementById 이런 구문 백번이면 될 간단한 자바스크립트를 $로 표현하기 위해 jquery를 가져오는 것은 배보다 배꼽이 커지는 실수인 것이다. 하지만 퍼포먼스가 그다지 필요하지 않은 웹페이지라면 이러한 단점들도 그다지 커지지는 않는다.


## 왜 jquery를 사용하는가?
- 그러면 다시 제목의 질문으로 돌아와서 왜 jquery를 사용하는가? 하는 질문을 하고 싶다. jquery를 쓰기 좋을 때는 멀티브라우져 지원, 이벤트+애니메이션+복잡한 CSS 변환+AJAX의 기능 모두를 다양하게 사용할 때, 그리고 위의 기능들을 구현할만한 시간적 여유가 없고 jquery에 대해서 이미 알고 있을 때. 그리고 무엇보다도 페이지가 퍼포먼스를 크게 요구하지 않고 사용자와의 인터렉션이 많지 않을 때 사용해야할 것이다.
- 그리고 반대로 자바스크립트에 대해 충분히 이해하고 jquery의 소스를 볼줄 안다면, jquery의 소스를 전부다 가져오는 것 보다는 일부 기능만 가져오거나 그 구현을 보고 자기만의 라이브러리를 만드는 것이 웹페이지의 퍼포먼스상 도움이 많이 될 것이다.
- 인터넷 속도가 1Gbps까지 올라가는 시대에 고작 32k를 가지고 퍼포먼스를 이야기하는 것도 웃긴 이야기지만, 이것은 http request가 하나 더 늘어난다는 점, 페이지의 구동이 느려진다는 점, 이후 최적화가 부족하다는 점이 완제품인 jquery를 가져오는 것의 단점이라고 말할 수 있다. 또한 중요한 것은 인터넷 속도 뿐만아니라 자바스크립트가 실행되는 브라우져 자체의 속도이기도 한데, 이것을 최적화하기 위해 jquery가 웹페이지의 목적에 맞게 튜닝이 되어있는지 뒤지는 것보다는 최적화된 자기의 라이브러리를 만드는 것이 훨씬 더 빠를 것이기 때문이다.
- : 하지만 분명한 것은 jquery는 최적화가 잘 된 좋은 라이브러리이며 멀티브라우져 지원에 대해 고민할 필요를 없애주는 너무나 고마운 라이브러리라는 것이지만, 페이지의 궁극적인 목적에 따라 그 사용 여부를 조심스럽게 결정을 해야한다는 것이다.

## jQuery 조심해야 할 점
- jQuery 라이브러리(jquery-1.11.2.min.js)를 HTML 문서 내에 포함하는 방법은 일반적으로 head 태그 내에 스타일 시트를 읽어들인 다음 자바스크립트를 읽어 들이는 순서를 따르며 이 때 다른 스크립트를 로드하기 전에 jQuery 스크립트를 우선하여 로드해야 한다.
- ⎼head 태그에 기술한 jQuery는 적용이 되지 않는데 그 이유는 브라우저 내의 HTML 인터프리터에 의해서 DOM 트리가 생성되기 전에 span 엘리먼트를 검색하려고 시도했기 때문이다. 
- addClass(className) 메서드는 jQueη 메서드로 style 태그 내부에 기술한 .className으로  정의된 클래스를 해당 엘리먼트에 추가하는 기능으로 메서드의 특징은 다음과 같다.


## ready
- $(document).ready(fns)
- 이 구문은 개발자로 하여금 어떤 함수 또는 코드가 호출 또는 실행되는 시점을 스케쥴링할 수 있게 해준다. 그 시점은 바로 문서객체모델이라고 하는 DOM (Document Object Model)이 모두 로딩되었을 때인데 이렇게 $(document).ready() 안에 위치한 코드를 DOM이 모두 준비된 이후에 실행되게끔 해준다. 
- jQuery가 나오기 오래 전부터 자바스크립트를 해 본 사람이라면 자바스크립트 window 객체의 onload  이벤트핸들러에 함수를 지정하는 것과 비슷한 역할을 하는 것이 아닐까 생각할 수 있는데 onload 이벤트 핸들러는 페이지를 구성하는 모든 리소스 즉, HTML 뿐만 아니라 이미지까지  불러온 시점에서 호출되는 데 반해 $(document).ready() 함수는 리소스가 아닌 DOM 객체가 생성되어 준비되는 시점에서 호출된다. 따라서 많은 이미지로 구성된 페이지의 경우라면 순서상 ready() 함수가 먼저 실행되고 그 다음에 onload 이벤트 핸들러가 실행된다. 즉, $(document).ready() 함수는 페이지를 구성하고 있는 모든 이미지가 브라우저상에 렌더링될 때까지 기다릴 필요없이 DOM이 준비되기만 하면 바로 실행된다. 

# 옵션
- 인자 없는 함수의 형태(  a()  )  는 옵션의 기능을 한다.

# 데이터
- 엑셀, CSV, XML 덩크, json은  
- a = {} 이렇게 구성되어 있음. 2. a = []

# jQuery 버전
- 1.xx 는 구형 브라우저 버전을 대부분 지원하며 가장 안정적인 release 이다. 
주로 공공기관 사이트나 국가 관련 사이트 등 구형 브라우저를 사용하는 사용자가 많을 것으로 예측되는 사이트에 사용된다.
- ※ 이슈) 1.9 이전의 버전과 그 후의 버전 간의 호환성 문제가 발생하여 최신버전의 jQuery를 필요로 하는 플러그인 이나 스크립트를 삽입할 때 제대로 작동하지 않을 수 있다. 따라서 jQuery Migrate를 삽입하여 문제를 해결한다.

## 2.xx 버전
- 2.xx 부터는 익스의 6~8 버전을 지원하지 않는 등 간소화? 하여 1.xx 보다 용량이 적다. 익스 6~8 버전 보다 높은 버전을 사용할것으로 예상되는 사용자만 접속한다는 가정하에 이 버전들을 쓰는 것이 좋다.

## migrate
- jQuery는 1.9 버전 이전에 작성된 코드와 이후에 작성된 코드간의 호환성에 문제가 발생할 수 있습니다. 구형 jQuery로 작성된 페이지에 최신버전의 jQuery를 필요로하는 플러그인이나 기타 스크립트를 삽입하다보면 발생하는 문제인데 이를 해결하는 방법중에 하나로 jQuery Migrate를 사용할 수 있습니다.
- 우리는 이전 버전의 jQuery에서 이전을 단순화하기 위해 jQuery Migrate 플러그인 을 만들었습니다. 플러그인은 더 이상 사용되지 않는 기능 및 동작을 복원하여 최신 버전의 jQuery에서 이전 코드가 계속 제대로 실행되도록합니다. 압축되지 않은 개발 버전을 사용하여 호환성 문제를 진단하면 문제를 확인하고 수정하는 데 사용할 수있는 경고가 콘솔에 생성됩니다. 압축 된 제품 버전을 사용하여 콘솔 경고를 생성하지 않고 호환성 문제를 간단하게 해결할 수 있습니다.

## min.js
- jquery.js 개발자 버전: 소스를 분석할수 있도록 공백을 포함하여 구성
- jquery.min.js: 공백없이 구성
- jquery의 경우 디버깅이 가능하도록 코드가 정렬되어있다
- 사이즈와 속도는 당연히 jquery.min.js가 좋다; 배포용
- jquery-1.x.x.min.js는 변수 등 내용들이 간소화되어 있고, 일렬로 길게 늘어서 있는데, 이는 페이지를 로딩할 때마다 jquery-1.x.x.min.js를 불러오는데 크기를 최소화하여 속도를 내기 위함
-  단순 개행, 공백의 제거뿐아니라 변수이름도 a, b, c와 같이 줄여서 전반적으로 임포트해서 쓰기에 좋은 형태( 불필요한 용량 제거 )로 가공을 해줍니다. 


# jQuery 순서
- script type = "text/javascript" src = "../JS/jquery-1.11.2.js"
		- 먼저 수행되어야 함.
- script type = "text/javascript" src = "../JS/jquery-migrate-1.11.2.js"

# 객체에 함수 담기
- 매개변수가 있을 때는 var t = function s(a, b) {} 이렇게 밖에 선언 못함;
- 매개변수가 없을 때만 var t = s(); 이렇게 선언 가능


# 콜백 함수
1. 함수 이름으로 호출하지 않는다.
2. 함수를 매개변수처럼 사용한다.
3. 매개함수는 익명함수가 되어야 한다.
- $(function() {
- $("#hello").html("안녕하세요");	
- } );


# jQuery 방식
 맵 방식
- 내에 속성과 값을 콜론(:)를 구분자로 쌍으로 기술하여 속성에 값을 설정하는 방식으로 여러 개의 속성에 대해서 값을 설정할 경우에는 콤마(,)로 속성과 값을 여러 번 반복해서 기술한다.
- $('div span:first-child, div span:last-child').css('text-decoration':'underline','color':'red','font-size':'20pt');

2. 체인 방식
- 메서드 호출이 완료된 후 메서드에 마침표(.)를 찍어 연속적으로 메서드를 호출하는 방식으로 체인 방 식을 사용하면 한 문장으로 여러 메서드를 호출할 수 있다.
- $('div span:first-child, div span:last-child').css('text-decoration','underline').css('color','red').css('font-size','20pt');

# 파싱
## 자식
## 자손
- 자식: div > em; 가장 겉에 있는 1개의 자식만
- 자손: div em; 같은 위치에 있는 자식 포함해서 자손들도


## 형제
- +, 한개만 검색 가능
- -; 형제 다 찾기


## 아이디로 찾기
- $('span[id="simpletext1"]').addClass('redtext');


# keyup
- 왜 keypress 가 아닌 keyup 이벤트를 사용하는 것일까요? 영문을 입력하면 keypress 이벤트가 사용하기 좋지만 한글은 keypress 이벤트를 지원하지 않습니다. 따라서 keypress 이벤트는 배제해야 합니다. 그리고 keydown 이벤트가 아니가 keyup 이벤트를 사용해야 합니다. 이는 키보드 이벤트가 어떠한 순서로 발생하는지를 안다면 이해하기 수월할 것입니다.

- 키보드 이벤트는 다음과 같은 순서로 진행됩니다.
1. 사용자가 키보드를 누른다.
2. keydown 이벤트가 발생한다.
3. 글자가 입력된다.
4. keypress 이벤트가 발생한다.
5. 사용자가 키보드에서 손을 뗀다.
6. keyup 이벤트가 발생한다.
- 따라서 keydown 이벤트가 발생한 순간에는 글자가 입력돼 있지 않습니다. 여기서는 입력한 글자 수를 표시해야 하므로 keyup 이벤트를 사용했습니다.


# 슬라이싱
