# 원격 네트워크
- 브라우저를 이용하지 않은 연동
- 브라우저를 이용한 연동은 ‘웹’이라는 말이 들어간다.

# 브라우저
* 익스플로어, 엣지, 파이어폭스, 크롬, 오페라, 사파리

## 시크릿 모드
* 입력정보를 보관하지 않음
* 캐시(임시파일)를 보관하지 않음
* 쿠키를 보관하지 않음

# 웹 서버 (Web Server
 * 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(.html, .png, .css등)를 제공하는 서버
 * 클라이언트에서 요청이 올 때 가장 앞에서 요청에 대한 처리를 한다.
 * 클라이언트의 요청을 기다리고 요청에 대한 데이터를 만들어서 응답하는 역할 (정적 데이터)
 
## CASE
 * 정적 컨텐츠를 요청(request)했나?
 * 1. 정적 컨텐츠구나! 내가 제공해줄게 => .html, .png 등 응답(response)
 * 2. 정적 컨텐츠가 아니구나.. 웹서버에서 간단히 처리 못하겠군. WAS에게 처리를 부탁해야겠다! => 결국 WAS가 처리해준 컨텐츠를 받은 웹서버는 응답(response)을 해줌
 * 대표 : Apache, nginx
 
 
# WAS (Web Application Server)
 * 동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버 (DB조회, 로직처리가 요구되는 컨텐츠)
 * JSP,Servlet 구동 환경 제공
 * 컨테이너, 웹컨테이너, 서블릿 컨테이너라고도 부름
* JSP, servlet을 실행시킬 수 있는 소프트웨어 = 컨테이너
 
 
## 동작 프로세스
1. 웹서버로부터 요청이 오면 컨테이너가 받아서 처리
2. 컨테이너는 web.xml을 참조하여 해당 서블릿에 대한 쓰레드 생성하고 httpServletRequest와 httpServletResponse 객체를 생성하여 전달한다.
3. 컨테이너는 서블릿을 호출한다.
4. 호출된 서블릿의 작업을 담당하게 된 쓰레드(2번에서 만든 쓰레드)는 doPost()또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response객체에 담아 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response객체를 HTTPResponse형태로 바꿔 웹서버에 전달하고 생성되었던 쓰레드를 종료하고 httpServletRequest, httpServletResponse 객체를 소멸시킨다.
대표 : Tomcat, Jeus, JBoss
 
## Web Server가 필요한 이유?
 * 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
 * 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
 * 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
 * Web Server를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
 * 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
## WAS가 필요한 이유?
 * 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다.
 * 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
 * 이때, Web Server만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.
 * 하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
 * 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
 
## WAS와 웹 서버 차이
 * - 클라이언트 - WAS(웹서버 - 웹컨테이너: JSP, Servlet) - 데이터 베이
 * - 동적 컨텐츠 처리를 수행 가능한가 아닌가.
 * WAS는 정적,동적 처리 둘다 가능하지만 정적처리를 WAS가 하게되면 부하가 많이 걸려서 좋지 않음
 *  
 * * 톰캣(WAS)에는 아파치(웹서버)의 기능(웹서비스데몬, Httpd)를 포함하고 있다.
 * - 일반적인 WAS, Web Server 구조가 아닌 걸로 알고 있음.
 *  
 * * WAS, Web Server를 따로 두고 쓰는 이유가 성능때문이라고 하는 건 잘못되었다.
 * 톰캣5.5 이상부터는 httpd의 native모듈을 사용해서 정적파일을 처리하는 기능을 제공하는데 이것이 순수 아파치 Httpd만 사용하는 것과 비교해서 성능이 전혀 떨어지지 않기 때문이다.
 * 그럼에도 톰캣앞에 아파치를 두는 이유는 하나의 서버에서 php애플리케이션과 java애플리케이션을 함께 사용하거나, httpd 서버를 간단한 로드밸런싱을 위해서 사용해야 할 때 필요하기 때문.


## 로드밸런싱(Loadbalancing)
 * 로드 밸런싱이란 부하 분산을 위해서 가상(virtual) IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.
 * 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도 저하 등을 고려하여 적절히 분산처리하여 해결해 주는 서비스이다. 로드밸런싱을 해주는 소프트웨어 혹은 하드웨어 장비를 로드밸런서라고 한다. 로드밸런서의 주 목적은 동시에 오는 수 많은 커넥션을 처리하고 해당 커넥션이 요청 노드 중의 하나로 전달될 수 있게 하는 것이다. 그리고 단지 노드를 추가하는 것만으로 서비스가 확장성을 가질 수 있도록 한다. 오픈 소스 로드 밸런서 중 많이 사용되고 있는 것은 HAProxy 이다.

## 로드 밸런싱에서 사용하는 주요 기술은 다음과 같다.
 * NAT(Network Address Translation) : private IP를 public IP로 바꾸는데 사용하는 통신망의 주소변조기
 * DSR(Dynamic Source Routing protocol) : 로드밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념
 * Tunneling : 인터넷 상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념으로, 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제할 수 있다.
 * 
 * 로드밸런서를 사용할 때 어려운 문제 중 하나는 세션 데이터를 관리하는 것이다. 서버에 액세스 할 때마다 다른 세션을 사용한다면 특정 사용자의 정보를 일관성있게 유지할 수 없게 된다. 이러한 문제를 해결하기 위해 세션을 고정(session sticky)한다. 이 방법으로 특정 사용자의 요청이 전달될 노드를 고정시킬 수 있다. 하지만 이 방법도 문제가 있다. 고정된 세션의 노드에 장애가 발생하면 고정한 의미가 없어진다. 장애가 발생하여 비활성화된 노드에 대한 고려가 필요하다.

## 대용량 서비스를 운영하려면 부하 분산은 필수이다.
 * 대용량 트래픽을 장애없이 처리하려면 여러 대의 서버에 적절히 트래픽을 분배해야 한다.
 * 단지 몇 개의 노드만 있다면 라운드 로빈 DNS와 같은 방식이 합리적이다. 로드 밸런서 자체의 비용이 높고 불필요한 복잡함을 증가시킬 수 있기 때문이다.  DNS에서는 하나의 도메인 이름을 라운드 로빈 방식으로 여러 개의 IP 주소를 변환한다면 이것만으로 쉽게 부하 분산이 가능하다. 하지만 여기에 두 가지 단점이 존재한다. 첫째, 대부분의 클라이언트에서는 DNS 서버의 부하를 줄이고 성능을 향상시키기 위해 일정 시간 동안 캐싱하기 때문에 부하 분산이 균등하게 발생하지 않는다. 둘째, 특정 서버에 장애가 발생하더라도 장애 여부가 감지되지 않아 서비스에서 해당 서버를 제거할 수 없다.
 * 그렇기 때문에 대규모 시스템에는 다양한 알고리즘과 스케줄링이 사용되고 있다 이러한 알고리즘들은 네트워크 트래픽과 분산 요청을 제어하면서 자동 절체나 이상 노드 제거와 같은 신뢰성 관련한 기능을 제공한다.

## 클러스팅
 * - 여러 개의 컴퓨터를 연결한 병렬 시스템으로 마치 하나의 컴퓨터처럼 사용하는 것을 클러스터라고 한다. 클러스터링 환경에서는 특정 장비에 문제가 생기거나 특정 장비에서 실행중인 애플리케이션에 문제가 발생하더라도 전체 서비스에 영향을 미치지 않도록 제어가 가능하다.
 * 클러스터링은 기본적으로 Virtual IP(가상 IP)를 기반으로 구현된다. 서비스를 제공하는 실제 장비는 물리적인 IP를 갖고, 데이터의 처리는 Virtual IP를 통해 이루어진다. 내부 시스템은 철저하게 가려져 있는 것이 원칙이다.
 * 
 * 확장 면에서 비교
 * 둘 다 scale-out 방식, 즉 수평 방향으로 노드를 추가해서 성능을 업그레이드 하는 방법이다. 저렴한 노드를 여러개 묶어서 성능을 업그레이드 하며, scale-up 방식에 비해 비용을 줄일 수 있으며 유연한 구성이 가능하다. 로드밸런싱은 하나의 서비스를 하나 이상의 노드가 처리하는 식으로 작동한다.

### 어떤 점이 좋은가?
 * 1 . 저렴한 비용으로 다수의 서버를 증설하여 비용절감의 효과를 볼 수 있다.
 * 2. 1대의 서버 장애가 발생하여도 서비스 중단없이 다른 서버로 적절히 자동 분배되어 서비스가 계속 운용가능하다.
 * 3. 서버를 확장할 때에도 서비스 중단없이 서버 증설이 가능하다.


# 대칭키 기법
- https://soul0.tistory.com/372 
- 하나의 비밀키를 양쪽(client - server)가 모두 같이 사용하는 것이 문제
-     (암호화와 복호화에 같은 암호 키를 쓰는 알고리즘)
- 해커로부터 안전할 수 없다
- 알고리즘 방식으로 DES, 3-DES, AES, SEED, ARIA, MASK 등이 있다.

# 비대칭키
- 비대칭키 는 암/복호화 할때의 Key 값이 다르다 대표적으로 RSA 라는 암호화가 있으며
 암호화 할때의 키를 공개키(Public Key) 복호화 할때의 키를 ​개인키(Private Key) 라고 한다.
- 즉,  암호화 할때의 Key 와 복호화 할때의 Key 값이 같으면 “대칭키”  ​암호화 할때의 Key 와 복호화 할때의 Key 값이 다르면 “비대칭키” 라고 한다.
 




# 공개키 기법 (≒비대칭키 기법, ≒비밀키 암호화, ≒비대칭형 암호 알고리즘)
- 보내야 하는 데이터를 송신자가 수신자의 공개키로 암호화를 걸어 놓고 데이터를 받은 수신자가 자신의 개인키(=비밀키)로 복호화를 하는 방법
- 개인 키는 한쪽에만 속해 있기 때문에 개인 키가 사용된 것으로 나타난 모든 경우 해당 키의 소유자만이 그것을 사용했다고 결론지을 수 있다.
- 한 쌍(공개키 + 개인키)의 키 조합이 필요.
- 암호화에 사용된 키와 복호화에 사 용된는 키가 다름에도 수학적 원리에 의해 해독이 가능하도록 한 방식
- 알고리즘 방식으로 RSA, DSA 등이 있다.
- 공개키 기법은 시간이 오래 걸리는 단점을 극복하고자 공개키 암호화는 대칭키를 보내는 용도로만 사용
- 개인키만 잘 보관하면 완벽한 암호화 기법

## 공개키 과정
- 공개키로 암호화하면 개이키로만 풀 수 있다.
- 각 키는 매우 큰 숫자이므로 한 개의 키로 다른 키를 알아내기 어렵다.
상대방에게 내 공개키를 알려준다.
2. 상대방은 나에게 자신의 공개키를 알려준다.
3. 상대방은 나의 공개키를 이용해 암호화된 문서를 나에게 보낸다.
4. 나는 내 개인키로 이 암호문을 해독한다.
5. 내 대답은 상대방의 공개키로 암호화해서 보낸다.
6. 상대방은 자신의 개인키로 내 글을 해독한다. 

# 공개키 기법으로 암호화한 대칭키 기법 내용
- 표준 보안 방식 SSL 이라고 부름.
- Secure Socket Layer
- 접속한 사이트가 신뢰할 수 있는 지 확인하기 위한 인증서가 출현
- 대칭키 기법 + 공개키 기법 = 장점만을 살린 방법
- 여기서 사용되는 대칭키는 매번 랜덤으로 선택되는데, 이렇게되면 만약 대칭키가 누출되어도 다음번에는 다른 키가 사용되기 때문에 안전
# 인증서란? ( 사이트와 인증기관의 구분을 명확히 생각하도록 하자. )
- 모든 개인키는 오직 자기 자신만 소유한다. 즉, 통신을 위한 공개키를 대충에게 공개해야 한다.
- 공인 인증 기관 출현
- 공인 인증 기관은 인증서를 발행해 주지만, 주 목적은 요청한 사이트에게 해당하는 인증기관 개인키와 인증기관 공개키 쌍을 만든다. 사이트에는 인증기관 개인키로 암호화한 인증서(사이트 공개키 + 사이트정보)를 발행 / 웹 브라우저에는 인증기관 공개키를 발행하여 암복호화 할 수 있도록 구성
- 사이트 개인키(Private Key) 를 보증(SSL 통신)하기 위해서 그 쌍이 되는 사이트 공개키(Public Key)가 바로 인증서에 들어있음.
- 또한 '공인 인증 기관의 전자 서명'이 바로 인증서에 들어 있음.
- 즉, 인증서는 사이트 공개키 + 공인 인증 기관의 전자 서명
- 인증서는 공개된 위치에 저장해서 요청하는 사람에게 내려보내 줄 수 있는 시스템이 갖춰져 있다. (보통 공인 인증 기관의 LDAP 에 저장)
- 이를 PKI(Public key infrastructure) 라고 한다.

## 인증서의 Root CA
- SSL의 기본 구조는 당신이 인증서를 서명한 사람을 신뢰한다면, 서명된 인증서도 신뢰할 수 있다는 것
- 이것은 마치 트리(Tree)와 같은 구조를 이루면서 인증서끼리 서명하게 된다.
- 인증서를 발행한 기관을 Root Certification Authority(Root CA)라고 부르며, 널리 알려진 인증 기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 웹브라우저에 기본적으로 설치되어 있다.
- Root CA의 인증서는 누가 서명을 했을까? 모든 Root CA 인증서는 자체 서명(Self Signed)되어 있다.
- 여기서 서명이란 신뢰할 수 있다고 서명하는 것을 뜻함.

## 정리
 * Q: SSL 이란?
 * A: 데이터를 암호화 해서 주고 받는 것
 * 
 * Q: SSL은 어떤 키를 사용?
 * A: 실제 암호문을 주고받는 것은 양쪽이 같은 대칭키를 사용 (대칭키를 전송하기 위한 공개키를 사용과 햇갈리지 말자)
 * 
 * Q: 대칭키를 전달할 때 위험을 피하는 방법은?
 * A: 사이트의 공개키로 암호화해서 데이터를 전송
 * 
 * Q: 인증기관의 역할은?
 * A: 사이트의 공개키가 신뢰할 수 있는지 보증하는 역할
 * A: 인증기관의 개인키로 사이트의 공개키를 전자서명과 함께 암호화 = 인증서 (이는 인증기관의 공개키로만 풀 수 있기 때문에 인증기관에서 발급한 인증서가 신뢰할 수 있다고 판단할 수 있다.)
 * 
 * Q: 인증서란?
 * A: 사이트의 공개키와 사이트 정보(전자서명 등)을 인증기관 개인키로 암호화한 파일에 불과하다.
 
# 쿠키와 세션의 차이

# 쿠키
- 쿠키란 서버측에서 클라이언트측에 상태 정보를 저장하고 추출할 수 있는 메커니즘
- 클라이언트의 매 요청마다 웹 브라우저로부터 서버에게 전송되는 정보패킷의 일종
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 하드 디스크에 저장하였다가 필요 시 정보를 참조하거나 재사용할 수 있음.
 
## 쿠키의 원리
- 클라이언트가 브라우저를 통하여 웹페이지 접속(Web Server) -> 클라이언트가 요청한 웹 페이지(HTTP)를 전송하면서 쿠키설정(클라이언트의 상태정보 하드디스크 저장) -> 클라이언트 재 방문시 웹페이지 요청과 함께 쿠키값도 같이 전송

## 예제
-  방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
- 팝업에서 “오늘 이 창을 다시 보지 않음” 체크

## 쿠키의 제약 조건
- 클라이언트에 총 300개까지 쿠키를 저장할 수 있다
- - 하나의 도메인 당 20개의 값만을 가질 수 있다
- 하나의 쿠키 값은 4096Byte까지 저장 가능하다
- [주의]하나의 도메인에서 설정한 쿠키값이 20개를 초과하면 가장 적게 사용된 쿠키부터 지워짐. 또한 쿠키는 기존에 설정한 값이 있는 곳에 값을 저장하거나 배열형태의 쿠키에 단일 값을 저장하려고 할 때 아무런 경고 없이 덮어쓰기 때문에 주의를 해야 한다.

# 세션이란?
- 세션이란 클라이언트와 웹서버 간에 네트워크 연결이 지속적으로 유지되고 있는 상태를 말함
- HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속시마다 새로운 네트워크 연결이 이루어진다.
- -클라이언트가 웹서버에 요청하여 처음 접속하면 JSP(혹은ASP)엔진은 요청한 클라이언트에 대하여 유일한 ID를 부여하게 되는데, 이 ID를 세션이라 부른다.
- 이 ID는 쿠키를 사용하여 유지되며, 이 쿠키의 이름이 JSESSIONID 입니다. 서버는 JSESSIONID를 웹 브라우저에 전달하고, 클라이언트는 새로운 접속시 쿠키를 통해서 세션 ID값을 서버에 전달한다
- -세션 ID를 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 구분할 수 있는 유일한 수단이 된다
 
# 세션의 장점
- 각각의 클라이언트마다 고유의 ID 부여
- 세션 객체마다 저장해 둔 데이터를 이용하여 서로 다른 클라이언트의 요구에 맞게 서비스 제공
- 클라이언트 자신만의 고유한 페이지를 열어놓아서 생길 수 있는 보안상의 문제 해결 용이
 
## 쿠키와 세션의 차이점
- 쿠키(cookie)와 세션(session)은 기능상 비슷한 역할을 하고, 동작원리도 비슷하다. 왜냐하면, 일반적인 세션은 쿠키를 바탕으로 동작하기 때문이다. 그러나 가장 중요한 차이점은 저장되는 곳이 다르다는 것이다. 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다. 쿠키의 경우에는 서버의 자원을 전혀 사용하지 않지만, 세션의 경우에는 서버에 저장되기 때문에 서버의 자원을 사용할 수가 있다.쿠키와 세션의 만료 되는 기간도 다르다.
