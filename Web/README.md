



# 웹 서버 언어
## CGI(Common Gateway Interface)
- ⎼ 는 의 약어로 응용 프로그램과 웹 CGI Common Gateway Interface 서버 사이의 정보를 주고받는 방식이나 규약들을 정해 놓은 것을 말한다.
- ⎼크게 보면 JSP나 PHP, Perl, ASP 등이 모두 CGI의 범주에 들어간다고 볼 수 있는데 CGI가 개발된 이유는 단순한 HTML 방식으로는 동적인 웹 페이지를 만들기 어렵기 때문에 서버 측에서 동적인 데이터를 처리해 클라이언트에
HTML 문서로 전송해 줄 수 있는 응용 프로그램의 필요성 때문이다.
⎼초기 CGI 프로그래밍에서 사용된 Perl 웹 프로그램의 경우 파일 DB인 텍스트 파일이나 MDB 등의 사용은 편리하지만 데이터베이스(DBMS)와의 연동이 매우 불편하고 쉽게 익히기 어려운 단점이 있다.

## ASP
- Active Server Page의 약어로 동적인 웹 페이지의 구현을 위해 Visual Basic 언어를 기반으로 만들어진 VBScript라는 스크립트 언어를 사용해서 구성된 웹 프로그래밍 기술이다.
- ⎼스크립트 언어(Script Language)는 컴파일이 필요 없이 해석기(인터프리터)에 의해 즉시 실행될 수 있는 프로그램 언어를 스크립트 언어로 대표적으로는 브라우저에 의해 해석되어 실행되는 JavaScript 등이 있다.
- ⎼ASP는 Visual Basic을 기반으로 하여 만들어 졌기 때문에 쉬운 문법을 가지고 있어서 빠르고 쉽게 개발할 수 있고 Active-X 및 DDL 컴포넌트를 사용하여 어느 정도의 확장성도 갖추었다고 할 수 있지만 웹 서버로 오직 Windows NT 기반의 IIS (Internet Inforrnation Server)만을 사용할 수 있기 때문에 플랫폼에 비독립적이라는
큰 단점을 가지고 있다.
- ⎼ASP.NET이 ASP와 유사하지만 실제로는 아주 다르고 ASP.NET은 전적으로 객체 기반이며 모든 객체는 그 자신의 프로퍼티, 메서드 그리고 이벤트들을 가질 수 있다.
- ⎼웹 어플리케이션들을 개발할 때 객체 지향 접근을 제공하므로 ASP.NET은 모든 개발자에게 웹 어플리케이션 개발을 더욱 쉽고 다양하게 그리고 유용하게 개발할 수 있게 해준다.
- ⎼Java 기반의 JSP에 비해 시스템 자원의 효율성과 확장성이 떨어진다는 단점이 있다.


## PHP
- PHP는 ASP와 유사한 스크립트 기반의 언어이지만 ASP와는 다르게 C를 기반으로 만들어진 언어이기 때문에 빠른 속도를 가지고 있다.
- ⎼다양한 플랫폼에서 사용이 가능하며 개인적인 용도로 개발된 언어이기 때문에 100% 무료로 사용할 수 있다는 장점이 있지만 서버 측의 자원 인프라가 매우 부족하며 확장성이 떨어지고 기업형의 복잡한 시스템 구조에 적용하기가 힘들 뿐만 아니라 보안상의 약점을 가지고 있다는 단점이 있다.







# 브라우저; 톰켓 이용 <>http; 컨트롤러(http 파라미터) <> 자바(모델, 서비스, DAO) <> DB 
- 컨트롤러가 자바면 JSP, C#이면 ASP, PHP면 PHP
- 자바에서 중간 연결체: 클래스 -> 웹과 연동을 하는 클래스: 서블릿이라고 부름
- jsp도 서블릿 역할; 컨트롤러 역할도 함# 리눅스
* 무료고 오픈소스라서 다양한 소프트웨어가 돌아감
* 콘솔에서 소프트웨어 설치 가능
* 코드는 오픈소스 무료이고 깃허브에서 코드 볼수 있고 파일을 커스터마이징 가능
* 아마존 서버는 리눅스 서버에서 돌아감



## 쿠키의 룰
1. 같은 도메인에서만 한정
* 자동적으로 보냄
* 자동적으로 세팅
* 페이스북이 만든 쿠키는 페이스북안에서만 보내질 수 있지만 페이스북의 좋아요 버튼이 들어간 링크에의 쿠키가 페북으로 들어감
- 보내주는 방법: 1. 새로운 request 생성(redirect)  2. 기존의 request 유지(forward)
- 포워드 방식을 자주 사용











# 서버 페이지
- form -> 서버 페이지(자바는 서블릿; jsp) -> 데이터베이스
- 1. sun에서 개발한 서블릿: JSP 2. 개발자가 개발한 서블릿
- 입력폼(JSP)  -> 컨트롤러(커스텀 서블릿; 개발자가 개발)  ->  자바(모델) -> DB -> 모델 -> 컨트롤러(커스텀 서블릿; 개발자가 개발) -> 출력폼(JSP)
- 컨트롤러 역할까지 했던 예전과 달리 지금 JSP는 뷰 역할만 한다.
- 입력폼 -> 웹 서버 -> 웹 어플리케이션 서버 -> 데이터 베이스 -> 웹 어플리케이션 서버 -> 웹서버 -> 출력폼
- 톰켓 8부터는 별도의 설정하지 않아도 인코딩이 된다.	

## 입력폼
- 폼 제어: 자바 스크립트(jQuery가 역할)

## 커스텀 서블릿
- 커스텀 서블릿에서 jsp 출력폼으로 보내거나 모델로 보낼 때 1. 포워드(주소 변경 안함) 2. 리다이렉트 방식 사용(주소지 변경)
- 페이지 수마다 코드가 들어가야 하기 때문에 페이지 수만큼 코드가 길어진다.

## 데이터 유지권
- # 세션: 서버에 저장; 로그인에서 아이디 유지권에 사용
- # 쿠키: 클라이언트에서 유지
- 부하가 크기 때문에 특별한 경우가 아니면 사용하지 않는다.   

# 톰켓
- 톰켓 8부터는 별도의 설정하지 않아도 인코딩이 된다.
- 톰켓 7버전은 get방식일 때 별도의 설정을 해주어야 한다. 실무에서는 아직 7버전을 많이 사용한다.
- ⎼POST 방식은 문제가 없지만 GET 방식으로 전송된 파라미터에 대해서는 request.setCharacterEncoding( ) 메서드로 지정한 캐릭터 셋이 적용되지 않는다.
- ⎼Server 디렉토리의 server.xml 파일을 XML Editor로 열고 Source를 선택한 후 Connetctor 요소에 추가 할 코드를 추가하고 파일을 저장한 후 서버를 반드시 재 시작한다.
- ⎼추가 할 요소는 URIEncoding= “UTF-8” 와 useBodyEncodingForURI= “true” 로 두 요소를 모두 추가해주는 것이 인코딩에 효율적이므로 권장한다.
- <Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443" URIEncoding= “UTF-8” useBodyEncodingForURI= “true” />







# 확장자
- 상속의 개념
- 파일 확장자(영어: filename extension)는 컴퓨터 파일의 이름에서 파일의 종류와 그 역할을 표시하기 위해 사용하는 부분이다.
- 많은 운영 체제들은 파일 이름에서 마지막 점(.) 뒤에 나타나는 부분을 확장자로 인식한다. 

# MIME
- ⎼MIME은 Multipurpose Internet Mail Extensions의 약자로 일종의 인코딩 방식으로 이메일과 함께 동봉할 첨부 파일(attachment file)을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었기 때문에 이름이 Internet Mail Extension이며 이제는 웹을 통해서 여러 형태의 파일을 전달하는 데 두루 쓰이고 있다.
- ⎼MIME 타입은 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘으로 각 문서와 함께 올바른 MIME 타입을 전송하도록 서버가 정확히 설정하는 것이 중요하며 브라라우저들은 리소스를 내려 받았을 때 해야 할기본 동작이 무엇인지를 결정하기 위해 대게 MIME 타입을 사용한다.

# JSP
- JSP 라이브러리: C:\apache-8.5.39\apache-tomcat-8.5.39\lib
- JSP 클래스 저장:  -    
- - C:\workspace\jsptest\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\begin\org\apache\jsp\begin
- jsp가 만들어지면 자동으로 서블릿이 만들어진다. 
- 또 jsp 만들면 web.xml에 sevlet 매핑에 jsp가 있다. jsp도 사실상 서블릿이다.
	⎼JSP 에서는 서블릿과 달리 위의 코딩을 추가해 주어야 한다.
	⎼out 객체를 지우고 out 객체를 새로 만들어서 추가한다.
	⎼jsp 에서 다운로드를 위해 OutputStream 추상 클래스를 받아서 처리할 때 JSP 에서 servlet 으로 변환될 때 내부적으로 out 객체가 생성되므로 response.getOutputStream( ) 메서드 호출 시 생기는 out 객체와 jsp 에서 servlet 으로 변환될 때 생성되는 out 객체와 충돌이 일어나서 예외처리가 발생하므로 추가해 준다.
	⎼ServletOutputStream 추상 클래스를 만들면서 out 객체를 재정의 하려고 시도하기 때문에 기본객체로 있는 out 객체에서는 예외가 발생하지만 동작은 잘되지만 이벤트가 서버에 쌓이므로 추가 해주는 것을 권장한다.

## JSP 특징
1. 강력한 이식성
- 이식성은 JSP의 가장 큰 장점이다.
- JVM을 이용한 자바 언어의 특성상 어떤 운영체제에서도 어떤 JSP 컨테이너에서도 사용이 가능하므로 한번 작성한 코드를 별다른 수정 없이 다른 플랫폼으로 얼마든지 이식이 가능하다.

2. 서버 자원의 효율적인 사용
- 사용자가 웹 서버에 요청을 보내면 서버는 각 요청 당 하나의 프로세스를 생성하고 해당 프로세스를 통해 결과를 생산하면 프로세스가 종료되는 구조를 가지고 있었기 때문에 수많은 사용자가 접속할 경우 프로세스 생성에 너무 많은 서버 자원을 필요로 하게 되는데 이러한 문제점을 JSP는 Thread(스레드) 기반의 아키텍처를 사용하여 개선시켰다.
- 스레드 기반의 아키텍처에서는 최초의 요청이 웹 서버에 들어오면 서버는 그 요청에 맞는 JSP 페이지에 대한 서블릿 인스턴스를 단 한 번 생성하고 이후 같은 페이지를 요청하는 사용자가 있을 경우 이미 생성되어 있는 인스턴스에 스레드 단위로 요청을 전송하여 처리하기 때문에 서버 자원의 효율적인 사용이 가능하다.

3. JSTL과 커스텀 태그 등을 이용한 개발 용이성
- .JSP 개발에 있어서 가장 큰 문제점은 JSP 문서 내에 자바 형식의 문법과 태그 형식의 HTML 문법이 같은 페이지 내에 존재하기 때문에 JSP 문서의 코딩 양이 많아질수록 코드의 가독성이 떨어진다는 점이다.
- .JSP 2.0 이후로 JSTL(JSP Standard Tag Library)과 커스텀 태그에 대한 지원이 강화됨으로써 자바 형식의 문법을 태그 라이브러리 파일로 만들어서 JSP를 태그만으로 구성힐 수 있게 만드는 기능이 강력해져 요소들을 태그 형식으로 깔끔하게 정리함으로써 전제적인 JSP 코드의 길이를 대폭 줄일 수 있게 되었으며 코드의 가독성 및 유지 보수의 효율이 대폭 향상되었다.
4. 쓰레드를 이용한 분산처리:  많은 작업 요청을 효율적으로 처리 가능하여 처리속도가 빠르다.
5..자바언어를 기반으로 제작
- 자바언오를 기반으로 제작되었기 때문에 객체지향적인  특징과 플랫폼에 독립적인 장점을 얻을수 있다.
 6. .프레임워크와 완벽한 연동
- 대규모 어플리케이션을 구현할 때 사용되는 SPRING과 같은 프레임워크와 완벽하게 연동된다.


## 인코딩
get방식: 1. <%@ page import="java.net.URLEncoder" %>
- user = URLEncoder.encode(user,"UTF-8");
- 파라미터가 있으니까 redirect, 포워드 사용
2. Post 방식 1. 포워드(객체 그대로 사용)하는 것 사용

## 포워드
- 포워드를 쓰면 객체가 보내기 전의 객체이기 때문에 css나 자바 스크립트 모두 실행되지 않는다.
.- forward(url) 메서드는 현재 페이지의 요청과 응답에 관한 제어권을 URL 로 지정된 주소로 영구적 넘긴다.
- forward(url) 메서드는 포워드 된 페이지의 요청처리가 종료되면 응답도 종료된다.
- 포워딩 방식은 요청과 응답에 대한 제어권을 다른 페이지로 넘기더라도 브라우저에 표시되는 주소가 유지되는 것으로 브라우저에 표시되는 주소가 바뀌는 방식을 리다이렉트 방식과 다르다.
- 포워딩 방식은 현재 페이지의 요청과 응답의 정보에 대한 제어권만이 다른 페이지로 넘어가므로 요청 정보와 응답 정보가 유지되는 장점이 있기 때문에 모델 2 기반의 웹 프로그래밍에서 뷰 페이지에서 요청 영역에 공유되어 있는 속성값을 이용하여 페이지를 구성하는 데 유리하다.
- Forward의 경우는 url1에서 forwar해서 url2로 전달하게 되면 제어권을 다시 url1으로 전달받지 못합니다. 따라서 url1에서 처리한 결과 화면이 전혀 보이지 않고 최종 클라이언트 브라우저에는 url2에서 처리한 화면만이 보여지게 됩니다.

### forward redirect 차이
### forward
- Web Container 차원에서의 페이지 이동, 실제로 웹 브라우저는 다른 페이지로 이동 했는지 알 수 없다.(첫 번째 사례의 경우, 고객은 상담원이 어떤 상담원에게 물어봤는지 알 수 없다.)
- 웹 브라우저는 최초 호출한 URL만 표시되고, 이동한 페이지의 URL정보는 볼 수 없다.(첫 번째 사례의 경우, 고객은 123번으로만 전화 했기 때문이다.)
- 현재 실행중인 페이지와 forward에 의해 호출될 페이지는 request , response 객체를 공유한다.(고객이 요청한 문의 사항은 전화를 끊을 때까지 유효하다.
- forward방식은 다음으로 이동할 URL로 요청정보를 그대로 전달한다. 말 그대로 forward(건네주기) 하는 것이다. 그렇기 때문에 사용자가 최초로 요청한 정보는 다음 URL 에서도 유효하다



## include
- include(url) 메서드는 현재 페이지의 요청과 응답에 관한 제어권을 URL 로 지정된 주소로 임시로 넘긴다.
- include(url) 메서드는 인클루드 된 페이지의 요청처리가 끝나면 제어권은 다시 원래의 페이지로 돌아가므로 인클루드로 지정된 페이지의 내용을 원래 페이지에 포함하는 효과를 가진다.
- 인클루드 방식은 여러 페이지를 한 페이지 안에 포함하며 현재 페이지의 요청과 응답에 관한 제어권을 URL 로 지정된 주소로 임시로 넘긴다.
- Include의 경우는 url1에서 include를 하면 url2로 제어권을 잠시 빌려주고 처리를 다 하면 다시 url1으로 제어권을 반납한다. 따라서 클라이언트화면에서는 url1의 내용속에 url2가 들어가서 보여진다.





## 리다이렉트
- 사례를 통해 redirect와 forward의 차이점에 대해 감을 잡아보자. 여기서 고객은 클라이언트이고, 123번은 URL이며, 상담원은 서버가 된다.
- 포워드랑 달리 외부로 호출 가능; ‘http://’ 사용 가능
- ⎼sendRedirect(url) 메서드는 지정된 URL 로 요청을 재전송하고 클라이언트 요청을 다른 페이지로 보낸다.
- sendRedirect(url) 메서드는 새로운 페이지를 위한 request 객체가 생성되므로 주소창의 주소가 변경되며 특정
- 작업을 완료한 후 다음 페이지로 이동할 때 흔히 sendRedirect 메서드를 사용하는데 sendRedirect 메서드는 두 번의 request 객체를 통해 하나의 작업을 완료하는 방식이다.
- sendRedirect(url) 메서드는 첫번째 요청이 서버에서 처리된 다음 서버는 이동할 다음 페이지의 경로를 클라이언트에 응답하면 클라이언트의 브라우저는 서버에게 새로운 페이지를 다시 요청하여 이동하는 방식이다.
- sendRedirect(url) 메서드를 이용할 경우에는 String 클래스 타입 밖에 전달 할 수 없으므로 세션을 이용하여 다른 타입을 전달한다.

### 리다에릭트, 포워드
- 포스트 방식 -> sendredirect 안됨
 

## sendRedirect 메서드와 forward 메서드의 차이점
- sendRedirect 메서드는 URL 을 웹 브라우저로 보내서 간접적으로 웹 자원을 호출하지만 forward 메서드는 웹서버 쪽에서 직접 호출한다.
- sendRedirect 메서드를 이용하면 다른 웹 서버에 있는 웹 자원도 호출할 수 있지만 forward 메서드를 이용하면 같은 웹서버나 같은 웹 어플리케이션 디렉토리 내에 있는 웹 자원만 호출할 수 있다.
- sendRedirect 메서드를 이용하면 텍스트(문자열) 데이터만 전달할 수 있지만 forward 메서드를 이용하면 객체 형태의 모든 데이터를 전달 할 수 있다.
- sendRedirect 메서드를 통해 한글 데이터를 전달하기 위해서는 URL 인코딩을 해야 하지만 forward 메서드에서는 그런 작업이 필요치 않다.

## get 방식
- RequestDispatcher dispatcher = request.getRequestDispatcher("./assign/view2.jsp?name=" + name + "&addr=" +addr + "&tel=" + tel + "&hobby=" + hobby);

 
- 첫번째 사례(redirect)
1. 고객이 고객센터로 상담원에게 123번으로 전화를 건다.
2. 상담원은 고객에게 다음과 같이 이야기한다. "고객님 해당 문의사항은 124번으로 다시 문의 해주시겠어요?"
3. 고객은 다시 124번으로 문의해서 일을 처리한다.
 
- 두번째 사례(forward)
1. 고객이 고객센터로 상담원에게 123번으로 전화를 건다.
2. 상담원은 해당 문의사항에 대해 잘 알지 못해서 옆의 다른 상담원에게 해당 문의사항에 답을 얻는다.
3. 상담원은 고객에게 문의사항을 처리해준다.


# WAR
* 패키징 된 웹 응용 프로그램

# 컨텍스트
* 하나의 웹 응용프로그램, 공통된 실행 


# 모델 1
1.  정의
- 모든 클라이언트 요청과 응답을 JSP가 담당하는 구조이다.
2. 개요
- JSP 로 구현한 기존 웹 어플리케이션은 모델1 구조로 웹 브라우저의 요청을 JSP 페이지가 받아서 처리하는구조이다.
- JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 보여주기 위한 출력 관련 코드가 뒤섞여 있는 구조로 웹 브라우저의 요청이 곧바로 JSP에 전달된다.
- 웹 브라우저의 요청을 받은 JSP 는 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업을 처리하고 그 결과를 클라이언트에 출력해준다.
- JSP 페이지에서 웹 브라우저가 요청한 것들을 처리한다는 것은 JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 보여줄 출력 관련 코드가 섞인다는 것을 의미한다.
- 하나의 JSP 페이지에서 서비스 클래스를 통해서 원하는 작업을수행하고 그 결과를 출력하는 경우가 많았는데 이것이 모델1 구조의 전형적인 예이다.
- 모델1 구조는 JSP 페이지 안에서 모든 정보를 표현(View)하고 저장(Model)하고 처리(Control)되므로 재사용이 힘들고 읽기도 힘들어 가독성이 떨어진다.
- 모델1 구조는 JSP 페이지에서 화면을 보여주는 기능도 하고 요청이 페이지로 들어올 때 요청에 관한 비즈니스 로직을 수행하는 것도 JSP 페이지에서 직접 이루어진다.
- 모델1 구조로 개발할 경우에 개발 시간은 짧아 질 수 있지만 유지보수 시 코드 분석이 어려워지고 디자이너가 디자인을 변경하려고 할 때 태그 외에 자바 코드들이 섞여 있기 때문에 해석하는 데 문제가 발생할 수 있다.
- 모델1 구조의 코드의 복잡성과 디자이너와 개발자 영역의 비분리 등은 프로젝트 규모가 커질수록 더 큰 걸림돌이 된다.

3. 장점
- 단순한 페이지 작성으로 쉽게 구현 가능하며 중소형 프로젝트에 적합하다.

4. 단점
- 웹 애플리케이션이 복잡해지면 유지보수 문제가 발생된다.


# 모델 2
1. 정의
- 클라이언트의 요청처리와 응답처리 및 비즈니스 로직 처리하는 부분을 모듈화 시킨 구조이다.

2. 개요
- 모델2 구조는 모델1 구조와 달리 웹 브라우저의 요청을 하나의 서블릿이 받게 되며 서블릿은 웹 브라우저의 요청을 알맞게 처리한 후 그 결과를 보여줄 JSP 페이지로 포워딩한다.
- 포워딩을 통해서 요청 흐름을 받은 JSP 페이지는 결과 화면을 클라이언트에 전송하여 서블릿이 비즈니스 로직 부분을 처리하게 되는 것 이다.
- 모델2 구조의 특징은 웹 브라우저의 모든 요청이 단일 진입점인 하나의 서블릿에서 처리된다는 점이다.
- 모델2 구조는 하나의 서블릿이 웹 브라우저의 모든 요청을 받기 때문에 서블릿은 웹 브라우저의 요청을 구분할 수 있는 방법을 필요로 하며 서블릿은 웹 브라우저의 요청을 처리한 후 웹 브라우저에 보여줄 JSP 를 선택하게 된다.
- 모델2 구조의 이러한 특징 때문에 MVC 패턴에 기반을 두어 웹 어플리케이션을 구현할 때는 모델2 구조를 주로 사용한다.
- 모델1 구조는 컨트롤러가 모델이나 뷰를 포함한 MV 형태를 띠고 있고 모델2는 완전한 MVC 형태를 적용하고 있다고 볼 수 있다.
- 모델2 구조는 디자인 부분과 비즈니스 로직 부분을 분리해서 개발하기 때문에 디자이너는 디자인 부분만 프로그래머는 로직 부분만 개발하는 것이 가능하다.
- 모델2 구조는 각 담당하는 부분의 페이지가 독립적이므로 디자이너는 JSP 페이지에 그리고 프로그래머는 java 클래스에 존재하므로 동시에 개발이 가능하여 프로젝트 규모가 커지면 오히려 프로젝트 생산성도 좋아진다.
- 모델2 구조 방식으로 개발하면 유지 보수 시 디자인을 변경하거나 로직을 변경할 때 자신이 개발한 부분에만 접근하여 변경할 수 있게 된다.
- 모델2 구조의 경우는 설계 단계가 까다로우므로 모델1 보다는 개발 기간이 더 길어지므로 일반적으로 규모가 그다지 크지 않은 프로젝트에서는 모델1 구조로 구현하는 것이 좋다.

3. 장점
- 처리작업의 분리로 인해 유지보수와 확장이 용이하다.

4. 단점
- 구조 설계를 위한 시간이 많이 소요되므로 개발 기간이 증가한다.


## 서버 페이지 표현
1. <% %>; 태그의 나머지; jsp, asp
- <%@ 지시어>
2. <? ?>; 태그의 질의어; php

# Servlet
- C:\apache-8.5.39\apache-tomcat-8.5.39\lib
- 웹에서 받은 데이터를 자바로 넘겨주는 역할

# WEB-INF
- 웹 애플리케이션 용으로 (servlet 규격으로) 따로 만들어진 디렉터리
- 웹을 중요한 파일들이 노출되지 않도록 만든 폴더



# META-INF
- 자바 패키징 기술인 jar의 일부
- META-INF폴더는 자바에서 설정관련 파일을 저장하는 폴더
- jar 파일들을 풀어보면 META-INF 폴더 아래 MANIFEST.MF 라는 파일이 있고 사양서 내용이 있다.
- 스프링 설정 파일을 META-INF에 두는 이유는  해당 애플리케이션을 war가 아닌 jar로 패키징해서 배포할 수 있기 때문.

# 세션
- 세션 id를 가지고 유지를 시킨다.
- HTTP 프로토콜은 요청(request)과 응답(response)의 구조로 되어 있어 서버가 요청에 대한 응답을 전송하고 나면 연결이 끊어지게(Stateless) 된다.
- 클라이언트의 정보가 유지되어야 할 필요가 있는 경우를 위해 가상 연결(Virtual Connection)이라는 개념의 세션이 등장하였고 JSP 에서는 이러한 세션을 session 내장 객체를 이용하여 구현한다.
- session 객체는 브라우저가 종료되어야 해제된다.
- session 객체는 강제로 끊어주거나 웹브라우저를 닫지 않는 한 계속 정보를 유지할 수 있다.



# request 객체의 request 문자열 인코딩과 요청 파라미터 관련 메서드
1. setCharacterEncoding 메서드
- setCharacterEncoding( ) 메서드는 문자열 인코딩 정보와 관련된 메서드로 문자를 인코딩을 해서 JSP로 전달해주며 한글일 경우 웹 페이지에서 꼭 필요하다.

2. getParameter 메서드
- getParameter(name) 메서드는 지정한 name 의 이름으로 지정된 파라미터에 할당된 값을 리턴 하므로 인자의 문자열과 같은 파라미터 값을 가져온다.
- getParameter(name) 메서드는 지정한 name 의 이름의 파라미터가 없으면 null 을 리턴한다.

3. getParameterValues 메서드
- getParameterValues(name) 메서드는 name 의 이름으로 지정된 파라미터의 모든 값을 문자열 배열로 리턴하고 하나의 이름으로 여러 개의 값을 가질 수 있다.
- getParameterValues(name) 메서드는 HTML 의 checkbox 요소와 같은 태그를 사용했을 때에 주로 사용되고 인자의 문자열과 같은 파라미터의 값을 배열로 가져온다.
- 하나의 이름에 하나의 값만 가지는 파라미터는 getParameter( ) 메서드를 사용하는 것이 좋다.

4. getParameterNames 메서드
- getParameterNames( ) 메서드는 요청에 포함된 모든 파라미터 이름을 Enumeration 인터페이스의 객체로 리턴하고 파라미터의 이름들을 나열하여 넘겨준다.

## request 객체의 쿠키 정보와 세션 정보 관련 메서드
1. getCookies 메서드
- getCookies( ) 메서드는 쿠키 정보와 관련된 메서드로 HTTP 요청 메시지의 헤더에 포함된 쿠키를 Cookie 클래스 배열로 리턴하고 모든 쿠키값을 배열 형태로 가져온다.

2. getSession 메서드
- getSession(Boolean create) 메서드는 세션 정보와 관련된 메서드로 요청한 클라이언트에 지정된 HttpSession 인터페이스의 객체를 반환하고 이전에 생성된 HttpSession 인터페이스의 객체가 없으면 새로운 객체를 생성해 할당한다.
- getSession(Boolean create) 메서드에 인자로 true 지정하면 getSession( ) 메서드와 동일한 결과를 리턴 하지만 false 로 지정하면 이전에 생성된 HttpSession 인터페이스의 객체가 없을 경우 null 을 리턴한다.

3. getRequestedSessionld 메서드
- getRequestedSessionld( ) 메서드는 세션 정보와 관련된 메서드로 요청한 클라이언트에 지정된 세션의 ID를 문자열로 리턴한다.

4. isRequestedSessionldValid 메서드
- isRequestedSessionldValid( ) 메서드는 세션 정보와 관련된 메서드로 요청한 포함된 클라이언트의 세션 ID가 유효하면 true 를 아니면 false 를 리턴한다.





## 필터(Fiter) 
* 필터의 개요 ⎼필터는 특정한 요청을 처리하기 전이나 후에 특정한 작업을 처리하는 기능이다. 
* 필터는 의 요청과 응답을 변경할 수 있는 재사용 가능한 객체이다 http . 
* 클라이언트의 특정 또는 공통의 요청 정보를 점검하거나 알맞게 변경하는 등 다음과 같은 것들을 할 수 있다
* 인증 로깅 요청 처리 데이터 변환 암호화 체크 

# JSP
* JAVA in HTML

## 형식
-   <servlet-name>so</servlet-name>; 이름부터 설정 필요;
-   <servlet-class>a.b.c.Test</servlet-class>; 클래스 이름은 서블릿 이름과 매치


## 서블릿의 의미
- 자바의 클래스 중 오직 서버(http; TCP/IP 프로토콜) 에서만 실행될 수 있는 클래스

# was
- server.xml -> web.xml


## web.xml
- 자바 -- web.xml -- 웹, 모바일
- web.xml을 어노테이션으로 구현(코드의 불필요 부분을 줄임)
- 존슨이 Spring을 이용하여 EJB를 사용하지 않고 구성.
1. 파일의 성격을 구성
2. 오류 페이지 구성
3. http 프로토콜의 영향 설정
4. 리스너 -> TCP/IP
5. 공통된 인코딩 설정 가능
- web.xml 파일은 <web-app> 태그로 시작하고 종료하는 문서로서 web.xml 파일에서는 정의된 Web Application 으로 구성된 임의의 디렉토리는 다음과 같은 것들이 존재한다.
1.  JSP 와 HTML 파일 그리고 이미지 파일과 같은 정형 데이터 파일 등 클라이언트에서 수행되는 파일
2. DD(Deployment Desciptor) 파일
3. 환경 파일
4. Servlet 과 같은 서버 상에서 수행되는 클래스 파일


## 설정파일
- 자바 -> JDK 필요
- 웹, 모바일 -> 서블릿(추상클래스; 자바와 웹을 연동)
- xml: 매핑, 상속

## 실행
- Servlet이 control 역할을 하면 jsp를 바로 실행 못하고 Servlet을 실행시켜야 한다.

## ajax
- put, delete는 ajax와 같이 사용

## HttpServlet

## jsp의 서블릿
- 톰켓 서버의 web.xml 보면 서블릿 이름이 jsp가 있어 동작하게 하는 기본 서블릿이 있다.


## 클래스
- 각 클래스 마다 1개의 서블릿 필요; 입력 서블릿, 수정 서블릿, 삭제 서블릿, 검색 서블릿

## 서블릿 설정
* xml에서 등록 안해놓으면 자바 코드에서 @servlet 찾음
-   <!-- 1. aliases 설정 -->
-     <servlet>
-         <servlet-name>welcome</servlet-name>
-         <servlet-class>servlets.WelcomeServlet</servlet-class>
-     </servlet>

-     <!-- 2. 매핑 -->
-     <servlet-mapping>
-         <servlet-name>welcome</servlet-name>
-         <url-pattern>/welcome</url-pattern>
-     </servlet-mapping>

### url-pattern
- *.me 는 모든 걸 동작시킴
- /클래스 이름; 충돌 방지 위해 클래스와 이름을 매칭함.

### aliases 설정
- 서블릿 이름을 실제 서블릿 클래스에 연결
- <servlet-name>welcome</servlet-name>과 아래 매핑 설정에서의 servlet-name은 반드시 같아야 한다.
- <servlet-class>servlets.WelcomeServlet</servlet-class>은 개발자에 의해 작성된 실제 클래스 이름으로 설정해야 한다.
- Ex. (패키지 이름).(서블릿 클래스 이름)
- 매핑
- URL을 서블릿 이름에 연결
- <url-pattern>/welcome</url-pattern>은 클라이언트(browser)의 요청 URL에서 앱(프로젝트) 이름 뒤에 오는 부분으로, 슬래시(‘/’)로 시작해야 한다.

## 경로
- navigator에서 build와 webContent를 같은 위치로 보고 classes와 WEB-INF와 META-INF가 같은 위치라고 본다. classes 안의 패키지는 경로로 보지 않는다.

# http
## ://
- http 프로토콜을 하위 디렉토리에 영향을 주겠다.


## ASP, PHP, JSP, 서블릿
- ASP는 IIS라는 웹서버에서 동작하는 언어이며 비베스크립트라고 불리운다.
- PHP는 APACHE 혹은  PHP용 웹서버가 있는 웹서버에서 동작하는 언어. 가볍다 빠르다.
IIS에서도 돌릴 수 있다.
- JSP는 자바에서 나온 웹언어. 자바용 서버인  TOMCAT이나 RESIN, JSERV에서 돌릴수 있다.
- APACHE : 공개용 웹서버, 작고 빠르기때문에 중소형 웹서버에 많이 쓰인다. APCHE는 보통 리눅스                  에 많이 설치한다. 무료인데다가 안정성 또한 우수하기 때문이지~
- 스프링 프레임워크가 서블릿 사용: 서블릿

# 커넥터 풀
## tomcat-dbcp
-  톰켓을 사용하지 않을수도 있으니 잘 사용 안함.

## response.setContentType("text/html;charset=UTF-8");



# 액션 태그; 커스텀 테그
- 서블릿 통합

## 종류

- forward, include 액션 사용 안함, useBean만 액션 사용

## useBean
-  <jsp:useBean id="com" class="a.b.c.dto.Command" scope="page" ></jsp:useBean>
- scope=”page”는 이 파일에서만 사용하겠다.
- <jsp:setProperty property="name" name="com" value="길동홍"/>


- 이걸 사용하면 new 선언할 필요 없이 id가 instance 뒤가 클래스
- Command com = new Command(); 와 동일

## EL

### 널 연산자
- a. 사용법 : empty
- b. 내용 : 값이 null 일 경우 true를 반환한다.

## JSP 커스텀 태그; 개발자가 만든 액션 태그; 
- 표준 액션 태그의 기능을 내장하고 있다.

## taglib 다운 
- 1.2버전: http://tomcat.apache.org/taglibs/standard/; impl, el, spec, compat 4개 다운

# import
- 웹은 war파일 export, import

## redirect
- web container는 redirect 명령이 들어오면 웹 브라우저에게 다른 페이지로 이동하라는 명령을 내린다.(두번째 사례의 경우, 고객은 전화를 끊고 124번으로 다시 전화를 건다.
- 웹 브라우저는 URL을 지시된 주소로 바꾸고 그 주소로 이동한다.
- 새로운 페이지에서는 request,response 객체가 새롭게 생성된다. (123번에서 고객이 요청했던 문의사항은 124번으로 다시 걸어서 요청한 문의사항을 다시 말해야한다.)
- redirect의 경우 최초 요청을 받은 URL1에서 클라이언트에 redirect할 URL2를 리턴하고, 클라이언트에게 새로운 요청을 생성하여 URL2에 다시 요청을 보낸다. 따라서 처음 보냈던 최초의 요청정보는 더이상 유효 하지 않다.

# page import
- <%@ page import="java.lang.String" %>


# CheckBox 배열 값 받기; pg308
- paramValues로 배열값 받기

- <c:forEach var="hobby" items="${paramValues.hobby}" varStatus="status">
- ${hobby}
- </c:forEach>





# XPath 개요
- xml 소스 트리의 정확한 위치를 지정해주기 위한 경로지정 문법이고 XSLT 와 XPointer 를 위해서 만들어진 것이며 xml 엘리먼트들을 노드(node)로 접근하고 XSLT 언어에 사용될 목적으로 설계되었다.
- .XML 문서는 트리 구조로 구조화 되어 있기에 XPath 라는 [약속된 경로 표기법]을 사용한다.
- .XML 문서의 프로그래밍 API 인 DOM(Document Object Mode)에서 노드를 검색할 때 사용한다.
- XPath 를 사용하려면 xalan.jar 라이브러리가 필수적으로 필요하며 다음과 같은 특성이 있다.
- ① XPath 는 절대 경로와 상대 경로 사용가능하며 절대경로 /(슬래시) 로 시작하고 상대 경로는 '.'(현재 단계 점1개)'..'(상위단계 점2개)을 사용한다.
- ② //(쌍 슬래시)로 시작할 경우는 모든 영역에서 해당 엘리먼트를 선택하게 된다.
- ③ 동일한 엘리먼트들이 있을 경우 [ ] 안에 포함된 숫자는 엘리먼트의 순번이며 조건식이 올 경우 해당하는 것이 선택된다.
- ④ last 메서드 일 경우는 맨 마지막 엘리먼트를 표시한다.
- ⑤ 속성은 at 기호(@)로 시작된다.
- ⑥ normalize-space 함수는 앞뒤 공백을 제거하는 trim 메서드의 역할을 한다.


