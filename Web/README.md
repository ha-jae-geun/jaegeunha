# 브라우저; 톰켓 이용 <>http; 컨트롤러(http 파라미터) <> 자바(모델, 서비스, DAO) <> DB 
- 컨트롤러가 자바면 JSP, C#이면 ASP, PHP면 PHP
- 자바에서 중간 연결체: 클래스 -> 웹과 연동을 하는 클래스: 서블릿이라고 부름
- jsp도 서블릿 역할; 컨트롤러 역할도 함
- 보내주는 방법: 1. 새로운 request 생성(redirect)  2. 기존의 request 유지(forward)
- 포워드 방식을 자주 사용

# 브라우저
## 넷스케이프
- MS에서 익스플로러를 windows 95 plus!에서 부터 끼워팔기 해서 넷스케이프 점유율이 50%까지 추락하였으며 이후에 windows 98에서 부터 끼워팔기를 해서 점유율을 떨어뜨려 개망하게 된 것입니다.


## 인터넷 익스플로우

## 크롬
- 크롬은 빠른 속도와, 구글과의 연동 기능으로 평이 좋고 널리 쓰이는 브라우저입니다. 구글에서 받쳐주는 브라우저이기 때문에, 각종 미디어 코덱의 지원도 빵빵하고, 구글 계열의 제품들인 구글 닥스, Gmail, 행아웃, 유튜브, 애드센스, 구글 지도 등과의 연계도 당연히 잘 될수밖에 없습니다. 또, 속도가 빠른 편이기도 합니다.
- 하지만, 이런 크롬에도 단점은 있겠죠? 크롬은 각 탭을 별개의 프로세스로 관리합니다. 그 말인 즉슨, 탭 두개를 열면 크롬 2개가 구동되는 메모리와 같다는 말이죠. 때문에 사양이 낮은 컴퓨터에서는 다른 브라우저에 비해 상당히 무겁게 느껴지는 브라우저인 것도 사실입니다.




## 파이어폭스
- 탭 브라우징에도 많이 신경을 쓴 부분이 보입니다. 글을 쓰다보면 이리저리 참고할 부분이 많은데, 이렇게 탭을 많이 열어놓고 참고해서 쓰고, 또 열다보면 어느새 열려있는 탭이 수십개가 되는 경우가 생깁니다. 이럴 때에 타 브라우저에 비해서 탭을 잘 관리하도록 도와주는 브라우저가 파이어폭스입니다. 탭을 좌우로 드래그해서 보기, 모든 탭 북마크 지정, 이 탭을 제외하고 모두 닫기, 닫은 탭 되돌리기.. 이런 기능들이 다른 브라우저들과 겹치는 기능일지도 모르겠지만, 실제로 사용할때에 가장 편리하다는 느낌을 받은 브라우저는 파이어폭스인것 같네요.
- 이런 파이어폭스의 단점이라면, 아무래도 큼지막한 회사 애플, 마이크로소프트, 구글에서 만드는 다른 브라우저들과 달리 비영리인 재단에서 만드는지라 유튜브에서 60fps 동영상도 지원하지 않는다는 기사를 얼마 전에 본 것 같습니다.
 
# 사파리
- 애플에서 개발하는 브라우저입니다. 따라서 아이폰/패드/팟 같은 애플의 모바일 기기에서는 기본으로 내장되어있기 때문에 점유율이 상당히 높지만, 본 글은 PC의 5대 브라우저에 대해 설명하는 글이기 때문에 PC를 기준으로 말씀드리겠습니다. 윈도우용의 경우에는, 솔직히 말하자면 타 브라우저보다 월등히 나은 점을 발견하기 힙듭니다. 사파리의 개발목적이 윈도우와는 먼 탓도 있고요. 또 개인용 컴퓨터에서 매킨토시를 쓰는 분들이 윈도우에 비해 많이 적기에, PC에서의 위상이 많이 크지는 않습니다. 하지만 5대 브라우저에 포함되는 만큼, 웹 프로그램 개발을 할 때에나 사이트를 만들 때에 절대 무시할수 없는 브라우저이기도 하죠.

## 오페라
- 오페라는 노르웨이의 오페라 소프트웨어에서 개발하고 배포하는 브라우저로, 가늘고 길게 연명해온 것이 특징이라고 할 수 있겠습니다. 또한 굉장히 다양한 플랫폼을 지원하고 있어서, 사파리와 마찬가지로 PC에서보다는 모바일/PDA 기기에서 영향력이 큰 브라우저이기도 합니다. 안드로이드에서의 오페라 미니, 아이패드에서의 오페라 코스트처럼 본래 오페라와 차이가 조금 있는 갈래들을 내기도 하고요.
- 우선 오페라는 다양한 환경, 특히 느린 네트워크에서 돌아가는 것에 상당히 신경을 써둔 브라우저입니다. 오페라 터보 기능(느린 네트워크에서 더 빨리 받을 수 있도록, 웹 페이지를 압축한 뒤 보내주어 로딩 속도를 빠르게 해주는 기능)이 그 대표적인 예라고 할 수 있겠지요. '오페라만의' 분위기나 개성이 강한 편이라, 고정 사용자층이 있는 편입니다.
 
## 브라우저 특징
1. html 지원하는 형태
2. 각 브라우저의 공통으로  레이아웃 지원



# 원격 네트워크
- 브라우저를 이용하지 않은 연동
- 브라우저를 이용한 연동은 ‘웹’이라는 말이 들어간다.

# 브라우저
* 익스플로어, 엣지, 파이어폭스, 크롬, 오페라, 사파리

## 시크릿 모드
* 입력정보를 보관하지 않음
* 캐시(임시파일)를 보관하지 않음
* 쿠키를 보관하지 않음

# 웹 서버 (Web Server
 * 클라이언트가 서버에 페이지 요청을 하면 요청을 받아 정적 컨텐츠(.html, .png, .css등)를 제공하는 서버
 * 클라이언트에서 요청이 올 때 가장 앞에서 요청에 대한 처리를 한다.
 * 클라이언트의 요청을 기다리고 요청에 대한 데이터를 만들어서 응답하는 역할 (정적 데이터)
 
## CASE
 * 정적 컨텐츠를 요청(request)했나?
 * 1. 정적 컨텐츠구나! 내가 제공해줄게 => .html, .png 등 응답(response)
 * 2. 정적 컨텐츠가 아니구나.. 웹서버에서 간단히 처리 못하겠군. WAS에게 처리를 부탁해야겠다! => 결국 WAS가 처리해준 컨텐츠를 받은 웹서버는 응답(response)을 해줌
 * 대표 : Apache, nginx
 
 
# WAS (Web Application Server)
 * 동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버 (DB조회, 로직처리가 요구되는 컨텐츠)
 * JSP,Servlet 구동 환경 제공
 * 컨테이너, 웹컨테이너, 서블릿 컨테이너라고도 부름
* JSP, servlet을 실행시킬 수 있는 소프트웨어 = 컨테이너
 
 
## 동작 프로세스
1. 웹서버로부터 요청이 오면 컨테이너가 받아서 처리
2. 컨테이너는 web.xml을 참조하여 해당 서블릿에 대한 쓰레드 생성하고 httpServletRequest와 httpServletResponse 객체를 생성하여 전달한다.
3. 컨테이너는 서블릿을 호출한다.
4. 호출된 서블릿의 작업을 담당하게 된 쓰레드(2번에서 만든 쓰레드)는 doPost()또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response객체에 담아 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response객체를 HTTPResponse형태로 바꿔 웹서버에 전달하고 생성되었던 쓰레드를 종료하고 httpServletRequest, httpServletResponse 객체를 소멸시킨다.
대표 : Tomcat, Jeus, JBoss
 
## Web Server가 필요한 이유?
 * 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
 * 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
 * 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
 * Web Server를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
 * 따라서 Web Server에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
## WAS가 필요한 이유?
 * 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다.
 * 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
 * 이때, Web Server만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.
 * 하지만 이렇게 수행하기에는 자원이 절대적으로 부족하다.
 * 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.
 * https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html
 
 
## WAS와 웹 서버 차이
 * - 클라이언트 - WAS(웹서버 - 웹컨테이너: JSP, Servlet) - 데이터 베이
 * - 동적 컨텐츠 처리를 수행 가능한가 아닌가.
 * WAS는 정적,동적 처리 둘다 가능하지만 정적처리를 WAS가 하게되면 부하가 많이 걸려서 좋지 않음
 *  
 * * 톰캣(WAS)에는 아파치(웹서버)의 기능(웹서비스데몬, Httpd)를 포함하고 있다.
 * - 일반적인 WAS, Web Server 구조가 아닌 걸로 알고 있음.
 *  
 * * WAS, Web Server를 따로 두고 쓰는 이유가 성능때문이라고 하는 건 잘못되었다.
 * 톰캣5.5 이상부터는 httpd의 native모듈을 사용해서 정적파일을 처리하는 기능을 제공하는데 이것이 순수 아파치 Httpd만 사용하는 것과 비교해서 성능이 전혀 떨어지지 않기 때문이다.
 * 그럼에도 톰캣앞에 아파치를 두는 이유는 하나의 서버에서 php애플리케이션과 java애플리케이션을 함께 사용하거나, httpd 서버를 간단한 로드밸런싱을 위해서 사용해야 할 때 필요하기 때문.


## 로드밸런싱(Loadbalancing)
 * 로드 밸런싱이란 부하 분산을 위해서 가상(virtual) IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.
 * 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도 저하 등을 고려하여 적절히 분산처리하여 해결해 주는 서비스이다. 로드밸런싱을 해주는 소프트웨어 혹은 하드웨어 장비를 로드밸런서라고 한다. 로드밸런서의 주 목적은 동시에 오는 수 많은 커넥션을 처리하고 해당 커넥션이 요청 노드 중의 하나로 전달될 수 있게 하는 것이다. 그리고 단지 노드를 추가하는 것만으로 서비스가 확장성을 가질 수 있도록 한다. 오픈 소스 로드 밸런서 중 많이 사용되고 있는 것은 HAProxy 이다.

## 로드 밸런싱에서 사용하는 주요 기술은 다음과 같다.
 * NAT(Network Address Translation) : private IP를 public IP로 바꾸는데 사용하는 통신망의 주소변조기
 * DSR(Dynamic Source Routing protocol) : 로드밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념
 * Tunneling : 인터넷 상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념으로, 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제할 수 있다.
 * 
 * 로드밸런서를 사용할 때 어려운 문제 중 하나는 세션 데이터를 관리하는 것이다. 서버에 액세스 할 때마다 다른 세션을 사용한다면 특정 사용자의 정보를 일관성있게 유지할 수 없게 된다. 이러한 문제를 해결하기 위해 세션을 고정(session sticky)한다. 이 방법으로 특정 사용자의 요청이 전달될 노드를 고정시킬 수 있다. 하지만 이 방법도 문제가 있다. 고정된 세션의 노드에 장애가 발생하면 고정한 의미가 없어진다. 장애가 발생하여 비활성화된 노드에 대한 고려가 필요하다.

## 대용량 서비스를 운영하려면 부하 분산은 필수이다.
 * 대용량 트래픽을 장애없이 처리하려면 여러 대의 서버에 적절히 트래픽을 분배해야 한다.
 * 단지 몇 개의 노드만 있다면 라운드 로빈 DNS와 같은 방식이 합리적이다. 로드 밸런서 자체의 비용이 높고 불필요한 복잡함을 증가시킬 수 있기 때문이다.  DNS에서는 하나의 도메인 이름을 라운드 로빈 방식으로 여러 개의 IP 주소를 변환한다면 이것만으로 쉽게 부하 분산이 가능하다. 하지만 여기에 두 가지 단점이 존재한다. 첫째, 대부분의 클라이언트에서는 DNS 서버의 부하를 줄이고 성능을 향상시키기 위해 일정 시간 동안 캐싱하기 때문에 부하 분산이 균등하게 발생하지 않는다. 둘째, 특정 서버에 장애가 발생하더라도 장애 여부가 감지되지 않아 서비스에서 해당 서버를 제거할 수 없다.
 * 그렇기 때문에 대규모 시스템에는 다양한 알고리즘과 스케줄링이 사용되고 있다 이러한 알고리즘들은 네트워크 트래픽과 분산 요청을 제어하면서 자동 절체나 이상 노드 제거와 같은 신뢰성 관련한 기능을 제공한다.

## 클러스팅
 * - 여러 개의 컴퓨터를 연결한 병렬 시스템으로 마치 하나의 컴퓨터처럼 사용하는 것을 클러스터라고 한다. 클러스터링 환경에서는 특정 장비에 문제가 생기거나 특정 장비에서 실행중인 애플리케이션에 문제가 발생하더라도 전체 서비스에 영향을 미치지 않도록 제어가 가능하다.
 * 클러스터링은 기본적으로 Virtual IP(가상 IP)를 기반으로 구현된다. 서비스를 제공하는 실제 장비는 물리적인 IP를 갖고, 데이터의 처리는 Virtual IP를 통해 이루어진다. 내부 시스템은 철저하게 가려져 있는 것이 원칙이다.
 * 
 * 확장 면에서 비교
 * 둘 다 scale-out 방식, 즉 수평 방향으로 노드를 추가해서 성능을 업그레이드 하는 방법이다. 저렴한 노드를 여러개 묶어서 성능을 업그레이드 하며, scale-up 방식에 비해 비용을 줄일 수 있으며 유연한 구성이 가능하다. 로드밸런싱은 하나의 서비스를 하나 이상의 노드가 처리하는 식으로 작동한다.

### 어떤 점이 좋은가?
 * 1 . 저렴한 비용으로 다수의 서버를 증설하여 비용절감의 효과를 볼 수 있다.
 * 2. 1대의 서버 장애가 발생하여도 서비스 중단없이 다른 서버로 적절히 자동 분배되어 서비스가 계속 운용가능하다.
 * 3. 서버를 확장할 때에도 서비스 중단없이 서버 증설이 가능하다.


# 대칭키 기법
- https://soul0.tistory.com/372 
- 하나의 비밀키를 양쪽(client - server)가 모두 같이 사용하는 것이 문제
-     (암호화와 복호화에 같은 암호 키를 쓰는 알고리즘)
- 해커로부터 안전할 수 없다
- 알고리즘 방식으로 DES, 3-DES, AES, SEED, ARIA, MASK 등이 있다.

# 비대칭키
- 비대칭키 는 암/복호화 할때의 Key 값이 다르다 대표적으로 RSA 라는 암호화가 있으며
 암호화 할때의 키를 공개키(Public Key) 복호화 할때의 키를 ​개인키(Private Key) 라고 한다.
- 즉,  암호화 할때의 Key 와 복호화 할때의 Key 값이 같으면 “대칭키”  ​암호화 할때의 Key 와 복호화 할때의 Key 값이 다르면 “비대칭키” 라고 한다.
 




# 공개키 기법 (≒비대칭키 기법, ≒비밀키 암호화, ≒비대칭형 암호 알고리즘)
- 보내야 하는 데이터를 송신자가 수신자의 공개키로 암호화를 걸어 놓고 데이터를 받은 수신자가 자신의 개인키(=비밀키)로 복호화를 하는 방법
- 개인 키는 한쪽에만 속해 있기 때문에 개인 키가 사용된 것으로 나타난 모든 경우 해당 키의 소유자만이 그것을 사용했다고 결론지을 수 있다.
- 한 쌍(공개키 + 개인키)의 키 조합이 필요.
- 암호화에 사용된 키와 복호화에 사 용된는 키가 다름에도 수학적 원리에 의해 해독이 가능하도록 한 방식
- 알고리즘 방식으로 RSA, DSA 등이 있다.
- 공개키 기법은 시간이 오래 걸리는 단점을 극복하고자 공개키 암호화는 대칭키를 보내는 용도로만 사용
- 개인키만 잘 보관하면 완벽한 암호화 기법

## 공개키 과정
- 공개키로 암호화하면 개이키로만 풀 수 있다.
- 각 키는 매우 큰 숫자이므로 한 개의 키로 다른 키를 알아내기 어렵다.
상대방에게 내 공개키를 알려준다.
2. 상대방은 나에게 자신의 공개키를 알려준다.
3. 상대방은 나의 공개키를 이용해 암호화된 문서를 나에게 보낸다.
4. 나는 내 개인키로 이 암호문을 해독한다.
5. 내 대답은 상대방의 공개키로 암호화해서 보낸다.
6. 상대방은 자신의 개인키로 내 글을 해독한다. 

# 공개키 기법으로 암호화한 대칭키 기법 내용
- 표준 보안 방식 SSL 이라고 부름.
- Secure Socket Layer
- 접속한 사이트가 신뢰할 수 있는 지 확인하기 위한 인증서가 출현
- 대칭키 기법 + 공개키 기법 = 장점만을 살린 방법
- 여기서 사용되는 대칭키는 매번 랜덤으로 선택되는데, 이렇게되면 만약 대칭키가 누출되어도 다음번에는 다른 키가 사용되기 때문에 안전
# 인증서란? ( 사이트와 인증기관의 구분을 명확히 생각하도록 하자. )
- 모든 개인키는 오직 자기 자신만 소유한다. 즉, 통신을 위한 공개키를 대충에게 공개해야 한다.
- 공인 인증 기관 출현
- 공인 인증 기관은 인증서를 발행해 주지만, 주 목적은 요청한 사이트에게 해당하는 인증기관 개인키와 인증기관 공개키 쌍을 만든다. 사이트에는 인증기관 개인키로 암호화한 인증서(사이트 공개키 + 사이트정보)를 발행 / 웹 브라우저에는 인증기관 공개키를 발행하여 암복호화 할 수 있도록 구성
- 사이트 개인키(Private Key) 를 보증(SSL 통신)하기 위해서 그 쌍이 되는 사이트 공개키(Public Key)가 바로 인증서에 들어있음.
- 또한 '공인 인증 기관의 전자 서명'이 바로 인증서에 들어 있음.
- 즉, 인증서는 사이트 공개키 + 공인 인증 기관의 전자 서명
- 인증서는 공개된 위치에 저장해서 요청하는 사람에게 내려보내 줄 수 있는 시스템이 갖춰져 있다. (보통 공인 인증 기관의 LDAP 에 저장)
- 이를 PKI(Public key infrastructure) 라고 한다.

## 인증서의 Root CA
- SSL의 기본 구조는 당신이 인증서를 서명한 사람을 신뢰한다면, 서명된 인증서도 신뢰할 수 있다는 것
- 이것은 마치 트리(Tree)와 같은 구조를 이루면서 인증서끼리 서명하게 된다.
- 인증서를 발행한 기관을 Root Certification Authority(Root CA)라고 부르며, 널리 알려진 인증 기관(Verisign, Thawte, Entrust 등)의 Root CA 인증서는 웹브라우저에 기본적으로 설치되어 있다.
- Root CA의 인증서는 누가 서명을 했을까? 모든 Root CA 인증서는 자체 서명(Self Signed)되어 있다.
- 여기서 서명이란 신뢰할 수 있다고 서명하는 것을 뜻함.

## 정리
 * Q: SSL 이란?
 * A: 데이터를 암호화 해서 주고 받는 것
 * 
 * Q: SSL은 어떤 키를 사용?
 * A: 실제 암호문을 주고받는 것은 양쪽이 같은 대칭키를 사용 (대칭키를 전송하기 위한 공개키를 사용과 햇갈리지 말자)
 * 
 * Q: 대칭키를 전달할 때 위험을 피하는 방법은?
 * A: 사이트의 공개키로 암호화해서 데이터를 전송
 * 
 * Q: 인증기관의 역할은?
 * A: 사이트의 공개키가 신뢰할 수 있는지 보증하는 역할
 * A: 인증기관의 개인키로 사이트의 공개키를 전자서명과 함께 암호화 = 인증서 (이는 인증기관의 공개키로만 풀 수 있기 때문에 인증기관에서 발급한 인증서가 신뢰할 수 있다고 판단할 수 있다.)
 * 
 * Q: 인증서란?
 * A: 사이트의 공개키와 사이트 정보(전자서명 등)을 인증기관 개인키로 암호화한 파일에 불과하다.
 
# 쿠키와 세션의 차이

# 쿠키
- 쿠키란 서버측에서 클라이언트측에 상태 정보를 저장하고 추출할 수 있는 메커니즘
- 클라이언트의 매 요청마다 웹 브라우저로부터 서버에게 전송되는 정보패킷의 일종
- HTTP에서 클라이언트의 상태 정보를 클라이언트의 하드 디스크에 저장하였다가 필요 시 정보를 참조하거나 재사용할 수 있음.
 
## 쿠키의 원리
- 클라이언트가 브라우저를 통하여 웹페이지 접속(Web Server) -> 클라이언트가 요청한 웹 페이지(HTTP)를 전송하면서 쿠키설정(클라이언트의 상태정보 하드디스크 저장) -> 클라이언트 재 방문시 웹페이지 요청과 함께 쿠키값도 같이 전송

## 예제
-  방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
- 팝업에서 “오늘 이 창을 다시 보지 않음” 체크

## 쿠키의 제약 조건
- 클라이언트에 총 300개까지 쿠키를 저장할 수 있다
- - 하나의 도메인 당 20개의 값만을 가질 수 있다
- 하나의 쿠키 값은 4096Byte까지 저장 가능하다
- [주의]하나의 도메인에서 설정한 쿠키값이 20개를 초과하면 가장 적게 사용된 쿠키부터 지워짐. 또한 쿠키는 기존에 설정한 값이 있는 곳에 값을 저장하거나 배열형태의 쿠키에 단일 값을 저장하려고 할 때 아무런 경고 없이 덮어쓰기 때문에 주의를 해야 한다.

# 세션이란?
- 세션이란 클라이언트와 웹서버 간에 네트워크 연결이 지속적으로 유지되고 있는 상태를 말함
- HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속시마다 새로운 네트워크 연결이 이루어진다.
- -클라이언트가 웹서버에 요청하여 처음 접속하면 JSP(혹은ASP)엔진은 요청한 클라이언트에 대하여 유일한 ID를 부여하게 되는데, 이 ID를 세션이라 부른다.
- 이 ID는 쿠키를 사용하여 유지되며, 이 쿠키의 이름이 JSESSIONID 입니다. 서버는 JSESSIONID를 웹 브라우저에 전달하고, 클라이언트는 새로운 접속시 쿠키를 통해서 세션 ID값을 서버에 전달한다
- -세션 ID를 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 구분할 수 있는 유일한 수단이 된다
 
# 세션의 장점
- 각각의 클라이언트마다 고유의 ID 부여
- 세션 객체마다 저장해 둔 데이터를 이용하여 서로 다른 클라이언트의 요구에 맞게 서비스 제공
- 클라이언트 자신만의 고유한 페이지를 열어놓아서 생길 수 있는 보안상의 문제 해결 용이
 
## 쿠키와 세션의 차이점
- 쿠키(cookie)와 세션(session)은 기능상 비슷한 역할을 하고, 동작원리도 비슷하다. 왜냐하면, 일반적인 세션은 쿠키를 바탕으로 동작하기 때문이다. 그러나 가장 중요한 차이점은 저장되는 곳이 다르다는 것이다. 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다. 쿠키의 경우에는 서버의 자원을 전혀 사용하지 않지만, 세션의 경우에는 서버에 저장되기 때문에 서버의 자원을 사용할 수가 있다.쿠키와 세션의 만료 되는 기간도 다르다.

# CSS
## 우선순위
- css가 제일 우선순위가 높다.
- id가 class보다 우선순위가 높다.

## id 와 class 의 차이점

- id는 한페이지에 하나의 정의(style/css)로 하나의 태그(id="")만 사용할 수 있다. 즉 로고, 상단메뉴, 하단정보 같은 스타일을 정의할 때 id를 사용한다
- class는 한페이지에 반복적으로 사용되는 스타일을 정의할 수 있다.
- 반복적으로 사용되는 스타일에는 class를 이용하여 정의하고, 그 내부에 세부 스타일을 정의할 때 id를 사용해주면 효과적이다.

# block과 inline 차이
## inline
-  width/height 적용 불가
- margin/padding-top/bottom 적용 불가
- line-height 원하는 대로 적용 불가(span에 적용안되고 감싸고 있는 div 전체 크기에만 영향 등)


## block
- 반면 block은 무조건 한줄을 점유하고, 다음 태그는 다음 줄로 가버리죠.
- width/height 적용 가능
- margin/padding-top/bottom 적용 가능
- line-height 적용 가능
- 다만 고려해야 할 것이 있습니다.
- inline-block 끼리 공백이 생기게 되는데, 이때는 상위 div에 { font-size: 0; } 를 적용하면 해결이 됩니다.
- inline-block 끼리 높이가 안맞을시 상위 공백이 생기는데, 이때는 { vertical-align: ---; } 값으로 top 등을 줘서 맞춰주시면 됩니다. 
- 디테일한 보정이 필요하고 예민하신 분들은 inline-block 쓰시는게 낫고,
text 내의 특정 부분 스타일 등 간단한 것들은 그냥 inline 쓰시면 됩니다.







# font-family
- 파이썬 라이브러리에서 이미지의 한글 인식 위한 것.

# form
## action
- <form action="#"> </form>; 자기 자신 문서를 의미



# 자바스크립트
## null
- null 객체라고 함.
- ⎼str 변수의 내용을 검사하여 “”을 출력하고 null을 할당하는 것 보다 웹에서는 “”을 할당하는 것을 권장한다


## script
- head나 body 어디든 적어도 되나 특수한 경우엔 어떤 것에만 놓아야 하는 경우가 있음.


# document
## getElementById
- document.getElementById: id에 따라 찾기
- 만약 해당하는 id 를 가진 태그가없을경우 null 에러가 발생한다.


## getElementsByTagName() 함수 , 

- 이 함수는 태그의 있는 div, li, p 와 같은 특정 태그명을 가지고 있는 element 의 집합을 가져오는 함수이다.
- 따라서 반환되는 값은 HTML컬렉션 객체이며 for문 등을 사용하여 element 객체를 사용할수있다.

##  getElementsByClassName() 
- 이 함수는 태그의 class="" 속성을 사용하여 접근한다.

- 동일한 class명이 존재할수 있기때문에  ( id속성은 html 문서에 동일한 id속성이 존재하면 안된다..) 

- id 속성을 사용하여 접근하는 getElementById() 와 달리 getElementsByClassName() 은 컬렉션 객체를 반환한다.

- 따라서 for문을 사용하거나 특정 index에 위치한 element를 반환받아 사용할수있다. 사용예는 아래와 같다.


## innerHTML
- innerHTML 을 사용하면 HTML 문서안에는 태그의 내용을 가져오거나 변경할수있다.
- sample.innerHTML = "bye"


## write()
- document.write()는 문서안의 텍스트 또는 연산된 숫자를 넣을수있다.

## console.log
- console.log는 말그대로 콘솔에 로그를 남길때 사용하는데, 콘솔은 개발자모드(F12) 에서 확인할수있다. 주로 디버깅용도로 사용한다.

# Tern
- 웹 단축키; 매번 configure 가서 설정해 주어야 함.

# 타입
## 기본 타입
- 숫자
- 모든 숫자를 64bit 부동 소수점 형태로 저장하며 정수와 실수의 구분이 없다 
- 문자열
- 불린값
- undefined
- null

## 참조타입
- 객체
- 배열
- 함수
- 정규표현식

# 속성값
- 객체, 함수, 메소드 기능 포함

# 따옴표
- R: 큰 따옴표
- 자바 스크립트: 큰 따옴표
- 파이썬: 작은 따옴표; 
- 제이슨: 큰 따옴표

## ==
- ⎼동등 연산자는 1 == "1" 은 두 피연산자의 타입이 다르므로 같은 타입으로 변환해서 두 값이 같다고 판단해서 document 객체의 write 메서드로 true를 출력한다.  
- ⎼동등 연산자의 비교는 타입변환에 따른 결과를 얻을 수 있으므로 대부분의 자바 스크립트 코딩 가이드에서 동등 연산자로 비교하는 것을 추천하지 않는다. 

## ===  Strict Equal Operator
- a = 1;  b=”1”;  브라우저에서 같은값으로 인식 가능;  ==으로하면 같은값 인식
-  10 : document.write(a === b); ⎼일치 연산자는 1 === "1" 은 두 피연산자의 타입이 다르므로 document 객체의 write 메서드로 false를 출력한다.
- 값과 타입 둘다 비교

### undefined와 null 의 비교 
- undefined == null => true
- undefined === null => false


## 크롤링
- R, 자바 스크립트, 제이슨

## typeof
- typeof는 unary 오퍼레이터이다. unary 오퍼레이터로는 ! 라던가 - 등과 같이 인자를 하나만 받을 수 있는 연산자를 뜻한다. 즉, 함수가 아니고 연산자이기 때문에 괄호를 사용하면 안된다.

### null 확인법
- 자바 스크립트는 null이라는 객체이다.
- if(typeof yourVariable === 'object') { /* 오브젝트 처리 */}
- 하지만 위와 같이 하게 되면 만약 yourVariable이 null이라면 결과가 true로 나타난다. 따라서 null인 경우 false의 결과를 나타내고 싶다면,
- if(yourVariable != null && typeof yourVariable === 'object') {/*오브젝트 처리*/} 
- if(!!yourVariable && typeof yourVariable === 'object') {/*오브젝트 처리*/}


## instance of
- : instanceof 는 비교 연산자로 >,<,== 와 같이 두개의 인자를 받는 연산자로 앞의 비교 연산자들을 이용하는 기분으로 사용하면 된다. 하지만 결과로 리턴하는 것은 typeof와는 성질이 조금 다르다. instanceof는 해당하는 변수가 사용하고 있는 prototype의 chain을 2번째 인자와 쭉 비교해서 true/false 값을 리턴한다.
- 쉬운말로 하자면, 해당하는 변수의 클래스와 비교해서 리턴해주는, java에서 많이 쓰던것과 비슷하다고 볼 수 있다.
- 자바스크립트는 instanceof 연산자가 존재한다. 이 연산자는 생성된 인스턴스 객체가 어떤 생성자 함수를 사용하여 생성되었는지 확인하고 불리언값으로 반환하여 주는 유용한 연산자이다. 이 연산자를 사용해 생성자 함수를 확인하는 과정을 예제를 통하여 알아보고자 한다.


# 연산자
- 쉬프트연산자는 산술연산자보다 우선순위는 나르지만 계산 속도가 더 빠르다.
- 비트 연산자도 관계예산자보다 우선순위는 낮지만 속도가 더 빠르다.
# 객체 표기법
- 파이썬에서는 딕셔너리, 자바에서는 맵이라고 표현
- 객체 표기법 - 제이슨
- 몽고디비, 카산드라는 객체표기법 사용

## 예제
- var person = 
- {
- 		fname : "홍", 
- 		lname : "길동",
- 		age : 25
- };


# 배열리스트  []
- 자바에서는 리스트, 파이썬에서는 리스트라고 함.


# for문

## for in 반복문과 for of 반복문의 차이점
- for in 반복문 : 객체의 모든 열거 가능한 속성에 대해 반복
- for of 반복문 : [Symbol.iterator] 속성을 가지는 컬렉션 전용; 인덱스로 접근 가능
- for...in iterates over the enumerable properties of an object
- for...of iterates over the property values of objects
- basic for문과 for in은 반복변수에 index를 리턴하지만 forEach 와 for of 는 해당 값을 리턴하기 때문이죠.
- forEach는 위와같이 callback 함수가 필요합니다. 굳이 이걸 쓸 필요 없이 같은 기능을 하기 위해 나온것이 for of이죠.
- for ... of 문은 반복가능한 객체(Array, Map, Set, String, TypeArray, arguments 객체등)를 반복하는 문법입니다.





## for in
- for(var i = 0; i < array.length; i++){
-       alert(array[i]);
-    }

위와 아래 같은 역할 

- for(var i in array){
-       alert(array[i]);
-    }


# 함수
- 반복해서 호출해서 사용할 수가 있다.
- 메소드는 복제 기능이 없다(= 객체를 통해서 사용하는 것이 없다)
- 함수는 복제, 메소드는 상속을 통해 재사용성을 가진다.
- // 변수나 함수는 동급이다. 둘 다 객체다.
- // 변수는 정적 객체고 함수나 메소드는 동적 객체다.
- 같은 객체이기 때문에 함수를 변수에 복제 가능(프로토 타입)
	- 정적 객체지만 속성은 동적 객체를 가질 수 있음.


## 변수에 함수 복제
- 매개변수에 들어가기 위해서 변수에 복제
- function sot() {
	
- document.write("함소 호출");
- }

- var minsot = sot;

- minsot(); 

## 정적 객체에 동적 객체 바로 할당
- 매개변수에 들어가기 위해서 변수에 복제
- var minsot1 = function sot() {
	
- document.write("함소 호출");
- }

## 정적 객체에 동적 객체 바로 할당 2
- 매개변수에 들어가기 위해서 변수에 복제
- var sot = function sot() {
	
- document.write("함소 호출");
- }
- sot(); // 정적 객체와 동적 객체의 래퍼런스가 다르기 때문에 같은 이름 대입 가능
