# 커널
```java
커널의 역할
 * 커널은 운영 체제의 핵심 부분이므로, 커널의 역할 역시 운영 체제의 핵심 역할이라 할 수 있다.
 * 하드웨어의 자원을 자원이 필요한 프로세스에 나눠주고, 덩달아 프로세스 제어(태스크 매니저), 메모리 제어, 프로그램이 
 운영체제에 요구하는 시스템 콜 등을 수행하는 부분으로 운영체제 맨 하부에서 돌아간다. 

보안
커널은 컴퓨터 하드웨어와 프로세스의 보안을 책임진다.

자원 관리
한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당하는 것을 스케줄링이라 한다.

추상화
같은 종류의 부품에 대해 다양한 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 문제를 매우 복잡하게 만들 수 있다.
일반적으로 커널은 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 몇 가지 하드웨어 추상화
(같은 종류의 장비에 대한 공통 명령어의 집합)들로 구현된다. 이 하드웨어 추상화는 프로그래머가 여러 장비에서 작동하는 프로그램을 개발하는 
것을 돕는다. 하드웨어 추상화 계층(HAL)은 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의지한다.


초기의 커널
초창기의 컴퓨터에서 운영 체제 커널은 필수적인 것이 아니었다. 초기의 프로그램은 하드웨어 추상화나 운영 체제의 지원을 받지 않고도 컴퓨터만으로 
불러들인 다음 실행될 수 있었으며, 이것은 초창기 컴퓨터들의 일반적인 운영 방식이었다. 다른 프로그램을 실행하기 위해서는 컴퓨터의 전원을 껐다가
켬으로써 다시 입력자료를 읽어들여야 하는 방식이었다. 이러한 과정이 반복되면서 사람들은 로더와 디버거 같은 작은 프로그램들이 상주해 있는 것이,
다른 프로그램으로 교체하거나 새로운 프로그램을 개발하는 데 유리하다는 사실을 알게 되었다. 이와 같은 로더, 디버거들이 초기 운영 체제 커널의 기초가 되었다.



종류

단일형 커널(monolithic kernel) - 커널의 다양한 서비스 및 높은 수준의 하드웨어 추상화를 하나의 덩어리(주소 공간)로 묶은 것이다. 
운영 체제 개발자 입장에서 유지 보수가 일반적으로 더 어려우나 성능이 좋다.

마이크로커널(microkernel) - 하드웨어 추상화에 대한 간결한 작은 집합을 제공하고 더 많은 기능은 서버라고 불리는 응용 소프트웨어를 통해 제공한다.

혼합형 커널(hybrid kernel) - 성능 향상을 위해 추가적인 코드를 커널 공간에 넣은 점을 제외하면 많은 부분은 순수 마이크로커널과 비슷하다. 
수정 마이크로커널이라고도 한다.

나노커널(nanokernel) - 실질적으로 모든 서비스를 책임진다.

엑소커널(exokernel) - 낮은 수준의 하드웨어 접근을 위한 최소한의 추상화를 제공한다. 전형적으로 엑소커널 시스템에서는 커널이 아닌 
라이브러리가 단일형 커널 수준의 추상을 제공한다.
```

# [blockDMask](https://blockdmask.tistory.com/69)
```java
1. 커널이란?

위키피디아 에서 정의하길  
"컴퓨터 과학에서 커널(Kernel)은 운영체제의 핵심 부분으로서, 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러가시 서비스를 제공한다."
라고 정의 되어있습니다. 
제가 말하고 싶은 것은, "운영체제의 중요한 부분"이다. 라는것 입니다.

커널의 역할은 세가지가 있습니다.
보안, 자원관리, 추상화
제가 학교에서 중점으로 배운것은 커널의 자원관리 였습니다.

컴퓨터의 자원(resource) 이라는것은 CPU, 메모리, 가상메모리, 뭐 키보드 마우스 등 과 추상적으로는 쓰레드, 패킷, 프로토콜, 테스크 를 말합니다.
간단히 말해서 컴퓨터 내부의 모든?(거의대부분?)의 것이라고 생각하면 됩니다.
운영체제의 커널은 이러한 자원을 효율적으로 관리하기위해서 CPU 스케줄링, 메모리관리, 입출력관리, 파일시스템 관리 등의 업무를 수행합니다.
2. 디바이스 드라이버란?

위키피디아에서 정의하길
"특정 하드웨어나 장치를 제어하기 위한 커널의 일부분으로 동작하는 프로그램이다. 컴퓨터를 구성하는 다양한 입출력 장치마다 각각 장치 드라이버가 
프로그램 커널에 통합되어 실행된다."
라고 정의 되어있습니다.

쉽게 이야기하면, 우리가 쓰는 모든 입출력장치(블루투스 키보드, 유선 모니터, 마우스, 복합기 등)와 컴퓨터(OS)가 서로 알아들을 수 있게 통역해주는
역할이라고 말할 수 있습니다.

조금 어렵게 이야기하면, 컴퓨터의 버스나 통신 시스템을 이용하여 하드웨어와 커널 사이에서 명령어나 데이터를 전달해주는 역할을 합니다.

이러한 디바이스 드라이버는 장치에 의존적(장치마다 작동하는게 다 다름)이기 때문에 각각 장치마다 장치 드라이버가 존재합니다.
USB 같은 경우에는 통합 드라이버가 존재하여서, winOS에서 제공해주고 있습니다.

예전에 (저는 91년생) 90년대 2000년대 제가 윈도우 95 98을 사용했을때에 프린터기를 사면 그에 따른 장치 드라이버 CD를 줬습니다. 
그래서 그 드라이버를 설치하지 않으면, 컴퓨터가 프린터기를 인식하지 못했었습니다. 이처럼 새로운 하드웨어와 OS는 서로 만난 적이 없기때문에
중간에 처리를 해주는 놈(디바이스 드라이버)이 필요합니다.
+(유저모드에서 돌아가는 드라이버도 있습니다)

 

3. 유저모드와 커널모드란.

커널에서 중요한 자원을 관리하기 때문에, 사용자가 그 중요한 자원에 접근하지 못하도록 모드를 2가지로 나눈 것입니다.

유저모드
: 유저(사용자)가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 침범하지 못하는 모드 입니다.
: 우리는 여기서 코드를 작성하고, 프로세스를 실행하는 등의 행동을 할 수 있습니다.
: 간단하게 유저 어플리케이션 코드가 유저모드에서 실행된다. 라고 말할 수 있습니다.
커널모드
: 모든 자원(드라이버, 메모리, CPU 등)에 접근, 명령을 할 수 있습니다. 
: 유저모드와는 비교가 안되게 컴퓨터 내부에서 모든 짓? 을 할 수 있다고 생각하면 되겠습니다
4. 유저모드와 커널모드의 전환.

프로세스가 실행되는 동안에 프로세스는 수없이 유저모드와 커널모드를 왔다갔다 하면서 실행이 됩니다.

(유저모드 -> 커널모드 요청)
프로세스가 유저모드에서 실행되다가 특별한 요청이 필요할때 system call을 이용해서 커널에 요청을 합니다. 

(커널모드 -> 유저모드로 반환)
system call의 요청을 받은 커널이 그 요청에 대한 일을 하고 결과값을 system call의 리턴 값으로 전해줍니다.

예를 들어 프로세스가 실행되고있는 중에 라이브러리 함수인 fopen함수를 호출했다고 가정해보겠습니다.
그렇게되면 fopen 내부에서 system call인 open을 호출하면서 커널모드로 넘어갑니다.
open에 대한 입력값이 커널로 전달이 되고 해당 일을 완료하고 커널에서 return을 해주면서 유저모드로 돌아가게됩니다.

이해를 돕기위해 오늘도 그림을 그려보았습니다.
핑크색 형광팬을 친 흐름으로 돌아가게됩니다. 저런흐름이 수없이 반복되면서 프로세스가 실행이됩니다.


 

5. 전체적인 흐름.

지금까지 설명한 것을 그림으로 나타내 보겠습니다.


흐름1) 유저모드에서 실행되고 있는 유저 어플리케이션에서 시스템콜이나 라이브러리 함수를 통해서 I/O 요청
-> 커널 모드로 전환.  커널의 I/O 관리자가 키보드나 모니터의 장치드라이버에 요청
-> 장치드라이버에서 키보드나 모니터에서 받은 return 값을 커널에 return
-> 커널은 해당 값을 user application으로 return
-> 유저모드로 전환.
흐름2) 유저모드에서 C언어로 작업중 malloc 를 통해서 메모리 할당을 받으려고 system call 호출
-> 커널 모드로 전환. 메모리 [관리 할당 or 잘못된 접근] return값을 user application으로 전달
-> 유저모드로 전환.
```

## CPU 명령  @커널
* CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다. 일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다.  이러한 일반 명령은 모든 프로그램이 수행할 수 있는 명령이다. 특권 명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다. 컴퓨터 시스템에서는 CPU내에 모드 비트를 두어 특권 명령을 항상 OS만이 수행할 수 있도록 제한하고 있다.

# 시스템 콜  @ 특권명령
 * 사용자 프로그램이 특권 명령의 수행이 필요한 경우 OS에게 특권 명령의 대행을 요청한다.이와 같은 서비스 요청을 시스템 콜이라고 한다.
 * 사용자 프로그램이 시스템 콜을 하게 되면 OS는 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.
 * 프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다.
 * CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 
 * 주변 장치의 상태를 지속적으로 파악할 수 없다. 
 * 따라서, 주변 장치는 CPU의 도움이 필요한 경우 인터럽트를 사용해 CPU에게 서비스를 요청하게 된다.
 * 인터럽트를 발생시키기 위해 주변 장치는 인터럽트 라인을 세팅하고 CPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 있는지 체크한다.
 * 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.

```java
시스템 콜의 이해

- 사용자 프로세스가 소프트웨어 인터럽트를 통해 커널의 기능을 이용하기 위한 서비시를 요청하는 하나의 방법


처리방식
- 사용자 프로세스가 시스템 콜을 요청하면 제어가 커널로 넘어옴(사용자 모드 -> 커널 모드)

- 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 기능별로 고유번호를 할당하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의

- 커널은 요청받은 시스템 콜에 대응하는 기능번호를 확인

- 커널은 그 번호에 맞는 서비스 루틴을 호출

- 서비스 루틴을 모두 처리하고 나면 커널 모드에서 사용자 모드로 다시 전환



시스템 콜의 종류

- 프로세스 제어
끝내기(end), 중지(abort)
적재(load), 실행(execute)
프로세스 생성(create process)
프로세스 속성 획득과 설정(get process attribute and set process attribute)
시간 대기(wait time)
사건 대기(wait event)
사건을 알림(signal event)
메모리 할당 및 해제 : malloc, free


- 파일 조작
파일 생성(create file), 파일 삭제(delete file)
열기(open), 닫기(close)
읽기(read), 쓰기(write), 위치 변경(reposition)
파일 속성 획득 및 설정(get file attribute and set file attribute)


- 장치 관리
장치를 요구(request devices), 장치를 방출release device)
읽기, 쓰기, 위치 변경
장치 속성 획득, 장치 속성 설정
장치의 논리적 부착(attach) 또는 분리(detach)


- 시스템 정보 및 자원 관리
시간과 날짜의 설정과 획득(time)
시스템 데이터의 설정과 획득(date)
프로세스 파일, 장치 속성의 획득 및 설정

- 통신 관련
통신 연결의 생성, 제거
메시지의 송신, 수신
상태 정보 전달
원격 장치의 부착 및 분리

2.4.5 통신에 대해 부가적인 내용을 추가한다.
일반적인 통신 모델에는 메시지 전달과 공유 메모리 두가지 가 있다.
메시지 전달 모델에서는 두 프로세스의 통신에 정보 교환을 위한 메시지를 주고 받는다. 
공유 메모리 모델에서는 다른 프로세스가 소유한 메모리에 접근을 위해 특정 시스템 콜을 호출한다. 
일반적으로 운영체제는 서로 다른 프로세스간의 메모리 접근을 차단한다. 
공유 메모리 기법을 사용하기 위해서는 통신하려는 프로세스들이 이러한 차단을 풀어주는데 동의해야한다.


시스템 콜 처리과정

- 사용자 프로세스 -> 시스템 콜 -> libc.a -> 0x80 인터럽트 발생 -> 커널에서 처리
```
## 매개변수를 운영체제에 전달
* 필요한 기능이나 시스템 환경에 따라 시스템 콜이 발생할 때 좀 더 많은 정보가 필요할 수 있다. 그러한 정보가 담긴 매개변수를 운영체제에 전달하기 위해서는 대략 3가지 정도의 방법이 있다.
  1. 매개변수를 CPU 레지스터 내에 전달한다. 이 경우에 매개변수의 갯수가 CPU 내의 총 레지스터 개수보다 많을 수 있다.
  2. 위와 같은 경우에 매개변수를 메모리에 저장하고 메모리의 주소가 레지스터에 전달된다. (아래 그림 참고)
  3. 매개변수는 프로그램에 의해 스택(stack)으로 전달(push) 될 수도 있다.
 
## 프로그램의 실행
 * “프로그램이 실행되고 있다”는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 갖는다.
 * 첫째는 디스크에 존재하던 실행 파일이 메모리에 적재됨을 의미한다.
 * 두 번째는 프로그램이 CPU를 할당받고 기계 명령을 수행하고 있는 상태를 의미한다.
 * 일반적인 컴퓨터 시스템의 경우 CPU는 하나밖에 없으므로 매 시점 CPU에서 명령을 수행하는 프로그램은 하나뿐이다. 하지만, 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 쓰고, 이들 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로 여러 프로그램이 동시에 실행된다는 말을 보편적으로 사용하는 것이다.
 * 실행 파일이 메모리에 적재될 때 실행 파일 전체가 메모리에 한꺼번에 올라가기보다는 일부분만 메모리에 올라가고 나머지는 디스크의 특정 영역에 내려가 있는 것이 일반적이다. 이는 여러 프로그램이 공유하는 메모리 공간을 효율적으로 사용하기 위한 방법이다.
 * 프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고 
 * 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 스왑 영역에 내려놓는 방식으로 운영된다.
 * 프로세스의 주소 공간은 코드, 데이터, 스택 등으로 구성된다.  각각의 프로그램마다 이러한 주소 공간을 별도로 가지며,  각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 가상 메모리 또는 논리적 메모리라 부른다.

## OS의 메모리
* OS도 하나의 프로그램이므로 OS 커널 역시 코드,데이터,스택의 주소 공간 구성을 갖는다.
 * 커널의 코드
     * OS의 기능 : 아랫단의 HW 자원을 효율적으로 관리하는 일 + 윗단의 응용 프로그램 및 사용자에게 편리한 서비스 제공
     * CPU, 메모리 등의 자원을 관리하기 위한 부분 + 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이룬다.
     * 이 밖에도 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다.
 * 커널의 데이터 영역
     * 각종 자원을 관리하기 위한 자료 구조가 저장된다.
     * CPU, 메모리와 같은 HW 자원을 관리하기 위한 자료 구조뿐만 아니라 
     * 현재 수행중인 프로그램을 관리하기 위한 자료 구조도 커널의 데이터 영역에 유지된다.
     * 이 때, 현재 수행중인 프로그램을 프로세스라고 부른다.
     * 각 프로세스의 상태, CPU사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조 PCB가 존재한다.
     * 즉, HW + SW를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료 구조를 각각 유지한다
 * 커널의 스택 영역
     * 함수 호출시 복귀 주소를 저장하기 위한 용도로 사용된다.
     * 커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다.
     * 즉, 프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 커널의 주소 공간에 존재하는 커널 스택을 사용하게 된다.

### Q. 프로세스마다 별도의 스택을 두는 이유
 * 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 
 * 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간이 필요하기 때문이다.
 * 또한, 커널은 일종은 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근 할 수 있으므로  일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 된다.

## 사용자 프로그램의 사용 함수  @ 시스템 콜 등 커널 내의 함수
 * 프로그램이 사용하는 함수는 크게 1. 사용자 정의 함수와 2. 라이브러리 함수, 3. 커널 함수 세 가지로 구분할 수 있다.
 * 사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다.
 * 라이브러리 함수란 누군가가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.
 * 사용자 정의 함수와 라이브러리 함수는 모두 컴파일하여 실행 파일을 만들게 되면 프로그램의 코드 부분에 기계어 명령 형태로 삽입된다. 
 * 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 
 * 또한, 함수 호출시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.
 * 한편 커널 함수는 OS 커널의 정의된 함수를 뜻한다.
 * 커널 함수의 종류에는 사용자 프로그램이 OS의 서비스를 요청하기 위한 시스템 콜 함수와 HW / SW가 CPU의 서비스를 요청하기 위한 인터럽트 처리 함수가 있다.
 * 이와 같은 커널 함수는 OS 커널의 주소 공간에 코드가 정의된다. 
 * 즉, OS 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.


## 인터럽트  @ 인터럽트 처리 함수
 * 인터럽트와 꽌련된 주요 용어로는 인터럽트 벡터와 인터럽트 핸들러가 있다.

### 인터럽트 벡터
 * 여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.
 * 일종의 함수를 가리키는 포인터라고도 할 수 있다.

### 인터럽트 핸들러
 * 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부른다.
 * OS 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 
 * 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 부른다.

## 시스템 콜 @ 인터럽트 라인
 * 컴퓨터 시스템에서는 HW 및 SW 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다.
 * 사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다 보면, 입출력 등 특권 명령을 수행해야 할 필요가 있다. 
 * 이 경우 사용자가 프로그램은 OS에게 시스템 콜을 통해 특권 명령의 대행을 요청하게 된다. 
 * 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다. 
 * 이 때 하드웨어적으로 모드 비트가 1에서 0으로 자동 세팅되기 때문에 OS는 특권 명령을 수행할 수 있다.
 * 모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며, 
 * 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다. 
 * 그러나 시스템 콜은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것이다. 
 * 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문이다.
 * 시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용한다. 
 * 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.

### 중요
 * 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다. 
*  시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용한다. 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.

## CPU 선점
 * 어떤 프로그램이 CPU를 할당받고 명령을 수행하다 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우가 있다.

1. 타이머에 의해 인터럽트 발생
 * 특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 하드웨어로 
 * CPU 할당 시간이 만료되면 인터럽트를 발생시킨다.
 * 이러한 는 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템의 구현을 위한 필수적인 요소이다.
 
 2. 입출력 요청을 위한 시스템 콜
 * 오래 걸리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 
 * 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이양하게 된다.
 * 입출력을 요청했던 프로세스는 입출력 요청이 완료되어 컨트롤러가 인터럽트를 발생시킨 시점부터 
 * 다시 CPU를 얻을 수 있는 기회가 생기며 CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다.

