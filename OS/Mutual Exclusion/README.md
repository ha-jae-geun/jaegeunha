# 문제
```java
51. 모니터에 대한 설명으로 옳지 않은 것은?  4번
① 모니터의 경계에서 상호배제가 시행된다.
② 자료 추상화와 정보은폐 기법을 최초로 한다.
③ 공유 데이터와 이 데이터를 처리하는 프로시저로 구성된다.
④ 모니터 외부에서도 모니터 내의 데이터를 직접 액세스할
수 있다


문 10. 프로세스 동기화 문제를 해결하기 위한 방법인 세
마포어(Semaphore) 알고리즘에 대한 설명으로 옳지 않
은 것은?
1 세마포어 알고리즘은 상호배제 문제를 해결할 수 없
다.
2 세마포어 변수는 일반적으로 실수형 변수를 사용하
지 않는다.
3 세마포어 알고리즘은 P 연산(wait 연산)과 V 연산
(signal 연산)을 사용한다.
4 P 연산과 V 연산의 구현 방법에 따라 바쁜 대기
(busy waiting)를 해결할 수 있다.

답 1
1 세마포어는 임계 구역 내의 공유 자원에 대한 접근을 통제하기
위한 방법으로 상호배제 문제를 해결하기 위한 방법이다.
<오답 체크> 2 세마포어는 일반적으로 정수형 변수를 사용한다.
3 세마포어(semaphore)는 운영 체계 또는 프로그램 처리에서 공
유 자원에 대한 접속을 제어하기 위해 변수를 사용하는 방법이다.
세마포어는 P와 V 두 개의 변수에 의해 작동하며, P는 임계 구
역에 들어가기 전에 수행되고, V는 임계 구역에서 나올 때 수행
된다. 이때 변수 값을 수정하는 연산은 모두 원자성을 만족해야
하며, 한 프로세스(또는 스레드)에서 세마포어 값을 변경하는 동
안 다른 프로세스가 이 값을 변경해서는 안 된다.
4 바쁜 대기(busy waiting)
임계 구역에 진입하기 위해 대기하면서 아무것도 하지 않는 빈
반복문을 계속해서 반복하는데, 아무것도 하지 않음에도 불구하
고 빈 반복문을 반복하기 때문에 계속적으로 문맥 교환이 발생하
며 이로 인하여 처리 효율이 떨어지는 현상이다.
바쁜 대기를 해결하기 위해 모니터나 세마포어 등의 방법을 사용
한다.
```

# 참고자료
* [블로그](http://yimoyimo.tk/OS-process-synchronization-2/)

# Mutual Exclusion
* 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

1. Sw Solutions
* Dekker's algorithm
* Dijkstra's algorithm

2. HW Solutions
* TestAndSet instruction
  * Test와 Set을 한 번에 수행하는 기계어
  
  
3. OS supported solution
* Spinlock
* Semaphore
* Eventcount/Sequencer

4. Language-Level solution
* monitor

# 임계영역
* [블로그](https://dailyheumsi.tistory.com/132?category=855210)
* 공유되는 자원, 즉 동시접근하려고 하는 그 포커싱된 자원!에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역을 임계영역이라고 해요
```java
동기화를 위해, 하나의 프로세스 혹은 쓰레드가 공유 자원에 대한 작업이 완료될 때까지, 
다른 프로세스, 쓰레드의 방해없이 완전하게 완료가 되어야 하는데, 이렇게 진행되는 원칙을 상호배재(Mutual Exclusion) 라고 하고, 
이렇게 수행되는 연산들을 Atomic Operation 이라 한다. 또, 
이렇게 공유자원에 대해 동기화해야하는 코드 부분을 임계 영역(Critical Section) 이라고 한다.

1.3. Critical Section 의 속성
임계 영역의 문제를 해결하기 위해서는 다음을 만족해야 한다.

상호배재 (Mutual Exclusion)
어떤 프로세스가 임계 영역을 실행하고 있을 때, 다른 프로세스는 임계 영역을 실행할 수 없다.
즉, 어떤 프로세스가 임계 영역을 실행할 때, 다른 프로세스는 코드 실행을 못하게 처리해줘야 한다.


진행 (Progress)
임계 영역에 실행되고 있는 프로세스가 없을 경우, 임계 영역을 실행하고자 기다리는 프로세스는 즉각적으로 임계 영역을 실행할 수 있어야 한다. 즉, 기다리고 있는 프로세스들에 대한 처리를 해줘야 한다.


한정 대기 (Bounded Waiting)
임계 영역을 실행하고자 하는 프로세스가 무한정으로 대기하면 안된다. 즉, 제한된 대기시간을 가져야 한다.

```

```java
화장실에 일을 보러 가야 하는데 변기는 혼자서만 사용해야 한다.
그러면 누군가가 사용하고 있다면 다른 사람은 사용할 수 가 없다.
이 때 문을 잠금다면(=Locking) 다른 사람이 들어가고 싶어도 못들어가게(=Waiting) 된다.
안에 있던 사람이 일을 보고 나오면 문을 열고(=Unlocking) 나와야 다른 사람이 들어갈 수 있게 된다.
```

```java
기본적으로 현재 일반 유저가 사용하는 대부분의 OS는 선점형 시분할 운영체제이다.
간단하게 말해서 크롬을 띄우고 메모장을 같이 띄워도 두개다 동작하는 것은 각각 일정 시간동안만 CPU를 선점하여 사용하기 때문이다.

이 때 할당되는 시간 단위를 타임 슬라이스(Time Slice)라고 한다.

일단 여기서 각각의 프로그램은 프로세스라는 단위로 움직인다.
그리고 프로세스 안에서 동작하는 실행 단위인 쓰레드가 존재한다.

크롬으로 스포츠 영상을 보면 크롬이 프로세스가 되고
크롬안에서 영상을 처리해주는 부분과 네트워크로 영상을 받아오는 부분이 각각 쓰레드가 된다.

그런데 프로세스 or 쓰레드가 Wait라는 상태가 걸리는 때가 있다.

이걸 이해하기 위해선 H/W를 살펴볼 필요가 있다.

H/W는 CPU보다 느리다.

그렇기 때문에 디스크에서 데이터를 읽는 작업처럼 느린 동작을 처리하기 위해서 작업이 잠깐 중단될 필요가 생긴다.

그러면 CPU는 디스크에서 데이터를 읽어 달라는 명령을 요청하고 다른 작업을 계속한다. (=Task Switch)
```


# Sw Solutions
* Dekker's algorithm
* Dijkstra's algorithm
*

## 단점
* 속도가 느림
* 구현이 복잡함
* ME primitive 싫행 중 preemption 될 
* Busy Waiting; 비효율적


2. HW solution
* TestAndSet instruction
  * Test와 Set을 한 번에 수행하는 기계어


## 장점
* 구현이 간단

## 단점
* Busy Waiting; 비효율적


# OS supported SW Solution



## 쓰레드 동기화 방법의 종류
* Mutex / Semaphore / Monitor
* 공통점은 세가지 모두 운영체제의 동기화 기법이라는 것이다.


```java
변기가 하나뿐인 화장실에서는 
앞의 사람이 볼일을 마치고 나가야 다음 사람이 들어갈 수 있다. 
이렇게 한번에 오직 하나만 처리할 수 있는 대상에 사용하는 것이 뮤텍스이다. 

변기가 세개인 화장실에서는 동시에 세 사람이 볼일을 볼 수 있고 
이 세 사람 중 아무나 한명이 나오면 다음 사람이 볼일을 볼 수 있다. 
이렇게 동시에 제한된 수의 여러 처리가 가능하면 세마포어이다. 

만약 변기 세개짜리 화장실의 각 변기에 대해 뮤텍스를 사용한다면 
대기중인 사람은 각 변기 앞에 줄을 서는 것이고 
이렇게 되면 옆 칸이 비어도 들어가지 못하게 된다. 

만약 변기 세개를 묶어서 뮤텍스를 사용한다면 
변기 수에 관계없이 무조건 한명만 사용할 수 있게 된다. 

이 예에서 변기는 동기화 대상, 사람은 그 동기화 대상에 접근하는 쓰레드를 나타낸다. 

뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 쓰레드에 의해 사용중일 경우 
다른 쓰레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만 
관리하는 동기화 대상이 몇개 인가에 따라 차이가 생기게 되는 것이다.
```

# Eventcount/Sequencer
* 은행 번호표 뽑기 원리

## 장점
* No Busy wating
* No starvation
* 세마포어보다 더 low-level control


## 쓰레드 동기화 방법의 종류
* Mutex / Semaphore / Monitor
* 공통점은 세가지 모두 운영체제의 동기화 기법이라는 것이다.

### 뮤텍스(Mutual Exclusion)
* 쓰레드의 동시 접근을 허용하지 않는다는 의미.
* 뮤텍스의 쓰레드 동기화 방법은 임계영역에 들어가기 위해 이 뮤텍스를 가지고 있어야 들어갈 수 있다.
* 예) 일종의 자물쇠와 같은 역할을 한다.
* 임계영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올때까지 다른 쓰레드가 못들어오게 내부에서 자물쇠로 잠근다.
```java
MUTual EXclusion으로 상호배제라고도 합니다.
0또는 1의 값을 가지는 이진 세마포어와 유사합니다. Critical Section (임계구역)을 가진 스레드들의 실행 시간을 
서로 겹치지 않게 단독으로 실행하게 하는 기술입니다.
- 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 Locking과 Unlocking을 사용합니다.
- 뮤텍스 객체를 두 스레드가 동시에 사용할 수 없습니다.
```

### 세마포어(Semaphore)
* 세마포어 역시 뮤텍스와 비슷한 역할을 하지만 세마포어는 동시 접근 동기화가 아닌 접근 순서 동기화에 더 관련있다.
* P: Probern: 검사, V: Verhogen(증가)
* 임의의 s 변수 하나에 ready queue 하나가 할당 됨
```java
프로세스간의 시그널(신호, Signal)을 주고받기 위해 사용되는 정수 값, 리소스의 상태를 나타내는 카운터로 세마포어는 다음 세가지 원자적인 연산만을 지원합니다.
- initialize, decrement, increment

- initialize : 세마포어 초기화. (음이 아닌 정수값으로 초기화)

- decrement : 프로세스를 블록시킬 수 있습니다.

- increment : 블록되었던 프로세스를 깨울 수 있습니다. 이 세마포어를 카운팅 세마포어 또는 범용 세마포어라고 합니다.

세마포어의 값에 따라 운영체제는 프로세스가 즉시 자원을 사용할 지, 자원이 다른 프로세스에 의해 사용 중인걸 알게 될 경우엔 일정 시간을 기다려야 합니다.

프로세스가 자원을 사용하는 동안에는 세마포어 값을 변경함으로서 다른 프로세스들이 기다리게 해야합니다.

- 프로세스간 메시지를 전송하거나 공유메모리를 통해 특정 데이터를 공유하게 될 경우 공유 자원에 여러 프로세스가 접근하면서 문제가 발생하게 됩니다.

 + 하나의 프로세스만 자원에 접근 가능하도록 설정할 때 세마포어를 사용합니다.



출처: https://about-myeong.tistory.com/34 [명찌의 포스트잇]
```

### 세마포어 종류
1. Binary semaphore(하나의 스레드가 들어갈 수 있음)
* S가 0과 1 두 종류읙 값만 갖는 경우
* 상호배제나 프로세스 동기화의 목적으로 사용

2. Counting semaphore(하나 이상의 스레드가 들어갈 수 있음)
* S가 0이상의 정수값을 가질 수 있는 경우
* Producer-Consumer 문제 등을 해결하기 위해 사용
	* 생산자 소비 문제
```java
세마포어는 유지할 수 있는 값의 범위에 따라 이진 세마포어와 범용 세마포어(또는 카운팅 세마포어)로 구분됩니다.
위에서 봤던 세마포어를 카운팅 세마포어(counting semaphore) 또는 범용 세마포어(general semaphore) 라고 부릅니다. 세마포어의 초기값이 0이상의 수입니다.

이진 세마포어(binary semaphore) 는 세마포어의 초기 값이 0또는 1만 가질 수 있는 세마포어 입니다. (이후에 알아볼 것이지만 뮤텍스가 이진 
세마포어와 비슷한 것이라 생각하고 계시면 됩니다)

이렇게 세마포어의 초기 값에 따라 범용 세마포어, 이진 세마포어로 나뉘는 것을 공부했습니다.

<참고>
세마포어는 큐에 프로세스들이 여러 개 있을 때 어떤 프로세스부터 깨울지에 따라 강성 세마포어와 약성 세마포어로 나뉩니다. 큐에서 선입선출로 
꺼낸다면 강성 세마포어이며, 프로세스들이 큐에서 제거되는 순서를 특별히 명시하지 않은 세마포어를 약성 세마포어라고 합니다.
```

### 세마포어로 해결 가능한 동기화 문제들
1. 상호배제 문제
2. 프로세스 동기화 문제
3. 생산자 소비자 문제
4. Reader-writer 문제
5. Dining philosopher 문제


```java
P_counting( int count )
   P( countLock )        // Acquire lock to count: countLock <- 0
   count--
   if( count <= 0 )      // If no more threads allowed into critical section
      P( sectionLock )   // Resource full => Acquire section lock: sectionLock <- 0
      V( countLock )     // Release lock to count: countLock <- 1
   else
      V( countLock)

V_counting( int count )
   P( countLock )
   count++
   if( count > 0)        // Release sectionLock if resource is freed up
      V(sectionLock)     // countLock released after sectionLock so that waiting
      V(countLock)       // threads do not jump in when before resource is available
   else
      V(countLock)
```

* [블로그](https://codegym.cc/groups/posts/220-whats-the-difference-between-a-mutex-a-monitor-and-a-semaphore)
# 모니터(Monitor)
* Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다.

## 모니터의 구조
1. 진입 큐: 모니터 내의 procedure 수만큼 존재
2. Mutual exclusion: 모니터 내에는 항상 하나의 프로세스만 진입 가능
3. 정보 은폐: 공유 데이터는 모니터 내의 프로세스만 접근 가능
4. 조건 큐: 모니터 내의 특정 이벤트를 기다리는 프로세스가 대기
5. 신호제공자 큐: 모니터에 항상 하나의 신호제공자 큐가 존재
* signal() 명령을 실행한 프로세스가 임시 대기

## 모니터 장점
* 사용이 쉽다
* Deadlock 등 error 발생 가능성이 낮음

## 모니터 단점
* 지원하는 언어에서만 사용 가능
* 컴파일러가 OS를 이해하고 있어야 함
	* Critical section 접근을 위한 코드 생성

## Synchronized
* Java uses the synchronized keyword to represent a monitor. All the code that appears instead of the synchronized keyword in the last example is the monitor.

### 전자(뮤텍스,모니터)는 상호 배제를 함으로써 임계구역에 하나의 쓰레드만 들어갈 수 있다.
* 후자(세마포어)는 하나의 쓰레드(binary semaphore)만 들어가거나
* 혹은 여러 개의 쓰레드(counting semaphore)가 들어가게 할 수도 있다.


### 전자(뮤텍스,모니터)는 상호 배제를 함으로써 임계구역에 하나의 쓰레드만 들어갈 수 있다.
* 후자(세마포어)는 하나의 쓰레드(binary semaphore)만 들어가거나
* 혹은 여러 개의 쓰레드(counting semaphore)가 들어가게 할 수도 있다.


### . 뮤텍스와 모니터의 차이는?
* 가장 큰 차이는 뮤텍스는 다른 프로세스(애플리케이션)간에 동기화를 위해 사용한다.
* 반면 모니터는 하나의 프로세스(애플리케이션)내에 다른 쓰레드 간에 동기화할 때 사용한다.
* 또한, 뮤텍스는 보통 운영체제 커널 의해서 제공되는 반면에 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다.
* 따라서 뮤텍스는 무겁고(heavy-weight) 느리며(slower) 모니터는 가볍고(light-weight) 빠르다(faster).


### 락과 뮤텍스 모니터 차이점
```java
Lock은 한 프로세스 내에서 쓰레드 단위로 일어나는거고 Mutex는 Lock이랑 같지만 여러 프로세스끼리 가능하다
Lock은 실제 클래스나 객체가 아닌 컴파일러 키워드인데 Monitor 클래스의 기능을 둘러싼 래퍼이고 Monitor의 작업을 보다 쉽게 수행할 수 있도록 설계되었다
lock-그것은 실제로 Monitor class 에 대한 지름길입니다. 반면에 커널 리소스 할당과 커널 코드로의 전환을 피하려고합니다. 
더 빠름-비슷한 WinAPI 구문을 찾아야하는 경우 CriticalSection )입니다.
다른 차이점은 다른 사람들이 지적한 것입니다. Mutex는 프로세스 전체에서 사용됩니다.
특별한 요구가 있거나 프로세스 간 동기화가 필요한 경우가 아니면 lock (일명 Monitor) ˛를 따르는 것이 좋습니다.

Lock은 잠겨있는 임계 영역에 하나의 스레드만 접근이 가능하며 다른 프로세스와는 공유되지 않는다.

Mutex는 잠겨있는 임계 영역에 하나의 스레드만 접근이 가능하며 잠겨있는 임계 영역을 다른 프로세스와 공유할 수 있다.
```

### 세마포어와 모니터의 차이는?
* Java에서는 모니터를 모든 객체에게 기본적으로 제공하고 있는 반면 C에서는 모니터를 사용할 수 없다.
* 세마포어는 카운터라는 변수값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용 시 매번 값을 따로 지정해줘야하는 등 조금 번거롭다.
* 반면, 모니터는 이러한 일들이 캡슐화 되어 있어서(encapsulation) 개발자는 카운터값을 1 또는 0으로 주어야 하는 고민을 할 필요 없이 synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화할 수 있다.
```java
세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다. 반면에 뮤텍스는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있습니다.
현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다. 하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.
```


### 뮤텍스와 세마포의 차이는?
* 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
* 예를 들어 Casting을 한다고 보면
	* (뮤텍스)세마포어 –> 가능
	* (세마포어)뮤텍스 –> 불가능
* 세마포어는 소유할 수 없는 반면 뮤텍스는 소유할 수 있고 소유자가 이에 책임을 진다
* 뮤텍스는 1개만 동기화가 되지만 세마포어는 하나 이상을 동기화 할 수 있다.


## 뮤텍스와 세마포어 모니터 차이
```java
공통점은 세가지 모두 운영체제의 동기화 기법이라는 것이다.

우선 뮤텍스, 모니터와 세마포어의 차이는 개념적으로 전자(뮤텍스,모니터)는 상호배제를 함으로써 임계구역에 하나의 스레드만 들어갈 
수 있다는 것이고 후자(세마포어)는 하나의 스레드만 들어가게도 할 수 있고 (binary semaphore) 여러개의 스레드가 들어가게 할 수도 있다(counting semaphore).



그럼 뮤텍스와 모니터의 차이는?

가장 큰 차이는 뮤텍스는 다른 프로세스(애플리케이션)간에 동기화할 때 사용할 수 있다는 것이고 모니터는 하나의 프로세스(애플리케이션)
내에 다른 스레드 간에 동기화할 때 사용된다는 것이다. 또한, 뮤텍스는 보통 운영체제 커널,프레임워크,라이브러리에 의해서 제공되는 
반면에 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다. 따라서 뮤텍스는 무겁고(heavy-weight) 느리며(slower) 모니터는 가볍고(light-weight) 빠르다(faster).



세마포어와 모니터의 차이에 대해 좀 더 자세하게 보면?

앞서 세마포어는 binary semaphore 아니라 counting semaphore를 제공하는 반면 모니터는 개념적으로 이진 세마포어만 가능하다고 했다.

둘은 이 차이점만 있는 것이 아니다.

Java에서는 모니터를 모든 객체에게 기본적으로 제공하고 있는 반면 C에서는 모니터를 사용할 수 없다.

또한, 세마포어는 실제로는 카운터라는 변수값으로 프로그래머가 상호배제나 오더링의 목적으로 사용시 매번 값을 따로 지정해줘야하는 
등 조금 번거롭다. 반면,모니터는 이러한 일들이 캡슐화되어있어서(encapsulation) 개발자는 카운터값을 1로 주냐 0으로 주냐 고민할 
필요 없이 synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화할 수 있다.



출처: https://about-myeong.tistory.com/34 [명찌의 포스트잇]
```


# Spinlock

## Sleep 가능한 락
```java
락 중에는 이런식으로 자원에 접근 하는 락이 있다.

앞에서 살펴본 워터파크에는 k명만 입장이 가능하다.

k명에 들어간다면 그냥 입장 가능하겠지만 k명에 해당되지 않는다면 대기자는 그냥 졸면서 기다린다.

그리고 자원을 다 사용한 사람들이 나가면 졸고 있는 사람들을 깨워서 들여보낸다.

이게 바로 세마포어(Semaphore) 개념이다.

세마포어는 보통 자원에 관계된 락이다.

그래서 락을 걸때 특정 수만큼의 카운트를 갖고 빼주는 형식으로 처리된다.

이런 락을 슬립(Sleep)가능한 락이라고 한다.

또한 뮤텍스(Mutex)라는 락이 있는데 이는 Mutualy Exclusive라는 락이다.

결국 이것도 세마포어긴 한데, 특별히 카운트가 1인 락으로 봐도 무방하다.

이와 반대로 스핀락은 자지 않고 게속해서 버틴다고 볼 수 있다
```

## 스핀락은
```java
만약 다른 쓰레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.

조금만 기다리면 바로 쓸 수 있는데 굳이 문맥 교환으로 부하를 줄 필요가 있나? 라는 컨셉으로 개발됐다.

일반적으로 프로세스를 컨트롤 하는 입장에서
Sleep을 시키고 태스크를 스위칭 하는 일련의 작업은 그다지 작은 연산이 아니다.

Sleep된 프로세스를 깨우기 위해선 일단 데이터를 메모리에다가 쓰고 스위칭 작업을 하고 모든 작업이 다 끝났을때 가능하다.

그렇기 때문에 아주 작은 작업에 대해서는 세마포어 or 뮤텍스를 사용하지 않고 스핀락을 사용하는 게 효율적일 수 있다.
```

## 스핀락 주의할 점
```java
예를들어 어떤 숫자를 단순히 +1 해주는데 사용될 락이 있다 생각해보자.
이 경우는 거창하게 문맥 교환을 하면서 구현할 필요가 없다.
잠깐 밖에서 값을 검사해보고 내가 사용가능하면 바로 처리 하도록 하는게 효율적이다.
이 개념이 "스핀락" 개념이다.

그냥 단순히 적절한 시간동안 외부에서 for나 while로 루프를 돌면서 락을 검사하고 처리하게 되는 것이다.
이때 임계 영역은 굉장히 작거나 아주 빨리 처리가 가능할 경우 이런 락을 쓰게 된다. 

대신에 이런 락을 쓰고 있을 때 Sleep을 하게 되면 다른 쪽(쓰레드든, 프로세스든)에서는 
CPU는 사용하고 있는데(=루프가 돌고 있기 때문에) 락을 얻지 못하는 사실상의 데드락 상태에 빠지게 된다.

그래서 스핀락은 이런 특성 때문에 "바쁜 대기 상태(Busy Waiting)"라고도 불린다.
```

```java
임계 구역(Critical Section)에 진입이 불가능할 때 문맥 교환을 하지 않고 루프를 돌면서 재시도를 한다.

스핀락은 운영 체제의 스케줄링 지원을 받지 않기 때문에 해당 쓰레드에 대한 문맥 교환이 일어나지 않는다.

따라서 스핀락은 임계 구역에 짧은 시간 안에 진입할 수 있는 경우에 문맥 교환을 제거할 수 있어 효율적이다.

하지만 스핀락이 오랜 시간을 소요한다면 다른 쓰레드를 실행하지 못하고 대기하게 되며
이 경우 비효율적인 결과를 가져온다.

만약 오래 걸리는 작업에 대해 스핀락을 사용한다면
많은 쓰레드들이 락을 잡으려는 시도를 계속 하게되며
이렇게 되면 CPU 점유율이 엄청나게 올라가게 될 것 이다.
하지만 실질적인 작업은 수행하지 않는다.
```

## spin lock 특징ㅇ
1. Lock을 얻을 수 없다면, 계속해서 Lock을 확인하며 얻을 때까지 기다린다. 이른바 바쁘게 기다리는 Busy Wating이다.
2. 바쁘게 기다린다는 것은 무한 루프를 돌면서 최대한 다른 쓰레드에게 CPU를 양보하지 않는 것이다.
3. Lock이 곧 사용가능해질 경우 컨택스트 스위치를 줄여 CPU의 부담을 덜어준다. 하지만, 만약 어떤 쓰레드가 Lock을 오랫동안 유지한다면 오히려 CPU 시간을 많이 소모할 가능성이 있다.
4. 단일 CPU or 단일 코어인 경우에는 유용하지 않다. 그 이유는 만약 다른 쓰레드가 Lock을 가지고 있고 그 쓰레드가 Lock을 풀어 주려면 싱글 CPU 시스템에서는 어차피 컨택스트 스위치가 일어나야 하기 때문이다.
5. 주의할 점은 스핀락을 잘못 사용하면 CPU 사용률 100%를 만드는 상황이 발생된다.
6. 스핀락은 기본적으로 무한 루프를 돌며 lock을 기다리므로 하나의 쓰레드가 lock을 오랫동안 가지고 있다면, 다른 Blocking된 쓰레드는 Busy Waiting을 하므로 CPU를 쓸데없이 낭비하게 된다.
* 스핀락을 잘 사용하면 문맥 교환을 줄여 효율을 높일 수 있다. 

### 뮤텍스 락 vs 스핀락
* 락을 얻을 수 없을때 쓰레드 슬립 모드로 빠지지 않고 반복문을 계속 돌며 락을 얻으려는 시도를 한다.
* 락이 해제될 때 별도의 쓰레드 문맥교환(Context Switching)에 대한 오버헤드 없이 임계 구역에 접근을 한다.
* 뮤텍스 락의 경우 락이 해제되더라도 운영체제에 의해 쓰레드가 다시 깨어나야하지만 스핀락은 락을 얻을때까지 계속해서 CPU 자원을 점유하므로 CPU를 비효율적으로 낭비할 위험이 있다.
* 그러므로 임계구역 진입을 위한 대기 시간이 짧을 때 사용하는게 바람직하다.




# 멀티 쓰레드
* 쓰레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 힙(Heap) 영역을 이용하여 데이터를 주고받을 수 있다.
* 그렇기 때문에 프로세스 간 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다.
* 심지어 쓰레드의 문맥 교환은 프로세스 문맥 교환과는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
* 따라서 시스템의 처리량이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축된다.


## 쓰레딩의 문제점
* 멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만
* 멀티 쓰레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 쓰레드가 데이터와 힙 영역을 공유하기 때문에
* 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료 구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 그렇기 때문에 멀티쓰레딩 환경에서는 동기화 작업이 필요하다.
* 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다.
* 하지만 이로 인해 병목 현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락(lock)으로 인한 병목 현상을 줄여야 한다.
* 공유 자원이 아닌 부분은 동기화 처리를 할 필요가 없다. 즉, 동기화 처리가 필요한 부분에만 synchronized 키워드를 통해 동기화하는 것이다.
* 불필요한 부분까지 동기화를 할 경우 현재 쓰레드는 락(lock)을 획득한 쓰레드가 종료하기 전까지 대기해야한다. 그렇게 되면 전체 성능에 영향을 미치게 된다.
* 즉 동기화를 하고자 할 때는 메소드 전체를 동기화 할 것인가 아니면 특정 부분만 동기화할 것인지 고민해야 한다.

