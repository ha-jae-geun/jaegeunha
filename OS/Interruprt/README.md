# 문제
```java
31. 인터럽트의 우선순위결정과 가장 관계없는 것은?  1번
① 트랩 방식 ② 폴링 방식
③ 벡터 방식 ④ 데이지 체인 방식


28. 다음 중 타이머에 의한 인터럽트(Interrupt)는?  3
① 프로그램 인터럽트 ② I/O 인터럽트
③ 외부 인터럽트 ④ 머신 체크 인터럽트


26. 인터럽트의 처리 루틴의 순서로 올바른 것은?   4번
ㄱ. 현재 상태 보존
ㄴ. 인터럽트 인식
ㄷ. 요청 인터럽트 서비스로 분기 및 서비스
ㄹ. 사용자 상태 복구 및 재개
① ㄱ → ㄴ → ㄷ → ㄹ
② ㄴ → ㄷ → ㄱ → ㄹ
③ ㄴ → ㄱ → ㄹ → ㄷ
④ ㄴ → ㄱ → ㄷ → ㄹ


28. 인터럽트 우선순위를 결정하는 Polling 방식에 대한 설명으로 옳지 않은 것은? 1번
① 많은 인터럽트 발생 시 처리 시간 및 반응 시간이 매우
빠르다.
② S/W 적으로 CPU가 각 장치 하나하나를 차례로 조사하는
방식이다.
③ 조사 순위가 우선순위가 된다.
④ 모든 인터럽트를 위한 공통의 서비스 루틴을 갖고 있다
```

# [컴퓨터 시스템의 동작 원리](https://goodgid.github.io/OS-How-Computer-Systems-Work/)


# [인터럽트](https://goodgid.github.io/OS-The-Principle-Of-Interrupt/)
## 컴퓨터 시스템의 구조
 * 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 
 * 이 때 프로그램의 주소 영역은 크게 코드,데이터,스택 영역으로 구분된다.
 * 코드영역은 우리가 작성한 프로그램 함수들의 코드가 기계어 명령으로 변환되어 저장되는 부분이다.
 * 데이터 영역은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다.
 * 스택 영역은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다.
 * 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다.
 * 반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 OS 커널 부분에 존재하게 된다.
 * OS는 현재 실행중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다.
    * 예를 들어 A,B 두 개의 프로그램이 현재 수행중이라면  커널 어딘가에 이 두 프로그램을 관리하기 위한 자료 구조가 존재한다.  이 자료 구조를 "프로세스 제어 블록(PCB)"라 부른다.

```java
인터럽트(Interrupt)
 

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나

예외상황이 발생하여 처리가 필요할 경우 CPU에게 알려 처리할 수 있도록 하는 것

 
인터럽트란 사전적 의미로는 '끼어들다', '중단시키다' 정도의 의미를 가진 말로 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 
현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것을 말한다.



인터럽트의 종류
인터럽트의 종류는 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 나뉠 수 있다.


외부 인터럽트
전원 이상 인터럽트(Power fail interrupt) : 말그대로 정전, 파워 이상 등
기계 착오 인터럽트(Machine check interrupt) : CPU의 기능적인 오류
외부 신호 인터럽트(External interrupt)
- 타이머에 의한 인터럽트 : Preemptive개념을 생각하면 된다. 자원이 할당된 시간이 다 끝난 경우
- 키보드로 인터럽트 키를 누른 경우 : 대표적으로 Control + Alt + Delete
- 외부장치로부터 인터럽트 요청이 있는 경우 : I/O 인터럽트 아님!! 다른 개념이다
입출력 인터럽트(I/O Interrupt)
- 입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
- 입출력 데이터에 이상이 있는 경우



내부 인터럽트
잘못된 명령이나 잘못된 데이터를 사용할때 발생하며 Trap이라 부른다.
프로그래 검사 인터럽트(Program check interrupt)
- Division by zero
- Overflow/Underflow
- 기타 Exception
소프트웨어적이 내용이나 분류상 인터럽트가 아니다!


소프트웨어 인터럽트(SVC : SuperVisor Call)
사용자가 프로그램을 실행시키거나 감시프로그램(Supervisor)을 호출하는 동작을 수행하는 경우
소프트웨어 이용중 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 등의 동작이 수행된다.


전원 공급이 이상 → CPU의 기계적인 오류 → 외부 신호에 의한 인터럽트 
→ 입출력 전송 요청 및 전송 완료, 전송 오류 → 프로그램 검사 인터럽트 → 슈퍼바이저 호출(SVC 인터럽트)




인터럽트의 장점
∝ 프로세서(CPU)가 이벤트 발생 여부를 감시(Polling)할 필요가 없다.

        // 감시를 하는 대신 다른 연산을 수행하므로 효율이 높아진다.

 

인터럽트 과정
1. 인터럽트 요청 신호 발생

2. 프로그램 실행 중단

        // 현재 실행중이던 명령어까지 수행

3. 현재 실행중인 프로그램 상태 보관

        // 다음에 실행할 명령어의 번지 보관

4. 인터럽트 처리 루틴 실행
        // 인터럽트를 요청한 장치 식별(식제 인터럽트 작업 아님)

5. 인터럽트 서비스 루틴 처리

        // 인터럽트 원인 파악 및 작업 수행

        // 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1 ~ 5 과정 수행

6. 상태 복구

        // 보관한 PC의 값을 다시 PC에 저장

 

7. 중단된 프로그램 실행 재개

        // PC의 값을 이용하여 수행중이였던 프로그램 계속 실행
        
        
        
                
인터럽트 처리 우선순위 결정 방식
(1) 소프트웨어에 의한 방법(폴링 방식)
① 의미：인터럽트가 발생했을 경우, 각 장치를 우선순위에 따라 차례로 검사(폴링;polling)하여 그 중 가장 우선순위가 높은 장치를 찾고 
이에 해당하는 서비스 루틴을 실행하게 한다.

② 장⋅단점
㉠ 장점：하드웨어 가격 저렴, 인터럽트 우선순위 변경의 유연성
㉡ 단점：처리 시간이 오래 걸림(인터럽트 요청 장치가 많을 경우)


(2) 하드웨어에 의한 방법(데이지 체인 방식)
① 의미：모든 장치를 하드웨어적인 방법으로 우선순위에 따라 직렬로 연결하고 CPU는 인터럽트 확인 신호를 순차적으로 통과시켜 
인터럽트를 요청한 장치로부터 인터럽트 벡터주소(VAD)를 받는다.

② 장⋅단점
㉠ 장점：처리 속도가 빠르다.
㉡ 단점：하드웨어 가격이 고가, 인터럽트 우선순위 변경 유연성이 작다.



인터럽트와 서브루틴
서브루틴의 사용：어떤 프로그램 내에서 특정 처리가 여러 번 실행될 필요가 있을 때, 이를 서브루틴으로 작성하여 프로그램 여러 곳에서 호출하여 사용하도록 한다.
```


## PCB
* 프로그램 A가 수행중에 인터럽트가 발생하면 현재 실행중이던 지점을 A의 프로세스 제어 블록에 저장한 후 인터럽트 처리 루틴으로 가서 인터럽트 발생관련 일 처리를 한다. 인터럽트 처리를 모두 마치면  프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.


## 인터럽트  @ 인터럽트 처리 함수
 * 인터럽트와 꽌련된 주요 용어로는 인터럽트 벡터와 인터럽트 핸들러가 있다.

### 인터럽트 벡터
 * 여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.
 * 일종의 함수를 가리키는 포인터라고도 할 수 있다.

### 인터럽트 핸들러
 * 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부른다.
 * OS 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 
 * 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 부른다.

## 시스템 콜 @ 인터럽트 라인
 * 컴퓨터 시스템에서는 HW 및 SW 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다.
 * 사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다 보면, 입출력 등 특권 명령을 수행해야 할 필요가 있다. 
 * 이 경우 사용자가 프로그램은 OS에게 시스템 콜을 통해 특권 명령의 대행을 요청하게 된다. 
 * 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다. 
 * 이 때 하드웨어적으로 모드 비트가 1에서 0으로 자동 세팅되기 때문에 OS는 특권 명령을 수행할 수 있다.
 * 모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며, 
 * 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다. 
 * 그러나 시스템 콜은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것이다. 
 * 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문이다.
 * 시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용한다. 
 * 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.

### 중요
 * 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다. 
*  시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용한다. 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.

## CPU 선점
 * 어떤 프로그램이 CPU를 할당받고 명령을 수행하다 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우가 있다.

1. 타이머에 의해 인터럽트 발생
 * 특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 하드웨어로 
 * CPU 할당 시간이 만료되면 인터럽트를 발생시킨다.
 * 이러한 는 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템의 구현을 위한 필수적인 요소이다.
 
 2. 입출력 요청을 위한 시스템 콜
 * 오래 걸리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 
 * 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이양하게 된다.
 * 입출력을 요청했던 프로세스는 입출력 요청이 완료되어 컨트롤러가 인터럽트를 발생시킨 시점부터 
 * 다시 CPU를 얻을 수 있는 기회가 생기며 CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다.

# DMA
```java
   다. 메모리 직접 접근 I/O(Direct Memory Access : DMA)    
   - 인터럽트 방식이 프록램에 의한 입출력 방식보다는 효율적이지만 입출력을 위한 상태정보, 
   제어정보, 데이터 전송을 위해서는 여전히 CPU의 능동적인 개입이 요구됨
```
* [DMA](https://github.com/ha-jae-geun/jaegeunha/blob/master/ComputerArchitecture/CPU/DMA/README.md)
