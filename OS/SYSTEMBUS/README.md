# 문제
```java
40. 메모리 버퍼 레지스터(MBR)의 설명으로 옳은 것은? 3번
① 다음에 실행할 명령어의 번지를 기억하는 레지스터
② 현재 실행 중인 명령의 내용을 기억하는 레지스터
③ 기억장치를 출입하는 데이터가 일시적으로 저장되는 레지스터
④ 기억장치를 출입하는 데이터의 번지를 기억하는 레지스터
```

## 시스템버스
* 하드웨어들이 데이터 및 신호를 주고 받는 물리적인 통로
* 프로세스, 메인 메모리, 주변 장치 사이에 통신

### 데이터 버스

### 주소 버스
* PC 레지스터 -> MAR: PC에 저장되니 주소를 프로세서 내부 버스를 이용하여 MAR에 전달한다.
* MAR -> MBR: MAR에 저장된 주소에는 해당하는 메모리 위치에서 명령어를 인출한 후 이 명령어를 MBR에 저장한다. 이 때 제어장치는 메모리에 저장된 내용을 읽도록 제어 신호를 발생시킨다.
 * PC1 -> PC: 다음 명령어를 인출하려고 PC를 증가시킨다.
 * MBR -> IR: MBR에 저장된 내용을 IR에 전달한다.
* pc 레지스터 -> MAR -> 주소 버스 -> 메모리가 어느 주소를 읽어야 되는지 알려줌
  * 동시에 제어 신호를 발생시켜서 제어 신호가 메모리에게 읽어달라고 말하고 주소 명령어가 읽어져서 데이터 버스를 탄다
  * 데이터 버스를 타고 MBR(메모리 버퍼 레지스터)에서 내려서 IR로 가서 다음에 수행할 명령어가 저장됨
  
### 제어 버스
```java
1. PC (Program Counter) : 기억장치로부터 읽혀질 다음 명령어의 주소를 저장

2. MBR (Memory Buffer Register) : 기억장치에 저장될 단어를 가지고 있거나, 
기억장치로부터 읽혀진 다음 단어를 저장하는데 사용

3. MAR(Memory Address Register) : MBR로부터 쓰여지거나 읽혀질 단어의 기억장치 주소를 저장

4. IR (Instruction Register) : 실행될 명령어의 연산코드를 저장

5. AC(accumulator) : 데이터를 일시적으로 보관하는 누산기


[동작 순서]

CPU는 기억장치(RAM)와 메모리를 교환한다.

1. PC가 첫 번째 명령어의 주소인 x를 가지고 있다.

2. PC에 있는 주소가 MAR로 적재

3. 이때, MAR에 있는 주소가 main memory 주소를 가리킨다.

4. 그 주소에 해당하는 값을 MBR에 저장

5. 해당하는 값을 IR한테 전달한다. 이 때 PC가 한개 증가(다음 주소를 읽어야 하기 때문...)

6. 제어장치가 명령어를 해독 후, AC에 data를 저장하거나 연산.(이것은 IR에 적재되어 있는 명령어에 따라 달라짐... 
명령어를 해석해보니, AC로 main memory에 있는 값을 불러오라는 것일수도 있고, AC에 있는 값을 연산하라는 것일수도있다.)



출처: https://itdexter.tistory.com/387 [IT_Dexter]
```
# Bus 
## CPU
* CPU - 캐시(CPU 칩 안의 작은 칩) - 버스(CPU와 메인 메모리 사이에 데이터를 저장하기 위함) - 메인 메모리
*   MBR(CPU 안)- 데이터 버스 - 주기억 장치 - 주소버스 - MAR(CPU 안) - PC
 * 채널에 관리가 되는 입출력 장치도 꽂혀있음
* 양방향성: 데이터 버스
* 1K = 2의 10승;  1M = 2의 20승

## IO 장치가 시스템 버스에 직접 접속되지 못하는 이유
* 종류에 따라 제어 방법이 서로 다른 I/O 장치들의 제어 회로들을 CPU 내부에 모두 포함시키는 것이 어려워 CPU가 그들을 직접 제어할 숭 ㅓㅄ기 때문이다.(CPU도 채널로 하여금 관리)
* I/O 장치들의 데이터 전송 속도가 CPU의 데이터 처리 속도에 비해 훨씬 느려 CPU도 채널을 붙임
* I/O 장치들과 CPU가 사용하는 데이터의 형식ㅇ의 깅리가 서로 다른 경우가 많다.

## 버스의 종류
- CPU가 처리한 데이터들은 모니터에 출력되거나 메모리에 저장되어 진다. 이러한 행위가 이루어 지기 위해서는 위의 데이터들이 각 컴포넌트끼리 통신이 가능 해야한다. 이러한 통신을 가능하게 해주는 Subsystem이 존재한다. 또한 이러한 Subsystem을 Computer Bus라고 한다. 즉 버스는 데이터를 통신할 수 있게 해주는 시스템이다.
 
### System Bus
-  CPU와 메모리를 연결하는 Subsystem을 System Bus라고 명명한다.
- 입출력장치는 조건(프린터,키보드,태블릿 등)에 따라 읽어들이는 데이터가 일일이 다르다. 느리고 서로 읽는 데이터양도 다른고, 그 두개의 문제가 다 해결됬다 하더라도 문제가 또 있다. cpu가 입출력장치를 직접 컨트롤 하지 않는 이유는 입출력장치가 너무 다양하다는 것이다. cpu입장에서는 개별적인 입출력장치를 어떻게 처리해야할지 고민 안해도되고 중간 제어기와 어떻게 대화할지만 생각하면된다. 이런 중간제어기가 바로 시스템버스다. 
 
### I/O Bus   https://richong.tistory.com/92 [study]
- 메모리와 다른 입출력 장치와 통신을 하는 Subsystem을 I/O Bus라고한다.
 
 
# 시스템 버스
## 데이터 버스
- 데이터 버스는 시스템 모듈들 간의 데이터 이동 경로를 제공한다. 주로 32, 64, 128 또는 그 이상의 분리된 선들로 구성되어 있으며 선의 수는 한 번에 전송할수 있는 비트 수를 결정지어 주는데 이것은 CPU가 수용할 수 있는 데이터의 크기, Word와 밀접한 관계가 있다.
• CPU가 기억장치 또는 I/O 장치간의 데이터 전송 신호 선 • 데이터 선의 수는 CPU가 한 번에 전송할 수 있는 비트 수를 결정 [예] 데이터 버스 폭 = 32 비트라면, CPU와 기억장치 간의 데이터 전송은 한 번에 32 비트씩 가능 
- 한편 버스에는 데이터 버스도 있다. 데이터 버스는 위에서 언급한 예에서, 데이터를 보낼 때 사용하는 버스이다.  데이터 버스는 각종 장치들이 자신들의 데이터를 보내는 만큼, 당연히 서로가 보낼 수 있는 양방향 버스이다.  데이터 버스는 워드(한 번에 처리하는 명령어의 단위)에 맞먹는 회선이 필요하다. 가령 요즘 쓰는 64비트 컴퓨터는 64비트 버스가 되어야 하는 것이다. 
 
 
## 주소 버스
- 주소 버스는 데이터의 근원지나 목적지의 일정한 메모리 주소를 전달하는 버스이다. 
- 주소 버스의 폭은 최대 기억장치의 용량을 결정지어 주는데 32개의 주소 버스를 지닌 컴퓨터 시스템은 2^32개의 메모리 위치를 할당할 수 있다. 또한 I/O포트를 지정하기 위해서도 사용되어진다.
- CPU에서 외부(주변장치)로 발생하는 주소 정보 전송 신호선 • 주소 선의 수는 CPU와 접속되는 최대 기억장치 용량 결정 [예] 주소 버스의 비트 수 = 16 비트라면, 최대 216 = 64K 개의 기억 장소들의 주소지정 가능 
- 가령 중앙처리장치에서 메모리 중 01111111에 해당하는 곳에 데이터를 보내려면, 이 데이터만이 아니라 이 데이터가 갈 곳인 01111111이라는 정보도 주소 버스를 통해 보내야 하는 것이다. 
 
## 제어 버스
- 제어 버스는 데이터 버스와 주소 버스를 제어하기위해 사용되어 진다. 데이터 버스와 주소 버스는 공유하는 선들의 집합이므로 이들을 제어하는 수단이 반드시 필요하기 때문에 사용한다. 
- CPU가 시스템 내의 각종장치들의 동작을 제어하기 위한 신호선 

### 제어버스 예제
- 기억장치의 읽기/쓰기(memory read/write) 신호 
- 입출력장치의 입력/출력(I/O input/output) 신호 
- 인터럽트(interrupt) 신호
-  버스 제어(bus control) 신호 
 
# CPU와 시스템 버스간의 접속
- 주소 버스 : 단방향성(unidirectional) 주소는 CPU로부터 기억장치 혹은 I/O 장치들로 보내지는 정보 
- 데이터 버스, 제어 버스 : 양방향성(bidirectional) 읽기와 쓰기 동작을 모두 지원 
 
2. 동기식 버스 vs 비동기식 버스

# 동기식 버스
 * 동기식 버스는 정해진 시간에 데이터를 전송하는 방법이다. 이 때 시간은 버스가 가지고 있는 Clock을 기준으로 하며 빠르고 인터페이스 논리회로가 간단하다는 장점이 있지만 느린 장비도 이 Clock에 맞춰야 한다는 점에서 시간 낭비가 발생할 수 있다. 
 
# 비동기식 버스
 * 비동기식 버스는 동기식 버스와 달리 시간을 따로 정하지 않는다. 단지 서로 데이터를 주고 받을 준비가 되어있는지 확인하는 핸드쉐이킹 프로토콜을 사용하여 수신측에서 준비가 되었으면 바로 전송을 하는 방식이다.
장점은 따로 정해진 시간이 없기 때문에 시간 낭비가 적다는 점이고 단점은 회로 구성이 복잡하고 핸드쉐이킹하는 과정이 필요해서 속도도 동기식에 비해 느리다.
 
3. PCIe
 * 버스의 특징이 공용 선이라는 것인데 이 특징덕분에 한 쪽이 데이터 선을 점령하면 다른 쪽에서는 신호 중첩을 유발 시킬수 있어서 사용을 하면 안된다. 이 점을 보완하기 위해 점대점 상호연결방식이 등장하였다.
 
## QPI(Quick Path Interconnect)
 * 다른 구성요소와 직접연결하는 점대점 상호방식중 하나로 레이어로 구성된 프로토콜 구조이므로 물리적으로 연결되어 있는 부분부터 오류의 존재 여부를 점검하는 등 각각의 레이어에서 하는 일을 구분되어 있다. 고속, 고효율의 패킷 기반의 전송방식을 사용하며 인텔의 i7 데스크톱 프로세서 이후로 사용되어지는 방식이다.
 
## PCIe(Peripheral Component Interconnect Express)
 * 버스를 1대 1로 연결해서 택시로 만들어 버렸다. 높은 용량덕분에 기가이더넷과 같은 빠른 데이터 속도의 I/O 디바이스를 지원하는데 사용되어지며 각각의 버스마다  독립적인 데이터 흐름을 제공하여 많이 사용되어진다. 또한 핀수가 적고 물리적 면적이 작으며 상세한 오류검출 및 보고구조 등의 장점을 가지고 있다.
 * 최근엔 I/O 가상화도 지원한다.
