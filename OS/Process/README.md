# 문제
```java
55. 프로세스의 정의로 거리가 먼 것은?  3번
① 운영체제가 관리하는 실행 단위
② PCB를 갖는 프로그램
③ 동기적 행위를 일으키는 주체
④ 실행 중인 프로그램


2. 프로세스의 상태 변이에 대한 설명으로 옳지 않은 것은?
1 시간 할당량(time slice)을 사용하는 일반적 우선순
위 기반 스케줄링에서 실행(running) 상태 프로세스
의 시간 할당량이 모두 소진되었을 때, 우선순위가
높은 다른 준비 상태의 프로세스가 있다면 실행 중
이던 프로세스는 커널(kernel)에 의해 스케줄링되기
를 기다리는 준비(ready) 상태로 전이된다.
2 실행 상태의 프로세스가 동기식 입출력 요청을 하면,
일반적으로 해당 프로세스는 입출력이 완료될 때까
지 CPU를 반납하고 대기(blocked 또는 waiting) 상
태로 전이된다.
3 대기 상태의 프로세스가 요청하였던 입출력이 완료
되면, 해당 프로세스는 CPU 연산이 가능해지므로
바로 실행 상태로 전이된다.
4 다중 처리기 시스템(multi-processor system)에서
는 실행 상태의 프로세스가 여러 개 있을 수 있다.
5 대기 상태의 프로세스들은 CPU 할당을 위한 스케줄
링에서 제외된다


답 3
3 대기 상태의 프로세스가 입출력이 완료되면 바로 실행 상태로
전이되는 것이 아니라, 준비 상태로 전이되어 자신의 순서가 오
길 기다린다.
<오답 체크> 5 대기 상태의 프로세스에는 우선순위가 부여되지 않
으므로, 스케줄링에서 제외된다.

```

# 프로세스
* 실행중인 프로그램
* 커널에 등록되고 커널의 관리하에 있는 작업
* 각종 자원들을 욫어하고 할당 받을 수 있는 개체
* 프로세스 관리 블록을 할당 받은 개체
* 능동적인 개체




## PCB
* 프로그램 A가 수행중에 인터럽트가 발생하면 현재 실행중이던 지점을 A의 프로세스 제어 블록에 저장한 후 인터럽트 처리 루틴으로 가서 인터럽트 발생관련 일 처리를 한다. 인터럽트 처리를 모두 마치면  프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.

## 컴퓨터 시스템의 작동 개요 @ 스택
 * CPU를 컴퓨터의 두뇌라고 부르지만 CPU는 인간의 뇌처럼 스스로 생각하고 판단하는 능력을 갖추고 있지는 못하다.
 * 이는 CPU가 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 어떠한 작업을 수행해야 하는지에 대해 스스로 결정하는 능력은 없기 때문이다.
 * CPU는 현재 수행해야 할 메모리 주소의 명령을 있는 그대로 처리할 뿐이다. 
 * 이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다. 
 * 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다.
 * 일반적으로 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 
 * 바로 다음 주소의 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다.
* 메모리에는 사용자 프로그램 + OS 같이 올라가 수행된다.  이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다.
* if 프로그램 카운터가 메모리 주소 중 OS가 존재하는 부분을 가리킨다면 CPU가 커널 모드에서 수행중이라고 이야기한다. else CPU가 사용자 모드에서 수행중이라고 이야기한다.



## 프로세스의 상태  @ CPU 선점
 * 프로세스의 상태는 실행, 준비, 봉쇄의 세 가지로 크게 나누어 볼 수 있다.


## PCB
* os가 프로세스 관링 ㅔ필요한 정보 저장
* 프로세스 생성 시 생성됨

### 실행
 * CPU를 할당받고 기계어 명령을 수행하고 있는 프로세스의 상태이다.

### 준비 상태
 * CPU만 할당받으면 당장 명령을 수행할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당받지 못한 프로세스의 상태이다.

### 봉쇄 상태
 * CPU를 할당받더라도 명령을 수행할 수 없는 프로세스의 상태이다. 
 * 프로세스가 요청한 입출력 작업이 진행중인 경우 CPU를 할당받더라도 입출력이 끝나기전까지 작업을 진행할 수 없기 때문에 CPU를 할당하지 않는다.


### 준비 상태에 있는 프로세스가 실행 상태로 변경되는 경우
 * 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태가 되거나 또는 실행 상태에 있던 프로세스의 CPU 할당 시간이 만료되어 타이머 인터럽트가 발생한 경우를 들 수 있다.
 * OS는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(Ready Queue)를 두고 
 * 준비 큐의 제일 앞에 있는 프로세스에게 CPU를 할당한다. 
 * 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.

### OS는 특정 자원을 기달리는 프로세스들을 줄 세우기 위해 자원별로 큐를 두고 있다.
* 예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 
 * 디스크 입출력 큐(Dist I/O Queue)에 줄 서게 된다.
 * 그러면, 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행하게 된다.
 * 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시키고, 
 * 그러면 인터럽트 처리 루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와
 * CPU를 기다리는 준비 큐에 줄 서게 된다.


## 위에서 언급된 큐는 HW 자원을 기다리는 프로세스들을 줄 세우기 위한 것이었다. 
* 이와 같은 큐는 SW 자원을 기다리는 경우에도 필요하다.
 * 예를 들어 데이터에 대한 접근 권한은 SW 자원으로 분류될 수 있다.
 * 어떠한 프로세스가 공유 데이터를 사용하고 있는 도중에 
 * 다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손될 수 있다.
 * 따라서, 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.
 * 이 때 접근한다는 의미가 반드시 CPU가 그 데이터를 사용하고 있다는 의미는 아니다.
 * 공유 데이터를 접근중인 프로세스가 "준비 상태"나 "봉쇄 상태로" 변경된 경우에도
 * 새롭게 CPU를 할당받은 프로세스가 동일한 데이터를 접근하게 되면
 * 데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안 된다.
 * 즉, 공유 데이터라는 일종의 SW 자원을 앞서 접근중인 프로세스가 다 사용하고 반날할 때까지는
 * 다른 프로세스가 CPU를 할당 받았다 하더라도 접근하지 않고 기다려야 하는 것이다.
 * 여러 프로세스가 공유 데이터를 동시에 접근하려고 할 경우 공유 데이터를 기다리는 "큐"에 줄 서게 하여
 * 현재 그 데이터를 사용중인 프로세스가 데이터를 반납하기 전까지는 접근을 못하게 하고,
 * 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방법을 사용하게 된다.
* 위 그림처럼 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 이루어지게 된다.
* 각 프로세스들이 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리하고 있다는 뜻이다.

### 예시
 * 예를 들어 타이머 인터럽트가 발생하면
 * 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해
 * 다음에 어느 프로세스에게 CPU를 할당할지 결정하고
 * 현재 실행되던 프로세스는 준비 큐의 제일 뒤로 보내게된다.
 * // 준비 큐는 CPU를 할당받기 위해 기다리는 큐이므로
 * // 어떤 프로세스에게 CPU를 할당할지 결정하려면 준비 큐를 봐야한다.
 * // 타이머 인터럽트이기 때문에 "봉쇄 상태"가 아니라 준비 큐의 가장 마지막에 재삽입하는 것이다.
 * // 입출력 요청이였을 시에는 "봉쇄 상태"로 빠져 준비 큐에 들어가지 못하게 된다.


## 프로세스의 두 가지 실행 상태
* 하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다.
* 이는 프로그램이 사용자 정의 함수나 라이브러리 함수뿐 아니라 입출력 시스템 콜 등을 통해 OS 커널의 함수도 호출하여 실행하기 때문이다.

### 예시
 * 예를 들어 프로세스 A가 CPU에서 실행되고 있다고 하면
 * 이는 자신의 주소 공간에 정의된 코드를 실행하는 것과
 * 커널의 시스템 콜 함수를 실행하는 것으로 나누어 볼 수 있다.
 * 전자를 사용자 모드에서의 실행 상태(User mode Running)이라 하고,
 * 후자를 커널 모드에서의 실행 상태(Kerner mode Running)라고 한다.
 * 한 가지 주의할 점은 시스템 콜이 수행되는 동안
 * 프로세스 A의 코드가 아니라 OS 커널의 코드이지만
 * 커널이 실행 상태에 있다고 하지 않고
 * 프로세스 A가 실행 상태에 있다고 말한다.
 * 프로세스 A 입장에서는 CPU를 OS 커널에게 빼앗긴 것으로 생각할 수도 있지만
 * 커널의 코드가 실행되는 것이 사실상 프로세스 A가 해야 할 일을 대행하는 것이기 때문에
 * 시스템 콜이 실행중일 때에도 여전히 프로세스 A는 실행 상태에 있는 것으로 간주한다.
 * 다만, 프로세스 A 자신의 코드를 실행하는 것과 구분지어
 * 이러한 상태를 프로세스 A가 커널 모드에서 실행중이라고 이야기한다.


### 정리
 * 정리하자면, 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 
 * 이를 사용자 모드와 커널 모드의 실행 상태로 구분 지을 수 있다.
 * 프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경없이 사용자 모드에서의 실행을 하게 되며, 
 * 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행하게 된다. 
 * 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시트템 콜 이후의 명령들을 계속 실행하게 된다. 
 * 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.

# Process
* 프로그램을 운영하는 기초 단위  
    ^basuc unit of running program
* Concurrent
* Code, Stack, Heap, Data
* Stack:  

# 프로세스
- https://bowbowbow.tistory.com/16 
- 프로그램 -> 실행 내용 -> 프로세스 -> 중앙처리장치(CPU)
- 프로그램은 일반적으로 하드 디스크 등에 저장되어 있는 실행코드를 뜻하고, 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.
- 프로세스와 프로그램의 차이는 정말 명확합니다. 프로그램자체는 생명이 없습니다. 프로그램은 보조 기억장치(하드디스크, SSD)에 존재하며 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음입니다. 이 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 생명이 있는 프로세스가 됩니다.

## 프로세스의 정의
* 커널에 등록되고 커널의 관리하에 있는 작업
* 각종 자원들을 요청하고 할당 받을 수 있는 개체
* 프로세스 관리 블록을 할당받은 개체
* 능동적인 개체(실행 중에 각종 자원을 요구, 할당, 반납하여 진행)

## 코드가 프로세스가 되는 과정
* 먼저, 하나의 코드가 프로그램이 되고, 프로그램이 프로세스가 되는 과정은 다음과 같다.
* 코드 작성 -- (컴파일) --> 오브젝트 파일 -- (링킹) --> 실행 파일(=프로그램) -- (로드) --> 메모리 적재 및 수행(=프로세스)
* [출처]['https://dailyheumsi.tistory.com/137?category=855210 [하나씩 점을 찍어 나가며]']

```java
컴파일러
​ 사용자가 작성한 원시코드를 컴퓨터가 읽을 수 있는 형태의 오브젝트 파일로 만드는 프로그램

어셈블러
​ 어셈블리어 코드를 기계어 코드로 변환시켜주는 프로그램.
​ 명확히 말하면, 어셈블러는 큰 의미 컴파일러 내부에 속한다.
​ 큰 의미의 컴파일러는 사실 다음과 같이 구성된다.
​ (원시 코드) -> (컴파일러) -> (어셈블리어 코드) -> (어셈블러) -> (기계어 코드 = 오브젝트 코드)

링커
​ 프로그램이 되기 위해 여러 개의 오브젝트 파일과 라이브러리를 엮는 과정(링킹)을 수행하는 프로그램

로더
​ 사용자가 프로그램을 실행하면, 메모리에 적재하는 일(로드)을 수행하는 프로그램


```

## 프로세스가 접근할 수 있는 메모리 공간
- 이 주소 공간은 Text, Data, BSS, Heap, Stack 영역으로 구성됩니다. 아래 그림에서 각 영역에 프로그램의 어떤 정보를 저장하는지 나타냈습니다.
- Text: 기계어; Data: 초기화된 전역 변수, static 변수, BSS: 초기화되지 않은 전역 변수, static 변수, Heap: malloc으로 동적 할당된 변수   stack: 지역 변수




## PCB
- 프로세스에 대한 정보는 프로세스 제어블록(PCB, Process Control Block)또는 프로세스 기술자(process descriptor)라고 부르는 자료구조에 저장됩니다. 대부분 PCB라고 부릅니다. 이 자료구조 크게 다음과 같은 정보를 담고있습니다. 
- 운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호(PID, Process IDentification)입니다.
- CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행중인 프로세스도 있고 대기 중인 프로세스도 있습니다. 그런 프로세스의 상태를 저장합니다.
- CPU가 다음으로 실행할 명령어를 가리키는 값입니다. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값입니다.
- 운영체제는 여러개의 프로세스를 동시에 실행하는 환상을 제공합니다. 운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것을 스케줄링이라고 합니다. 이 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 합니다.
- 프로세스가 접근할 수 있는 자원을 결정하는 정보입니다. 안드로이드 앱을 예로 들면 아무 앱이나 휴대폰 통화내역을 볼 수 있는 권한을 가지면 이를 악의적으로 이용하는 앱이 등장하겠죠? 그래서 프로세스마다 어디까지 접근할 수 있는지에 대한 권한이 필요합니다.
- 최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성합니다. 그래서 각 프로세스는 자식 프로세스와 부모프로세스에 대한 정보를 가지고 있습니다.
 
 * 출처: https://bowbowbow.tistory.com/16 [멍멍멍]

## 프로세스의 상태
- 생성(create) : 프로세스가 생성되는 중이다.
- 실행(running) : 프로세스가 CPU를 차지하여 명령어들이 실행되고 있다.
- 준비(ready) : 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있다. 일반적으로 준비 상태의 프로세스 중 우선순위가 높은 프로세스가 CPU를 할당받는다.
- 대기(waiting) : 보류(block)라고 부르기도 한다. 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태를 말한다.
- 종료(terminated) : 프로세스의 실행이 종료되었다.

##상태전이
- 디스패치(dispatch)
- 준비 리스트의 맨 앞에 있던 프로세스가 CPU를 점유하게 되는 것, 즉 준비 상태에서 실행 상태로 바뀌는 것을 디스패치라고 하며 다음과 같이 표시한다.
- dispatch (processname) : ready → running

- 보류(block)
- 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우 프로세스는 CPU를 스스로 반납하고 보류 상태로 넘어 간다. 이것을 보류라고 하며 다음과 같이 표시한다.
- block (processname) : running → blocked

- 깨움(wakeup)
- 입출력 작업 종료 등 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어가는 과정을 깨움이라고 하며 다음과 같이 표시한다.
- wakeup (processname) : blocked → ready



- 시간제한(timeout)
- 운영체제는 프로세스가 프로세서를 계속 독점해서 사용하지 못하게 하기 위해 clock interrupt를 두어서 프로세스가 일정 시간동안만 (시분할 시스템의 time slice) 프로세서를 점유할 수 있게 한다
- timeout(processname) : running -> ready


## Process Creation
* [블로그](https://dailyheumsi.tistory.com/129?category=855210)
```java
Process Creation
현재 프로세스에서 새로운 프로세스를 생성하거나 실행시키는 경우, 2가지 구현 방법이 있다.
모두 OS에서 제공해주는 시스템 콜(System call) 로 fork() 와 exec() 이다.

3.1. fork()
fork() 는 OS가 새로운 메모리 공간을 할당하도록 한 후, 현재 프로세스의 코드와 정보를 
모두 새로운 메모리 공간에 복사하도록 한다. 즉, 현재 실행중인 프로세스와 동일한 프로세스 하나를 더 만드는 셈이다.
프로세스는 결과적으로 1개에서 2개가 되는 셈이다.


핵심은 다음과 같다.

1) `fork()` 를 하면, 현재 프로세스의 자식 프로세스를 생성한다.  
2) 이 때, 반환 값이 0이면 자식이고, 0보다 크면 부모 프로세스를 의미한다. (즉 자식 프로세스를 pid 로 구분해야함)  
3) 부모 프로세스를 그대로 복사하여 생성하기 때문에, PC(프로그램 카운터)도 그대로 가져간다.
즉 자식 프로세스는 `fork()` 이 시점부터 프로그렘이 실행된다. 한편 저장되어있던 지역변수 등 모두 동일하다.

3.2. exec()
exec() 는 OS가 현재 프로세스의 공간에 새로운 프로세스를 덮어쓰게 한다.
예를 들어, execl("/bin/ls", "ls") 와 같이 했다면, 이 명령어를 담고있는 프로세스에 해당 프로그램 /bin/ls 를 실행시킨다.
즉, /bin/ls 이 성공했으므로, 뒤에 수행되는 코드들은 모두 덮혀버린다.
프로세스는 결과적으로 그대로 1개인 셈이다.

자세한 내용은 아래 링크 참조.

```

```java
fork()와 exec()는 모두 한 프로세스가 다른 프로세스를 실행시키기 위해 사용하게 됩니다.

exec에는 execl, execv등 여러가지 함수군을 가지고 있습니다. exec의 함수군에 대해서는 아래쪽에서 차이를 간단히 정리하고자 합니다.

우선 fork()와 exec()의 차이점은 fork() 시스템 호출은 새로운 프로세스를 위한 메모리를 할당합니다. 그리고 fork()를 호출한 프로세스를 
새로운 공간으로 전부 복사하게 되고, 원래 프로세스는 원래 프로세스대로 작업을 실행하고 fork()를 이용해서 생성된 프로세스도 그 나름대로 
fork() 시스템 콜이 수행된 라인의 다음 라인부터 실행이 됩니다. (새로 생성된 프로세스는 원래의 프로세스와 똑같은 코드를 가지고 있습니다.)

반면, exec()는 fork()처럼 새로운 프로세스를 위한 메모리를 할당하지 않고, exec()를 호출한 프로세스가 아닌 exec()에 의해 호출된 프로세스만 메모리에 남게됩니다.


 
간단히 정리하면, fork()의 결과는 프로세스가 하나 더 생기는 것입니다.( = 프로세스 id- PID 가 완전히 다른 또 하나의 프로세스가 생기는 것)

반면 exec()실행의 결과로 생성되는 새로운 프로세스는 없고, exec()를 호출한 프로세스의 PID가 그대로 새로운 프로세스에 적용이 되며, exec()를 
호출한 프로세스는 새로운 프로세스에 의해 덮어 쓰여지게 됩니다.



이제, exec()관련 함수들에 대해 조금 간단히 다뤄볼까 합니다. exec는 execl, execv, execlp, execvp 등이 있습니다.

이들에 대하여 본 4가지만 간단히 구분하는 방법을 정리해보았습니다.



exec를 먼저 l계열(execl, execlp)과 v계열(execv, execvp)로 나누어 설명하겠습니다.

l계열 : 인자를 열거하는 방식이 나열형

v계열 : 인자를 열거하는 방식이 배열형



다음으로 p가 붙은 계열(execlp, execvp), 안붙은 계열(execl, execv)로 나누어 정리하면,

p가 안붙은 계열 : 경로를 지정해주면 ,현재/절대경로를 기준으로 찾게 됩니다.(경로로 실행파일을 지정)

p가 붙은 계열(path) : path에 잡혀있으면 실행됩니다.(실행파일의 이름만 지정)



exec계열은 첫번째 인자의 코드가 들어오고 나머지 기존에 exec아래에서 실행해야할 코드는 전부 잃어버리게 된다는 점을 가지고 있다고 보시면 됩니다.



출처: https://jwprogramming.tistory.com/55?category=680235 [개발자를 꿈꾸는 프로그래머]
```

## process termination
```java
Process Termination
일반적으로, 프로세스가 마지막 명령어(코드) 를 수행하면 OS에게 삭제해달라는 exit() 요청을 하게된다.
다만, 이 때 자식 프로세스가 아직 실행중인 경우, 부모 프로세스는 OS에 의해 wait 명령을 받아 wait 상태에 있게 된다.
이후, 모두 완료되면 OS가 할당했었던 메모리를 회수해간다.

보통 부모 프로세스가, 자식 프로세스보다 먼저 삭제되는 경우, OS는 이를 비정상적인 상황이라 인지하고 
해당 부모의 자식 프로세스도 모두 삭제시키는데, 이를 Cascading Termination 이라 한다.


4.1. Zombie vs Orphan Process
Zombie Process
실행이 완료된 프로세스임에도, 여전히 프로세스 테이블에 남아있는 (지워지지 않은) 프로세스를 말한다.
이러한 프로세스가 발생하는 이유는 다음과 같다.
부모 프로세스는 자식 프로세스의 실행이 끝난 뒤의 상태(status) 를 받기 위해 계속 wait(&status) 하고 있는다.
자식 프로세스는 실행이 끝나고 exit status 로 상태를 바꾼 뒤, 
이를 부모 프로세스에게 전달하고, 부모가 전달받을 때까지 기다린다.
이 기다리는 동안, (부모 프로세스가 자식 프로세스를 회수해가지 않는 동안) 메모리 공간을 잡아먹지는 않지만, 
프로세스 테이블에는 남아있으므로 일종의 Zombie 상태가 된다.
여하튼, 종료된 프로세스임에도 프로세스 테이블에 남아있는 것은 좋지않으므로,
부모 프로세스에서 반드시 wait(&status) 를 통해, 자식 프로세스의 종료상태를 읽어야 한다.

Orphan Process
자식 프로세스가 종료되기 전에, 부모 프로세스가 먼저 지워진 자식 프로세스를 말한다.
이러한 프로세스가 발생하는 이유는 부모 프로세스 실행 중, 비정상적인 종료 혹은 wait() 을 하지 않았기 때문이다.
Orphan Process 는 OS에 의해 Init Process 가 부모로 할당된다.


```



## IPC (Inter-Process Communication)
* 프로세스간 통신하는 방법에는 다음과 같은 방법이 있다.
```java

5.1. Shared Memory
일반적으로 프로세스들은 메모리에서 각자의 독립된 공간을 보장받는다. 
즉 어떤 프로세스가 다른 프로세스의 메모리 영역에 접근할 수 없도록 OS가 설계되어져 있다.
하지만, Shared Memory 를 OS 에게 요청하면, 프로세스의 해당 영역은 다른 프로세스와 공유할 수 있는 공간이 된다.
프로세스간 통신에서 가장 빠르게 작동하는 방법이다.
다만, 동기화를 직접 해줘야 한다는 것, 메모리 공간을 직접 제어해줘야한다는(생성, 삭제) 단점이 있다.

5.2. Message passing
위 그림에서도 보이듯, 기본적으로 큐 형태를 취하기 때문에, 동기화 제어가 쉽게 가능하다.
다만, 동시에 Shared Memory 보다 통신 속도가 느리다.
대표적으로 아래와 같이 3가지 구현 형태가 있다.

1) Pipe
OS 에서 제공하는 pipe buffer 로, 한 프로세스에서 다른 프로세스로 통신하는, 단 방향 통신 방법이다.
ex. ps -aux | grep root | tail 에서 | 가 pipe 다.

2) Named Pipe
mkfifo() 라는 시스템 콜로 이름이 있는 파이프를 만들어 통신한다.
이전의 Pipe (익명 Pipe 라고 한다.) 는 통신을 할 프로세스를 명확히 아는 경우
(이를 테면 부모와 자식 프로세스 간)에만 사용 가능하지만, 
Named Pipe의 경우, 파이프의 이름을 통해 통신에 접근하기 때문에, 모든 프로세스 간에 통신이 가능하다.
하지만 여전히 Pipe 의 특성상, 읽기/쓰기가 동시에 가능하지 않으며, 따라서 일반적으로 읽기용 Pipe, 쓰기용 Pipe, 이렇게 2개를 사용한다.

3) Message Queue
커널에서 관리하는 큐를 통해 프로세스간 통신한다.
Named Pipe 처럼 일종의 식별자를 통해 각 프로세스마다 필요한 자료에 접근하게 된다.
Named Pipe 와 다른 점은, Pipe 는 단방향인데 반해, Queue는 양방향이라는 점, 메모리 공간에 할당된다는 점 등이 다르다.



출처: https://dailyheumsi.tistory.com/129?category=855210 [하나씩 점을 찍어 나가며]

```

## shared memory
```java
모든 프로세스는 자신의 업무를 수행하기 위해서 필요한 자료를 저장하기 위한 메모리 공간을 가지게 된다. 
이러한 메모리공간에는 CPU에 의해 수행되는 명령어들, 프로그램 시작시 정의되고 초기화된 데이터, 
프로그램 시작시 정의되었지만 초기화되지 않은 데이터, 함수호출에 필요한 정보, 동적할당이 이루어지는 데이터 등이 들어가게 된다.

 

프로세스는 시작시 혹은 실행중에 이러한 데이터를 저장하고 사용하기 위한 메모리공간을 커널에 요구하여서 
할당 받아 사용하게 되는데, 이러한 메모리 공간은 기본적으로 메모리를 요청한 프로세스만이 접근가능하도록 
되어 있다. 하지만 가끔은 여러개의 프로세스가 특정 메모리공간을 동시에 접근해야할 필요성을 가질때가 있을 것이다. 
공유메모리를 이러한 작업을 위한 효율적인 방법을 제공한다.

 

공유메모리는 여러 IPC 중에서 가장 빠른 수행속도를 보여준다. 그 이유는 하나의 메모리를 공유해서 접근하게 되므로, 
데이터 복사와 같은 불필요한 오버헤드가 발생하지 않기 때문으로, 빠른 데이터의 이용이 가능하다.

 

그러나 하나의 프로세스가 메모리에 접근중에 있을때, 또 다른 프로세스가 메모리에 접근하는 일이 
발생하면 자칫 데이터가 훼손될 수 있을 것이므로, 한번에 하나의 프로세스가 메모리에 접근하고 있다는 
걸 보증해 줄 수 있어야 할 것이다.  

 

공유메모리는 어떻게 할당되는가

 

공유메모리의 생성요청은 최초 공유 메모리 영역을 만드는 프로세스가 커널에 공유메모리 공간의 할당을 
요청함으로써 이루어지며, 만들어진 공유메모리는 커널에 의해서 관리되게 된다. 이런 이유로 한번 만들어진 
공유메모리는 운영체제를 재부팅하거나, 직접 공유메모리공간을 삭제 시켜주지 않는 한, 공유메모리를 사용하는 
모든 프로세스가 없어졌다 하더라도 계속적으로 유지되게 된다.

 

프로세스가 커널에게 공유메모리 공간을 요청하게 되면, 커널은 공유메모리 공간을 할당시켜주고 
이들 공유메모리공간을 관리하기 위한 내부자료구조를 통하여, 이들 공유메모리를 관리하게 된다.
```

## 프로세스간 커뮤니케이션
```java
IPC 기법 이지만, 이외에도 많이 사용되는 두 가지 기술이 있다.

1. 시그널
2. 소켓


1. 시그널(signal)
유닉스에서 30년이상 사용된 전통적인 기법
커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
프로세스 관련 코드에 관련 시그널 핸들러를 등록해서, 해당 시그널 처리 실행

시그널 무시
시그널 블록(블록을 푸는 순간, 프로세스에 해당 시그널 전달)
등록된 시그널 핸들러로 특정 동작 수행
등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행

주요 시그널
SIGKILL : 프로세스를 죽여라
SIGALARM : 알람을 발생한다
SIGSTOP : 프로세스럴 멈춰라
SIGCONT : 멈춰진 프로세스를 실행해라
SIGINT : 프로세스에 인터럽트를 보내서 프로세스를 죽여라
SIGSEGV : 프로세스가 다른 메모리영역을 침범했다.


2. 소켓(socket)
소켓은 네트워크 통신을 위한 기술
기본적으로는 클라이언트와 서버등 두 개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술
소켓을 하나의 컴퓨터 안에서, 두 개의 프로세스간에 통신 기법으로 사용 가능
```


## [컨텍스트 스위칭](https://www.youtube.com/watch?v=-4HKhwlH3FQ&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=35)
```JAVA
멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 
다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고
CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 
Context Switch(Context Switching)라고 한다.

질문에 대한 답변은 이정도로 하고 좀 더 명확하게 이해해본다.

* Context Switching을 문맥 교환으로 번역하지 말자.

Context는 무엇인가?

사용자와 다른 사용자, 사용자와 시스템 또는 디바이스간의 상호작용에 영향을 미치는 사람, 장소, 
개체등의 현재 상황(상태)을 규정하는 정보들을 말한다.

android나 servlet등에서도 context가 있지만 OS에서 Context는 CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.

이 Context는 프로세스의 PCB(Process Control Block)에 저장된다.

그래서 Context Switching 때 PCB의 정보를 읽어(적재) CPU가 전에 프로세스가 일을 하던거에 이어서 수행이 가능한 것이다.

PCB의 저장정보

- 프로세스 상태 : 생성, 준비, 수행, 대기, 중지

- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어 주소

- 레지스터 : 누산기, 스택, 색인 레지스터

- 프로세스 번호

* 참고로 Context Switching 때 해당 CPU는 아무런 일을 하지 못한다. 따라서 컨텍스트 스위칭이 잦아지면 
오히려 오버헤드가 발생해 효율(성능)이 떨어진다.

Context가 뭔지 알았고 멀티프로세싱하기 위해 CPU를 나눠서 사용하기 위해 Context를 교체하는 것이 Context Switching임을 알았다.
그리고 PCB에 Context가 저장됨도 알았다.

남은 것은 인터럽트 요청이 뭐고 어떤 종류가 있는지 + 서브로 우선 순위에 대한 이야기다.

Context Switching - 인터럽트(Interrupt)

인터럽트는 CPU가 프로그램을 실행하고 있을 때 실행중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우 
CPU에게 알려 예외 상황을 처리할 수 있도록 하는 것을 말한다.



어떤 인터럽트 요청이 와야 Context Switching이 일어날까?

1. I/O request (입출력 요청할 때)

2. time slice expired (CPU 사용시간이 만료 되었을 때)

3. fork a child (자식 프로세스를 만들 때)

4. wait for an interrupt (인터럽트 처리를 기다릴 때)

+ 더 있겠지만 자세한 것은 생략.

* 우선 순위는 해당 OS의 스케줄러가 우선 순위 알고리즘에 의해 정해지고 수행하게 되어있다.

라운드로빈 스케줄링(Round Robin Scheduling)은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나다.

쉽게 설명하면 순서대로 시간단위(Time Quantum)을 CPU에 할당하는 방식이다.

꽤 효율적인 스케줄링 알고리즘이지만 이 시간단위를 작게 설정하면 CPU가 조금 일하고 Context Switching을 
반복하므로 아까 말했듯이 효율이 떨어진다.

* Context Switch를 하는 주체 = OS 스케줄러


```

# [정아마추어](https://jeong-pro.tistory.com/93?category=793347)
## context switching
* 멀티프로세스 환경에서 CPU가 어떤 프로세스를 실행하고 있는 상태에서, interrupt 요청에 의해 다음 우선쉰위으 프로세스가 실행되야 할 때, 기존 프로세스의 상태 또는 레지스터 값을 저장하고 cpu가 다음 프로세스를 수행하도록 상태 또는 레지트서 값을 교체하는 작업이다. 컨텍스트 스위칭 작업간에 cpu는 아무 작업을 할 수 없다. 따라서 잦은 컨텍스트 스위칭으로 오버헤드가 발생해 효율이 낮아질 수 있다.
* CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 컨텍스트 스위칭이라 한다. 이러한 컨텍스트 스위칭을 통해 우리는 멀티 프로세싱, 멀티 스레딩 운영이 가능하다.

```java
CPU에 실행할 프로세스를 교체하는 기술 (Context Switching)
실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보를 CPU에 넣고, 실행
실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB정보(PC,SP)를 CPU의 레지스터에 넣고, 실행
dispatch : ready상태의 프로세스를 running 상태로 바꾸는 것
컨텍스트 스위칭 시간이 오래 걸리면 운영체제 속도가 느려진다
실제로는 굉장히 짧은시간(ms) 단위로, 프로세스 스위칭이 일어남
```

### 컨텍스트 스위칭의 원리
* 프로세스 A가 실행이 될려면 스케쥴러에 프로세스가 들어가게 된다. 스케쥴러아 해당 status를 running으로 변경한다. 프로세스 A가 실행을 하다가 스케쥴러가 프로세스 B를 running status로 변경하는 것을 컨택스트 스위칭이라고 한다. (pc와 stack pointer가 핵심이다 !!)
* process A에서 process B로넘어갈때 현재의 컨텍스트를 PCB라는 별도의 저장공간을 만들어서 저장하고 운영체제가 관리한다. 프로세스 B실행중 스케쥴러에 의해 다시 Process A로 넘어오면 PCB를 읽어서 Context를 불러 와서 프로세스를 실행한다.


```java
멀티태스킹 컨텍스트에서, 한 태스크에 대해 시스템 상태를 저장하여 작업을 일시 중지하고 다른 태스크가 재개되도록 하는 프로세스를 말한다. 
컴퓨팅에서 컨텍스트 스위치는 프로세스 또는 스레드의 상태를 저장하여 나중에 같은 지점에서 복원하고 실행을 재개하는 과정이다. 이를 통해 
여러 프로세스가 하나의 CPU를 공유할 수 있으며, 멀티태스킹 운영 체제의 필수적인 기능이다. 또한 컨텍스트 스위치는 작업이 디스크 스토리지에 
액세스해야 하는 경우와 같이 인터럽트의 결과로 발생하여 다른 작업에 대한 CPU 시간을 확보할 수 있다. 일부 운영 체제에서는 사용자 모드와 커널 
모드 작업 사이를 이동하기 위해 컨텍스트 스위치가 필요하다. 컨텍스트 전환 프로세스는 수행 중인 스위치의 특성에 따라 이 효과의 크기가 달라지지만 
시스템 성능에 부정적인 영향을 미칠 수 있다.


컨텍스트 스위치에 대한 세 가지 잠재적 트리거가 있다.

멀티태스킹
가장 일반적으로, 어떤 스케줄링 계획 안에서, 다른 프로세스가 실행될 수 있도록 CPU에서 한 프로세스를 꺼야 한다. 이 컨텍스트 스위치는
I/O 또는 동기화 작업이 완료되기를 기다리는 것과 같이 스스로 실행 불가능한 상태로 만드는 프로세스에 의해 트리거될 수 있다. 사전 예방적
다중 작업 시스템에서 스케줄러는 여전히 실행 가능한 프로세스를 전환할 수도 있다. 다른 프로세스가 CPU 시간에 굶주리는 것을 방지하기 위해,
선제적 스케줄러는 종종 프로세스가 시간 절감을 초과할 때 타이머 인터럽트를 작동하도록 구성한다. 이 인터럽트는 스케줄러가 컨텍스트 스위치를 
수행하기 위한 제어를 확보하도록 보장한다.

사용자 및 커널 모드 전환
운영 체제에서 사용자 모드와 커널 모드 간의 전환이 필요한 경우 컨텍스트 스위치는 필요하지 않다. 모드 전환 자체는 컨텍스트 스위치가 아니다. 
그러나 운영 체제에 따라 컨텍스트 스위치도 이때 발생할 수 있다.

인터럽트 처리
현대의 아키텍처들은 인터럽트 기반이다. 이는 CPU가 예를 들어 디스크에서 데이터를 요청하면 읽기가 끝날 때까지 business-wait할 필요가 
없다는 것을 의미한다. 즉, CPU는 요청을 발행하고 다른 실행을 계속할 수 있다. 읽기가 끝나면 CPU를 중단하여 읽기와 함께 표시할 수 있다. 
인터럽트의 경우 인터럽트 핸들러라는 프로그램이 설치되며, 디스크로부터의 인터럽트를 처리하는 것이 인터럽트 핸들러다. 인터럽트가 발생하면 
하드웨어는 컨텍스트의 일부를 자동으로 전환한다. 취급자는 특정 하드웨어 및 소프트웨어 설계의 세부사항에 따라 추가 컨텍스트를 저장할 수 있다.
종종 인터럽트를 처리하는 데 소요되는 시간을 최소화하기 위해 컨텍스트의 최소 부분만 변경된다. 커널은 인터럽트를 처리하기 위해 특별한 프로세스를
생성하거나 스케줄링하지 않고, 대신에 핸들러는 인터럽트 처리 초기에 설정된 컨텍스트에서 실행된다. 인터럽트 서비스가 완료되면 인터럽트가 
발생하기 전에 유효했던 컨텍스트를 복원하여 인터럽트 프로세스가 적절한 상태로 다시 실행될 수 있도록 한다.
```

## 컨텍스트 스위칭 단점
```java
위의 그림을 보면 P0가 Excute에서 idle이 될 때 P1이 바로 Excute가 되지 않고 idle을 좀 더 하다가 Excute가 된다.

그 이유는 P0 상태를 PCB에 저장하고 P1 상태를 PCB에서 가져와야 하기 때문이다.

위 과정에서 PCB를 저장하고 가져올때는 CPU가 아무런 일도 하지 못하게 된다.

따라서 컨텍스트 스위칭이 너무 잦으면 오버헤드가 발생하여(비용이 높아) 성능이 떨어진다. 
```
* 코드, 데이터, 스택, 힙 영역로 이루어진 메모리를 모두 스위칭 하여야 해서 비용이 높다.


## 쓰레드와 프로레스 차이
```java
쓰레드는 프로세스 내 다른 실행 흐름을 가지기 위해 사용한다고 하였다.
실행 흐름을 다르게 가져가기 위해선 다른 함수 호출 시퀀스를 가져야 하고, 스택 영역이 별도로 있어야 하는 이유이다.

암튼, 위에서 보듯이 쓰레드는 Stack 영역만 별도로 소유함으로써 프로세스 대비 쓰레드간 컨텍스트 스위칭은 비용이 적은 것이다.

특히 캐쉬 메모리의 활용 측면으로 넘어가면 그 비용의 차이는 더 커진다.
프로세스 컨텍스트 스위칭시에는 모든 데이터 영역이 갈아엎히기에 캐쉬 메모리가 싹 비워져야 하지만, 쓰레드의 경우엔 그렇지 않다. 

다시 한번 정리하면 메모리 관련 쓰레드의 특성은 다음과 같다.
쓰레드마다 독립된 스택을 할당해 준다.
쓰레드마다 고유의 CPU 레지스터값 세트를 가진다. (그래야 쓰레드 스위칭 이후 실행하던 지점으로 돌아갈 것 아닌가?)
코드 영역을 공유한다.
힙 & 데이터 영역을 공유한다.
```

## 스레드 컨텍스트 스위칭
```java
스레드 컨텍스트 스위칭: OS는 스레드 하나의 작업을 진행하기 위해 해당 스레드의 Context를 읽어오고, 다시 다른 스레드로 작업을 변경할 때, 
이전 스레드의 Context를 저장하고 작업을 진행할 스레드의 Context를 읽어오는 작업을 말한다. 즉 한 마디로 말해서 한 스레드에서 
다른 스레드로 작업을 넘기는 과정이라고 할 수 있다.


```
