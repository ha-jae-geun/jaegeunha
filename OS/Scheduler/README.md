# 문제
```java
문 2. CPU 스케줄링 기법 중 라운드 로빈(Round Robin) 방식에 대한
설명으로 옳지 않은 것은? 4
1 선점 스케줄링 기법이다.
2 여러 프로세스에 일정한 시간을 할당한다.
3 시간할당량이 작으면 문맥 교환수와 오버헤드가 증가한다.
4 FIFO(First-In-First-Out) 방식 대비 높은 처리량을 제공한다.

[해설]
- RR(Round Robin, 라운드 로빈)
1 FCFS를 선점형 스케줄링으로 변형한 기법이다.
2 대화형 시스템에서 사용되며, 빠른 응답시간을 보장한다.
3 RR은 각 프로세스가 CPU를 공평하게 사용할 수 있다는 장점이 있지
만, 시간할당량의 크기는 시스템의 성능을 결정하므로 세심한 주의가 필
요하다.

운영체제의 디스크 스케줄링 기법에 대한 설명으로 옳은 것은? 3
① FCFS(First-Come-First-Served)는 현재의 판독/기록 헤드위치에서 
대기 큐 내 요구들 중 탐색 시간이 가장 짧은 것을 선택하여 처리하는 기법이다.
② N-Step-SCAN은 대기 큐 내에서 디스크 암(disk arm)이 외부 실린더에서 
내부 실린더로 움직이는 방향에 있는 요구들만을 처리하는 기법이다.
③ C-LOOK은 디스크 암(disk arm)이 내부 혹은 외부 트랙으로 이동할 때,
움직이는 방향에 더 이상 처리할 요구가 없는 경우 마지막 트랙까지 이동하지 않는 기법이다.
④ SSTF(Shortest-Seek-Time-First)는 각 요구 처리에 대한 응답 시간을 항상 공평하게 하는 기법이다.

∙ ① SSTF(Shortest Seek Time First)에 대한 설명입니다.
∙ ② C-SCAN(Circular SCAN)에 대한 설명입니다.
∙ ④ FCFS(First Come First Service)에 대한 설명입니다



57. 스케줄링의 목적으로 가장 거리가 먼 것은?  4번은
① 모든 작업들에 대해 공평성을 유지하기 위하여
② 단위 시간당 처리량을 최대화하기 위하여
③ 응답 시간을 빠르게 하기 위하여
④ 운영체제의 오버헤드를 최대화하기 위하여
```

# [디스크 스케줄링](https://limkydev.tistory.com/165)

# 프로세서
```java
Processor (프로세서)는 하드웨어적인 측면에서 "컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛"이다.  
이는 중앙처리장치(Central Processing Unit)를 뜻하며 폰노이만 아키텍쳐에 의해 만들어졌다면 적어도 하나 이상의 ALU (Arithmetic Logic Unit)와 
처리 레지스터(Register)를 내장하고 있어야 한다.
```

# [장, 단, 중기 스케줄링](https://kosaf04pyh.tistory.com/191)

# 스케줄링
```java
1. 스케줄링은 프로세스가 생성되어 실행될때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업을 의미합니다.

2. 프로세스가 생성되어 완료될때까지 프로세스는 여러 종류의 스케줄링 과정을 거치게 됩니다.

3. 스케줄링의 종류에는 장기 스케줄링, 중기 스케줄링, 단기 스케줄링이 있습니다.



 장기 스케줄링

어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업을 의미합니다. 
작업 스케줄링, 상위 스케줄링이라고도 하며, 작업 스케줄러에 의해 수행됩니다. 

 중기 스케줄링 

어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업을 의미합니다. CPU를 할당받으려는 프로세스가 많을 경우 
프로세스를 일시 보류시킨 후 활성화해서 일시적으로 부하를 조절합니다.


 단기 스케줄링  
 
 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업을 의미합니다. 프로세서 스케줄링, 
 하위 스케줄링이라고도 합니다. 프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행됩니다. 



스케줄링의 목적

스케줄링은 CPU나 자원을 효율적으로 사용하기 위한 정책으로 아래와 같은 목적을 가지고 있습니다.


공정성 : 모든 프로세스에 공정하게 할당합니다.

처리율(량)증가 : 단위 시간당 프로세스를 처리하는 비율(양)을 증가시킵니다.

CPU 이용률 증가 : 프로세스 실행 과정에서 주 기억장치를 액세스한다든지, 입출력 명령실행 등의 원인에 의해 발생할 수 
있는 CPU의 낭비 시간을 줄이고, CPU가 순수하게 프로세스를 실행하는데 사용되는 시간 비율을 증가시킵니다.


우선순위 제도 : 우선순위가 높은 프로세스를 먼저 실행합니다.

오버헤드 최소화 : 오버헤드를 최소화합니다.

응답시간 최소화 : 작업을 지시하고 반응하기 시작하는 시간을 최소화합니다.

반환시간 : 프로세스를 제출한 시간부터 실행이 완료되는 시간을 최소화합니다.

반환시간 최소화 : 프로세스를 제출한 시간부터 실행이 완료될떄까지 걸리는 시간을 최소화합니다.

대기시간 최소화 : 프로세스가 준비상태 큐에서 대기하는 시간을 최소화합니다.

균형있는 자원의 사용 : 메모리, 입출력장치 등의 자원을 균형있게 사용합니다.

무한 연기 회피 : 자원을 사용하기 위해 무한정 연기되는 상태를 회피합니다.




 프로세서 스케줄링의 기법 
비선점 스케줄링

1. 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법입니다.

2. 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될때까지 CPU를 사용합니다.

3. 프로세스 응답 시간의 예측이 용이하며, 일괄 처리 방식에 적합합니다.

4. 중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우가 발생할 수 있습니다.

5. 비선점 스케줄링의 종류에는 FCFS, SJF, 우선순위, HRN, 기한부 등의 알고리즘이 있습니다.



선점 스케줄링

1. 하나의 프로세스가 CPU를 할당받아 실행하고 있을 떄 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법입니다.

2. 우선순위가 높은 프로세스를 빠르게 처리할 수 있습니다.

3. 주로 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용됩니다.

4. 많은 오버헤드를 초래합니다.

5. 선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록이 필요합니다.

6. 선점 스케줄링의 종류에는 라운드로빈, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등의 알고리즘이 있습니다.



※ 인터럽트용 타이머 클록이란?

하나의 시스템 내에서 동작하는 장치들을 감시하기 위해 주기적인 신호를 발생하는 것으로, 하나의 프로세스가 자원을 독점하지 못하도록 방지하기 위해 사용됩니다.
```

# 스케줄링
* [블로그](https://dailyheumsi.tistory.com/131?category=855210)
```java
다중 프로그래밍을 함으로써, 항상 실행할 수 있는 프로세스를 있도록 하여,
CPU 사용 효율을 극대화 하는 것이 목적이다.

* CPU, I/O burst
프로세스는 계산과 입출력의 반복.
계산(CPU burst) / 입출력(I/O burst)

* 선점 / 비선점 스케쥴링
선점은 RUN 중인 프로세스를 갑자기 중단시키고 다른 프로세스가 RUN 할 수 있는 방식
비선점은 RUN 중인 프로세스를 중간에 갑자기 중단 불가능.
일단 한 번 할당 받으면, 시간이 다 되거나, 완료 될 때까지 다른 프로세스들이 기다려야함.

* Dispatcher
스케쥴러가 선택한 프로세스를 CPU에 할당해주는 요소를 가르킴
Dispatch latency
	A 프로세스 STOP -> B 프로세스 RUN 하는 동안 소요되는 시간

```

## 용어정리
```java
CPU utilization (이용률)

전체 시간 중에서 CPU가 놀지 않고 일한 시간의 비율

Throughput (처리량)

주어진 시간동안 얼마의 작업을 처리했는가

<프로세스 입장에서의 성능척도>

Turnaround time (소요시간, 반환시간)

CPU를 할당받기 위해 Ready queue에서 대기한 시간부터 모든 프로세스 작업을 마치고 반환하기 까지 걸린 시간

Waiting time (대기 시간)

CPU를 할당받기 위해 Ready queue에서 대기한 시간의 총합

Response time (응답 시간)

Ready queue에 들어와서 첫 번째로 CPU를 할당받기까지 걸린 시간
```

## 스케쥴링 기준
```java
스케쥴링 알고리즘을 선택할 때, 고려되는 기준을 살펴본다.

처리율 (Throughput)
시간당 완료되는 프로세스의 수

반환시간 (Turnaround time)
한 프로세스가 큐에 들어간 시점부터 실행완료할 때까지 걸리는 시간

대기시간 (Waiting time)
한 프로세스가 큐에서 대기한 총 시간

응답시간 (Response time)
큐에 들어가고, 첫 번째 실행 때까지 걸리는 시간
처리율은 높이고, 반환, 대기, 응답시간은 낮추는게 가장 이상적인 알고리즘이다.

```
## 스케쥴링 종류
* FCFS, RR: 공평성(Fairness)
* SPN(Starvation), SRTN(현실적으로 불가능), HRRN: 효율성/성능
	* 문제점: 실행시간 예측 부하

```java
(2) 스케줄링 알고리즘의 종류

스케줄링 알고리즘의 종류에는 FIFO 스케줄링, 우선 순위 스케줄링, 기한부 스케줄링, RR 스케줄링 SJF 스케줄링, SRT 스케줄링, HRN 스케줄링, 다단계 피드백 스케줄링 등이 있다.

 

비선점 스케줄링

ⓐ FIFO(First In First Out) 스케줄링

가장 간단한 스케줄링 기법으로, 먼저 대기 큐에 들어온 작업에게 CPU를 먼저 할당하는 비선점 스케줄링 방식이다.

- 비선점 스케줄링 기법이다.

- 중요하지 않은 작업이 중요한 작업을 기다리게 할 수 있다.

- 대화식 시스템에 부적합하다.

- FCFS(First Come First Served) 스케줄링 기법이라고도 한다.

 

ⓑ 우선순위(Priority) 스케줄링

각 작업마다 우선순위가 주어지며, 우선 순위가 제일 높은 작업에 먼저 CPU가 할당되는 방법이다. 우선 순위가 낮은 작업은 
Indefinite Bolcking 이나 Starvation에 빠질수 있고, 이에 대한 해결책으로 체류 시간에 따라 우선 순위가 높아지는 Aging 기법을 사용할 수 있다

 
기아현상(Starvation)

시스템 부하가 많아서 낮은 등급에 있는 준비 큐에 있는 프로세스가 무한정 기다리는 현상

 

에이징기법(Aging)

기아현상을 해결하기 위한 기법으로 오랫동안 기다린 프로세스에게 우선순위를 높여줌으로서 처리하는 기법



ⓒ 기한부(Deadline) 스케줄링

작업이 주어진 제한 시간이나 Deadline 시간 안에 완료되도록 하는 기법이다.

 
 

ⓔ SJF(Shortest Job First) 스케줄링

SJF는 비선점 스케줄링 기법으로, 처리하여야 할 작업 시간이 가장 적은 프로세스에 CPU를 할당하는 기법이다. 평균 대기 시간이
최소인 최적의 알고리즘이지만, 각 프로세스의 CPU 요구 시간을 미리 알기 어렵다는 단점이 있다.



ⓖ HRN(Highest Response Ratio Next) 스케줄링

Brinch Hansen이 SJF 스케줄링 기법의 약점인 긴 작업과 짧은 작업의 지나친 불평등을 보완한 스케줄링 기법이다.

- 비선점 스케줄링 기법이다.

- 서비스 받을 시간이 분모에 있으므로 짧은 작업의 우선 순위가 높아진다.

- 대기 시간이 분자에 있으므로 긴 작업도 대기 시간이 큰 경우에는 우선 순위가 높아진다.





선점
ⓓ 라운드 로빈(RR; Round-Robin) 스케줄링

FIFO 스케줄링 기법을 Preemptive 기법으로 구현한 스케줄링 방법으로 프로세스는 FIFO 형태로 대기 큐에 적재되지만, 주어진 시간 
할당량(Time Slice) 안에 작업을 마쳐야 하며, 할당량을 다 소비하고도 작업이 끝나지 않은 프로세스는 다시 대기 큐의 맨 뒤로 되돌아간다.

- 선점 스케줄링 기법이다.

- 시스템이 사용자에게 적합한 응답시간을 제공해 주는 대화식 시분할 시스템에 적합하다.

 

ⓕ SRT(Shortest Remaining Time) 스케줄링

SJF 스케줄링 기법의 선점 구현 기법으로, 새로 도착한 프로세스를 비롯하여 대기 큐에 남아 있는 프로세스의 작업이 완료되기까지의
남아있는 실행 시간 추정치가 가장 적은 프로세스에 먼저 CPU를 할당한다.

 

ⓗ 다단계 피드백 큐(Multilevel Feedback Queue) 스케줄링
각각 프로세스의 중요도에 따라 큐로 나누고 각 큐에서 다른 알고리즘을 적용해 효율을 높일 수 있는 장점이 있죠. 

다양한 특성의 작업이 혼합된 경우 매우 유용한 스케줄링 방법으로, 새로운 프로세스는 그 특성에 따라 각각 대기 큐에 들어오게 되며, 
그 실행 형태에 따라 다른 대기 큐로 이동한다. 예를 들어 연산 위주의 프로세스들은 처음에 RR 방식의 대기 큐에서 주어진 시간 할당량이 
만료되면 다음 단계의 큐에 배치되고, 실행 시간이 길수록 점점 낮은 우선 순위를 지니게 되어 마지막 가장 낮은 우선 순위의 큐에 도달하면 
작업이 끝날 대까지 RR 방식으로 스케줄된다.
```

## 3. 스케쥴링 알고리즘
```java
3.1. 싱글레벨 큐
하나의 큐만 사용한다.

* FCFS (First Come First Served)
비선점 방식
FIFO 형태. 큐로 쉽게 구현
Convoy 효과
하나의 큰 프로세스가 CPU를 양보할 때 까지 다른 모든 프로세스가 기다리는 현상

* SJF (Shortest Job First)
현재 큐에 들어와있는 프로세스 중, CPU burst 시간이 제일 짧은 프로세스 순으로 스케쥴링
평균 대기 시간 측면에서는 그나마 최적에 가까움.
다음 CPU burst 시간 예측의 어려움
	지수 평균 방법으로 예측
선점방식일 경우, 다음 방법으로 선점여부 결정
	새 프로세스가 큐에 도착하면, 이 프로세스의 다음 CPU burst 시간(A) 예측
	현재 RUN 중인 프로세스의 남은 CPU burst 시간(B) 계산
	이 두 시간 A, B 를 비교해서 A < B 이면, 새 프로세스가 CPU 선점
	이 방식은 SRTF (Shortest Remaining Time First) 라고 함.
	
* 우선순위 스케쥴링
	우선순위가 높은 프로세스가 먼저 CPU를 선점함
	SJF 도 이 스케쥴링의 일종임.
우선순위는 OS 또는 사용자에 의해 지정될 수 있음
영구 대기(infinite blocking), 굶주림(starvation) 이 발생할 수 있음.
즉 우선순위가 낮은 프로세스는 영원히 실행되지 않는 문제
이를 극복하기 위해 우선순위를 점진적으로 낮춰주는 aging 기법을 사용함

* RR (Round robin)
시간 조각(time quantum) 을 정의하여, 이 시간이 경과할 때마다 CPU를 선점하는 프로세스를 바꿈.
예를 들어, 시간 조각 q=4ms 이면, 4ms 동안 프로세스 A가 선점한 후, 다음 4ms 에는 프로세스 B가 선점.
일반적으로 CPU burst 시간의 80% 는 시간 조각보다 적어야 가장 바람직함.


3.2. 다중레벨 큐
여러 개의 큐를 사용한다.

큐 간 독자적인 스케쥴링 알고리즘을 사용한다.
프로세스는 여러 개의 큐간 이동하며 수행된다.
이 스케쥴링의 주 목표는 CPU burst 시간 특성이 다른 프로세스들을 분리하여,
굶주림과 호위 효과 현상을 제거하는 것이다.
예를 들어, 입출력 중심의 프로세스는 상위 큐에, CPU 중심의 프로세스는 하위 큐에 할당된다.
다음과 같은 사항을 고려하여, 다중레벨 큐를 만들 수 있다.
	큐의 개수
	각 큐의 스케쥴링 알고리즘
	aging 혹은 그 반대로 만드는 방법
	큐 이동 순서

``
## Memory structure
* Data; initialized
  - static variable, global variable
  - 프로그램이 종료 될 때까지 먼저 호출되고 남아 있습니다.  
      ^it is called first and remain until programs terminate 
  - -> it's fixed
  - BSS (Block Stated Symbol); uninitialized
* Stack(function): local variable, parameter, return, pointer variable
  - 모든 프로그램은 스택을 가지고 있다. 나중에 프로그램을 백업시키는데 도움을 준다.  
      ^ALl programs have stacks. It helps to go back
  - 밑에서 위로 저장된다.  
      ^from bottom to top
  - funcion이 호출되면 스택이 시작됩니다.  
      ^when the funcion is called, it starts to be stacked. (recursive)
  - 메모리가 할당되면 스택 영역을 확장해야합니다 (컴파일 시간)  
      ^when memory is allocated, stack area has to be extended(compile time)
  - 컴파일 될 때 스택 크기가 결정됩니다.  
      ^At compile time, stack size has to be decided
  - 함수가 종료되면 스택도 사라집니다.  
      ^if the function is terminated, stack is also deleted
  - -> it's static
  - 배열의 길이는 일정해야 합니다.  
      ^Array's length has to be a constant
  - 스택 사이즈는 고정입니다.  
      ^stack size is fixed
* Heap; dynamic(malloc, free)  C++: new()
  - 위에서 아래로 저장됩니다.  
      ^from top to bottom
  - 스택과 다르게 실행 시간에 데이터가 저장됩니다.  
    <> stack; running time 
* Text(Code); assembly code about function; function, statement, constant
* SMA(Static Memory Allocation): data, stack   | DMA(Dynamic Memory Allocation): Heap Area
* 스택과 힙은 반비례 관계이다.  
    ^Stack and heap are in inverse proportion
```


# CFS 스케줄러
* 스케줄러는 CPU 자원을 프로세스들에게 분배하는 OS의 중요한 일부분이다.
* 2007년 발표 된 리눅스 커널의 스케줄러인 CFS(Completely Fiar Scheduler) RSDL(Rotating Staircase Deadline) 스케줄러를 기초로 한 RB-트리(Red-Black Tree) 데이터 구조를 사용하는 O(logN) 성능을 가지는 스케줄러이다.
* CFS는 시간단위로 나노초를 사용한다.

* 만약 A, B 두 개의 태스크가 진행되고 있다면 A와 B의 CPU 사용시간은 항상 1:1로 같아야한다.
* 그러나 두 태스크가 번갈아 가며 수행되므로 임의의 시점에 두 태스크의 CPU 사용 시간이 항상 1:1로 같을 수 없다.
* 따라서 CFS는 정해진 ‘시간 단위’로 봤을때 시스템에 존재하는 태스크들에게 공평한 CPU 시간을 할당하는 것을 목표로 한다.
* 만약 1초를 ‘시간 단위’로 한다면 0.5초 동안 A 태스크를 수행시키고, 그런 뒤 0.5초간 B 태스크를 수행시킴으로써 1초가 지난 이후 A와 B의 CPU 사용시간이 1:1이 되도록 하는 것이다.
* CFS의 기본 개념은 작업에 프로세서 시간을 제공할 때 밸런스(공평성)를 유지하는 것이다.
* 즉 프로세스에 공평한 양의 프로세서(=CPU)가 제공되어야 한다.
* 작업 시간의 밸런스가 무너진 경우에는(다른 작업에 비해 하나 이상의 작업에 공평한 양의 시간이 주어지지 않은 경우) 작업 시간이 적게 지정된 작업에 실행 시간이 주어져야 한다.

## 가상 런타임
* CFS에서는 밸런스를 결정하기 위해 가상 런타임이라는 지정된 작업에 제공된 시간의 양을 관리한다.
* 작업의 가상 런타임이 작을수록 즉, 프로세서에 액세스할 수 있도록 허용된 시간이 작은 작업일수록 더 많은 프로세서 시간이 필요하다.

## 대기자 공평성
* 이 개념은 현재 실행할 수 없는 작업(예를 들어, I/O를 대기 중인 작업)이 나중에 프로세서가 필요할 때 대기했던 시간에 상응하는 프로세서 시간을 받을 수 있도록 보장한다.

## RB-트리
* 하지만 CFS는 이전 Linux 스케줄러와는 달리 실행 큐에서 작업을 관리하지 않고 시간순으로 정렬된 RB-트리를 유지한다.
* 첫 번째는 스스로 밸런스를 조절한다는 것이다.
* 즉, 이 트리의 모든 경로는 다른 경로보다 두 배 이상 길어지지 않는다.
* 두 번째는 트리에 대한 작업이 O(log n) 시간(여기서 n는 트리의 노드 수임) 내에 발생한다는 것이다.
* 따라서 작업을 빠르고 효율적으로 삽입하거나 삭제할 수 있다.
