# 쓰레드
* 프로세스 안에 존재하여, 프로세스의 자원을 공유하는 개체 흔히 경량 프로세스라고 부름 각 쓰레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유.
## 스택을 쓰레드마다 독립적으로 할당하는 이유
* 쓰레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.
* 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을
* 저장하기 위해 사용되는 메모리 공간이므로
* 스택 메모리 공간이 독립적이라는 것은
* 독립적인 함수 호출이 가능하다는 것이고
* 이는 독립적인 실행 흐름이 가능하게 한다.

## PC Resister를 쓰레드마다 독립적으로 할당하는 이유
* PC 값은 쓰레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.
* 쓰레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다.
* 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.

## 쓰레드는 프로세스보다 생성 및 종료시간, 쓰레드간 전환시간이 짧다.
* 쓰레드는 프로세스의 메모리, 자원등을 공유하므로 커널의 도움없이 상호간에 통신이 가능하다.

## 멀티 스레드, 멀티 프로세스 장단점
```java
Multi process
독립적으로 어떤 일을 수행하므로, 문제가 발생해도 다른 프로세스에 영향을 주지 않는다.
하지만, 프로세스 처리는 쓰레드와 비교했을 때 무겁다.
Context Switching 에서의 오버헤드
CS 가 일어날 때마다 PCB 를 통째로 캐시에 저장, 로드 해야함.
IPC 에서의 오버헤드
자원 공유가 번거롭고, 느림.
좀 더 가볍게 여러 테스크를 진행할 수 없을까?


Multi Threading
하나의 목적을 가지고 하는 일을 여러 개로 나눠서 병행처리해야할 경우 쓰레드를 쓰자.
Multi prcoess 와 비교했을 때, 다음과 같은 장점이 있다.
프로세스보다 메모리 사용가 적다. (Stack 만 할당하므로)
쓰레드간 데이터 통신이 빠르다. (Heap 을 공유, 접근 가능하므로)
수행 속도가 일반적으로 빠르다. (CS 시, Stack 영역만 처리하므로)
다음과 같은 단점이 있다.
쓰레드간 자원 공유에 대한 문제 (동기화, synchronization)
설계와 제어가 까다롭다.


출처: https://dailyheumsi.tistory.com/130?category=855210 [하나씩 점을 찍어 나가며]
```

## 1.3. User-level Thread vs Kernel-level Thread
* [블로그](https://dailyheumsi.tistory.com/130?category=855210)
```java
커널 레벨 쓰레드와 유저 레벨 쓰레드는 생성 주체가 누구냐에 따라 구분된다. (매우 헷갈림 주의)

* User-level Thread
프로그래머가 커널에 의존적이지 않게, 라이브러리를 통해 생성하는 쓰레드가 유저 레벨 쓰레드이다.
이렇게 생성된 쓰레드는, 커널에게는 보이지 않는다.
즉 커널은 프로세스 그 자체만 알지 , 내부의 유저 쓰레드는 모른다.
커널 스케쥴링의 기본 단위가 즉 프로세스 단위다.
커널이 전혀 관여하지 안고, 프로세스에서 관리한다.
즉, 프로세스가 자체적인 쓰레드 스케줄링을 가진다.
모드 변경이 필요없어 생성과 관리가 빠르다.
즉, 쓰레드간 CS 시, 커널 스케쥴러를 호출하지 않으므로, 오버헤드가 적다.
하지만, 프로세스 내 하나의 쓰레드가 커널에 의해 블록되면 해당 프로세스가 통째로 블록된다.
이를 해결하는 프로그래밍과 결과 예측이 매우 어렵다.

* Kernel-level Thread
프로그래머 요청에 따라 쓰레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨 쓰레드라고 한다.
커널 스케쥴링의 기본 단위가 즉 프로세스 단위가 아닌, 쓰레드 단위다.
하나의 프로세스는 적어도 하나의 커널 쓰레드에게 관리된다.
단일 프로세스 = 1개의 쓰레드
하지만 유저 <-> 커널 모드 전환에서 오버헤드가 크다.
같은 프로세스 내 쓰레드 전환(유저 레벨)의 경우 CS 비용이 적지만,
다른 프로세스 간의 쓰레드 전환(커널 레벨)의 경우 이 비용이 크기 때문이다.
현대 대부분의 OS 는 이 방식을 채택

- 커널 레벨 쓰레드 장점 : 
안전성, 기능의 다양성 
단점 : 커널에서 기능을 제공하기 때문에 성능 저하 

- 유저레벨 쓰레드 장점 
전환 필요없기때문에 성능 좋음 
단점 : 프로세스 내에 쓰레드가 하나만 블로킹 되어도 나머지 쓰레드가 작동하기 어려움 


```

## . 다중 쓰레드 모델
```java
보통 운영체제는 유저레벨 쓰레드와 커널레벨 쓰레드 모두 제공한다.

다대일 (N-to-one) 모델
효율적이긴 하지만 한 스레드가 블락당할 경우 전체 프로세스가 봉쇄된다.
진정한 병렬성의 개념이 없다.


일대일 (One-to-one) 모델
다대일 보다 더 많은 병렬성을 제공한다.
많은 쓰레드가 생성됐을 시, CS 비용이 크다.


다대다 (N-to-M) 모델
위 두 모델의 문제점을 어느 정도 해결한 모델

```

## 쓰레드 동기화 방법의 종류
* Mutex / Semaphore / Monitor
* 공통점은 세가지 모두 운영체제의 동기화 기법이라는 것이다.

### 락과 뮤텍스 차이점
```java
Lock은 한 프로세스 내에서 쓰레드 단위로 일어나는거고 Mutex는 Lock이랑 같지만 여러 프로세스끼리 가능하다
```

### 뮤텍스(Mutual Exclusion)
* 쓰레드의 동시 접근을 허용하지 않는다는 의미.
* 뮤텍스의 쓰레드 동기화 방법은 임계영역에 들어가기 위해 이 뮤텍스를 가지고 있어야 들어갈 수 있다.
* 예) 일종의 자물쇠와 같은 역할을 한다.
* 임계영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올때까지 다른 쓰레드가 못들어오게 내부에서 자물쇠로 잠근다.

### 세마포어(Semaphore)
* 세마포어 역시 뮤텍스와 비슷한 역할을 하지만 세마포어는 동시 접근 동기화가 아닌 접근 순서 동기화에 더 관련있다.

### 모니터(Monitor)
* Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다.


### 전자(뮤텍스,모니터)는 상호 배제를 함으로써 임계구역에 하나의 쓰레드만 들어갈 수 있다.
* 후자(세마포어)는 하나의 쓰레드(binary semaphore)만 들어가거나
* 혹은 여러 개의 쓰레드(counting semaphore)가 들어가게 할 수도 있다.


### . 뮤텍스와 모니터의 차이는?
* 가장 큰 차이는 뮤텍스는 다른 프로세스(애플리케이션)간에 동기화를 위해 사용한다.
* 반면 모니터는 하나의 프로세스(애플리케이션)내에 다른 쓰레드 간에 동기화할 때 사용한다.
* 또한, 뮤텍스는 보통 운영체제 커널 의해서 제공되는 반면에 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다.
* 따라서 뮤텍스는 무겁고(heavy-weight) 느리며(slower) 모니터는 가볍고(light-weight) 빠르다(faster).


### 세마포어와 모니터의 차이는?
* Java에서는 모니터를 모든 객체에게 기본적으로 제공하고 있는 반면 C에서는 모니터를 사용할 수 없다.
* 세마포어는 카운터라는 변수값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용 시 매번 값을 따로 지정해줘야하는 등 조금 번거롭다.
* 반면, 모니터는 이러한 일들이 캡슐화 되어 있어서(encapsulation) 개발자는 카운터값을 1 또는 0으로 주어야 하는 고민을 할 필요 없이 synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화할 수 있다.


### 뮤텍스와 세마포의 차이는?
* 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다.
* 예를 들어 Casting을 한다고 보면
	* (뮤텍스)세마포어 –> 가능
	* (세마포어)뮤텍스 –> 불가능
* 세마포어는 소유할 수 없는 반면 뮤텍스는 소유할 수 있고 소유자가 이에 책임을 진다
* 뮤텍스는 1개만 동기화가 되지만 세마포어는 하나 이상을 동기화 할 수 있다.


```java
변기가 하나뿐인 화장실에서는 
앞의 사람이 볼일을 마치고 나가야 다음 사람이 들어갈 수 있다. 
이렇게 한번에 오직 하나만 처리할 수 있는 대상에 사용하는 것이 뮤텍스이다. 

변기가 세개인 화장실에서는 동시에 세 사람이 볼일을 볼 수 있고 
이 세 사람 중 아무나 한명이 나오면 다음 사람이 볼일을 볼 수 있다. 
이렇게 동시에 제한된 수의 여러 처리가 가능하면 세마포어이다. 

만약 변기 세개짜리 화장실의 각 변기에 대해 뮤텍스를 사용한다면 
대기중인 사람은 각 변기 앞에 줄을 서는 것이고 
이렇게 되면 옆 칸이 비어도 들어가지 못하게 된다. 

만약 변기 세개를 묶어서 뮤텍스를 사용한다면 
변기 수에 관계없이 무조건 한명만 사용할 수 있게 된다. 

이 예에서 변기는 동기화 대상, 사람은 그 동기화 대상에 접근하는 쓰레드를 나타낸다. 

뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 쓰레드에 의해 사용중일 경우 
다른 쓰레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만 
관리하는 동기화 대상이 몇개 인가에 따라 차이가 생기게 되는 것이다.
```

# 임계영역
* [블로그](https://dailyheumsi.tistory.com/132?category=855210)
* 공유되는 자원, 즉 동시접근하려고 하는 그 포커싱된 자원!에서 문제가 발생하지 않게 독점을 보장해줘야 하는 영역을 임계영역이라고 해요
```java
동기화를 위해, 하나의 프로세스 혹은 쓰레드가 공유 자원에 대한 작업이 완료될 때까지, 
다른 프로세스, 쓰레드의 방해없이 완전하게 완료가 되어야 하는데, 이렇게 진행되는 원칙을 상호배재(Mutual Exclusion) 라고 하고, 
이렇게 수행되는 연산들을 Atomic Operation 이라 한다. 또, 
이렇게 공유자원에 대해 동기화해야하는 코드 부분을 임계 영역(Critical Section) 이라고 한다.

1.3. Critical Section 의 속성
임계 영역의 문제를 해결하기 위해서는 다음을 만족해야 한다.

상호배재 (Mutual Exclusion)
어떤 프로세스가 임계 영역을 실행하고 있을 때, 다른 프로세스는 임계 영역을 실행할 수 없다.
즉, 어떤 프로세스가 임계 영역을 실행할 때, 다른 프로세스는 코드 실행을 못하게 처리해줘야 한다.


진행 (Progress)
임계 영역에 실행되고 있는 프로세스가 없을 경우, 임계 영역을 실행하고자 기다리는 프로세스는 즉각적으로 임계 영역을 실행할 수 있어야 한다. 즉, 기다리고 있는 프로세스들에 대한 처리를 해줘야 한다.


한정 대기 (Bounded Waiting)
임계 영역을 실행하고자 하는 프로세스가 무한정으로 대기하면 안된다. 즉, 제한된 대기시간을 가져야 한다.

```

```java
화장실에 일을 보러 가야 하는데 변기는 혼자서만 사용해야 한다.
그러면 누군가가 사용하고 있다면 다른 사람은 사용할 수 가 없다.
이 때 문을 잠금다면(=Locking) 다른 사람이 들어가고 싶어도 못들어가게(=Waiting) 된다.
안에 있던 사람이 일을 보고 나오면 문을 열고(=Unlocking) 나와야 다른 사람이 들어갈 수 있게 된다.
```

```java
기본적으로 현재 일반 유저가 사용하는 대부분의 OS는 선점형 시분할 운영체제이다.
간단하게 말해서 크롬을 띄우고 메모장을 같이 띄워도 두개다 동작하는 것은 각각 일정 시간동안만 CPU를 선점하여 사용하기 때문이다.

이 때 할당되는 시간 단위를 타임 슬라이스(Time Slice)라고 한다.

일단 여기서 각각의 프로그램은 프로세스라는 단위로 움직인다.
그리고 프로세스 안에서 동작하는 실행 단위인 쓰레드가 존재한다.

크롬으로 스포츠 영상을 보면 크롬이 프로세스가 되고
크롬안에서 영상을 처리해주는 부분과 네트워크로 영상을 받아오는 부분이 각각 쓰레드가 된다.

그런데 프로세스 or 쓰레드가 Wait라는 상태가 걸리는 때가 있다.

이걸 이해하기 위해선 H/W를 살펴볼 필요가 있다.

H/W는 CPU보다 느리다.

그렇기 때문에 디스크에서 데이터를 읽는 작업처럼 느린 동작을 처리하기 위해서 작업이 잠깐 중단될 필요가 생긴다.

그러면 CPU는 디스크에서 데이터를 읽어 달라는 명령을 요청하고 다른 작업을 계속한다. (=Task Switch)
```

## Sleep 가능한 락
```java
락 중에는 이런식으로 자원에 접근 하는 락이 있다.

앞에서 살펴본 워터파크에는 k명만 입장이 가능하다.

k명에 들어간다면 그냥 입장 가능하겠지만 k명에 해당되지 않는다면 대기자는 그냥 졸면서 기다린다.

그리고 자원을 다 사용한 사람들이 나가면 졸고 있는 사람들을 깨워서 들여보낸다.

이게 바로 세마포어(Semaphore) 개념이다.

세마포어는 보통 자원에 관계된 락이다.

그래서 락을 걸때 특정 수만큼의 카운트를 갖고 빼주는 형식으로 처리된다.

이런 락을 슬립(Sleep)가능한 락이라고 한다.

또한 뮤텍스(Mutex)라는 락이 있는데 이는 Mutualy Exclusive라는 락이다.

결국 이것도 세마포어긴 한데, 특별히 카운트가 1인 락으로 봐도 무방하다.

이와 반대로 스핀락은 자지 않고 게속해서 버틴다고 볼 수 있다
```

## 스핀락은
```java
만약 다른 쓰레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.

조금만 기다리면 바로 쓸 수 있는데 굳이 문맥 교환으로 부하를 줄 필요가 있나? 라는 컨셉으로 개발됐다.

일반적으로 프로세스를 컨트롤 하는 입장에서
Sleep을 시키고 태스크를 스위칭 하는 일련의 작업은 그다지 작은 연산이 아니다.

Sleep된 프로세스를 깨우기 위해선 일단 데이터를 메모리에다가 쓰고 스위칭 작업을 하고 모든 작업이 다 끝났을때 가능하다.

그렇기 때문에 아주 작은 작업에 대해서는 세마포어 or 뮤텍스를 사용하지 않고 스핀락을 사용하는 게 효율적일 수 있다.
```

## 스핀락 주의할 점
```java
예를들어 어떤 숫자를 단순히 +1 해주는데 사용될 락이 있다 생각해보자.
이 경우는 거창하게 문맥 교환을 하면서 구현할 필요가 없다.
잠깐 밖에서 값을 검사해보고 내가 사용가능하면 바로 처리 하도록 하는게 효율적이다.
이 개념이 "스핀락" 개념이다.

그냥 단순히 적절한 시간동안 외부에서 for나 while로 루프를 돌면서 락을 검사하고 처리하게 되는 것이다.
이때 임계 영역은 굉장히 작거나 아주 빨리 처리가 가능할 경우 이런 락을 쓰게 된다. 

대신에 이런 락을 쓰고 있을 때 Sleep을 하게 되면 다른 쪽(쓰레드든, 프로세스든)에서는 
CPU는 사용하고 있는데(=루프가 돌고 있기 때문에) 락을 얻지 못하는 사실상의 데드락 상태에 빠지게 된다.

그래서 스핀락은 이런 특성 때문에 "바쁜 대기 상태(Busy Waiting)"라고도 불린다.
```

```java
임계 구역(Critical Section)에 진입이 불가능할 때 문맥 교환을 하지 않고 루프를 돌면서 재시도를 한다.

스핀락은 운영 체제의 스케줄링 지원을 받지 않기 때문에 해당 쓰레드에 대한 문맥 교환이 일어나지 않는다.

따라서 스핀락은 임계 구역에 짧은 시간 안에 진입할 수 있는 경우에 문맥 교환을 제거할 수 있어 효율적이다.

하지만 스핀락이 오랜 시간을 소요한다면 다른 쓰레드를 실행하지 못하고 대기하게 되며
이 경우 비효율적인 결과를 가져온다.

만약 오래 걸리는 작업에 대해 스핀락을 사용한다면
많은 쓰레드들이 락을 잡으려는 시도를 계속 하게되며
이렇게 되면 CPU 점유율이 엄청나게 올라가게 될 것 이다.
하지만 실질적인 작업은 수행하지 않는다.
```

## spin lock 특징ㅇ
1. Lock을 얻을 수 없다면, 계속해서 Lock을 확인하며 얻을 때까지 기다린다. 이른바 바쁘게 기다리는 Busy Wating이다.
2. 바쁘게 기다린다는 것은 무한 루프를 돌면서 최대한 다른 쓰레드에게 CPU를 양보하지 않는 것이다.
3. Lock이 곧 사용가능해질 경우 컨택스트 스위치를 줄여 CPU의 부담을 덜어준다. 하지만, 만약 어떤 쓰레드가 Lock을 오랫동안 유지한다면 오히려 CPU 시간을 많이 소모할 가능성이 있다.
4. 단일 CPU or 단일 코어인 경우에는 유용하지 않다. 그 이유는 만약 다른 쓰레드가 Lock을 가지고 있고 그 쓰레드가 Lock을 풀어 주려면 싱글 CPU 시스템에서는 어차피 컨택스트 스위치가 일어나야 하기 때문이다.
5. 주의할 점은 스핀락을 잘못 사용하면 CPU 사용률 100%를 만드는 상황이 발생된다.
6. 스핀락은 기본적으로 무한 루프를 돌며 lock을 기다리므로 하나의 쓰레드가 lock을 오랫동안 가지고 있다면, 다른 Blocking된 쓰레드는 Busy Waiting을 하므로 CPU를 쓸데없이 낭비하게 된다.
* 스핀락을 잘 사용하면 문맥 교환을 줄여 효율을 높일 수 있다. 

### 뮤텍스 락 vs 스핀락
* 락을 얻을 수 없을때 쓰레드 슬립 모드로 빠지지 않고 반복문을 계속 돌며 락을 얻으려는 시도를 한다.
* 락이 해제될 때 별도의 쓰레드 문맥교환(Context Switching)에 대한 오버헤드 없이 임계 구역에 접근을 한다.
* 뮤텍스 락의 경우 락이 해제되더라도 운영체제에 의해 쓰레드가 다시 깨어나야하지만 스핀락은 락을 얻을때까지 계속해서 CPU 자원을 점유하므로 CPU를 비효율적으로 낭비할 위험이 있다.
* 그러므로 임계구역 진입을 위한 대기 시간이 짧을 때 사용하는게 바람직하다.

# 멀티 쓰레드
* 쓰레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 힙(Heap) 영역을 이용하여 데이터를 주고받을 수 있다.
* 그렇기 때문에 프로세스 간 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다.
* 심지어 쓰레드의 문맥 교환은 프로세스 문맥 교환과는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.
* 따라서 시스템의 처리량이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축된다.


## 쓰레딩의 문제점
* 멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만
* 멀티 쓰레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 쓰레드가 데이터와 힙 영역을 공유하기 때문에
* 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료 구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 그렇기 때문에 멀티쓰레딩 환경에서는 동기화 작업이 필요하다.
* 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다.
* 하지만 이로 인해 병목 현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락(lock)으로 인한 병목 현상을 줄여야 한다.
* 공유 자원이 아닌 부분은 동기화 처리를 할 필요가 없다. 즉, 동기화 처리가 필요한 부분에만 synchronized 키워드를 통해 동기화하는 것이다.
* 불필요한 부분까지 동기화를 할 경우 현재 쓰레드는 락(lock)을 획득한 쓰레드가 종료하기 전까지 대기해야한다. 그렇게 되면 전체 성능에 영향을 미치게 된다.
* 즉 동기화를 하고자 할 때는 메소드 전체를 동기화 할 것인가 아니면 특정 부분만 동기화할 것인지 고민해야 한다.
