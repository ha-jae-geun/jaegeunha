# 동기화
```java
정의 : 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것
프로세스가 서로 협력하며 공유 자원을 사용하는 상황에서, 경쟁 조건이 발생하면 공유 자원을 신뢰할 수 없게 만들 수 있다.
```
# 경쟁 상황(Race Condition)
```java
동시에 여러개의 스레드가 동일한 데이터를 접근하고 조작하고

그 실행 결과가 특정 순서에 의해 의존하는 상황

        // 멀티스레드 프로그래밍을 할 경우 주의해야하는 이유
```

# 쓰레드
* 프로세스 안에 존재하여, 프로세스의 자원을 공유하는 개체 흔히 경량 프로세스라고 부름 각 쓰레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유.
## 스택을 쓰레드마다 독립적으로 할당하는 이유
* 쓰레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.
* 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을
* 저장하기 위해 사용되는 메모리 공간이므로
* 스택 메모리 공간이 독립적이라는 것은
* 독립적인 함수 호출이 가능하다는 것이고
* 이는 독립적인 실행 흐름이 가능하게 한다.

## PC Resister를 쓰레드마다 독립적으로 할당하는 이유
* PC 값은 쓰레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.
* 쓰레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다.
* 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.

## 쓰레드는 프로세스보다 생성 및 종료시간, 쓰레드간 전환시간이 짧다.
* 쓰레드는 프로세스의 메모리, 자원등을 공유하므로 커널의 도움없이 상호간에 통신이 가능하다.

## 멀티 스레드, 멀티 프로세스 장단점
```java
Multi process
독립적으로 어떤 일을 수행하므로, 문제가 발생해도 다른 프로세스에 영향을 주지 않는다.
하지만, 프로세스 처리는 쓰레드와 비교했을 때 무겁다.
Context Switching 에서의 오버헤드
CS 가 일어날 때마다 PCB 를 통째로 캐시에 저장, 로드 해야함.
IPC 에서의 오버헤드
자원 공유가 번거롭고, 느림.
좀 더 가볍게 여러 테스크를 진행할 수 없을까?


Multi Threading
하나의 목적을 가지고 하는 일을 여러 개로 나눠서 병행처리해야할 경우 쓰레드를 쓰자.
Multi prcoess 와 비교했을 때, 다음과 같은 장점이 있다.
프로세스보다 메모리 사용가 적다. (Stack 만 할당하므로)
쓰레드간 데이터 통신이 빠르다. (Heap 을 공유, 접근 가능하므로)
수행 속도가 일반적으로 빠르다. (CS 시, Stack 영역만 처리하므로)
다음과 같은 단점이 있다.
쓰레드간 자원 공유에 대한 문제 (동기화, synchronization)
설계와 제어가 까다롭다.


출처: https://dailyheumsi.tistory.com/130?category=855210 [하나씩 점을 찍어 나가며]
```

## 1.3. User-level Thread vs Kernel-level Thread
* [블로그](https://dailyheumsi.tistory.com/130?category=855210)
```java
커널 레벨 쓰레드와 유저 레벨 쓰레드는 생성 주체가 누구냐에 따라 구분된다. (매우 헷갈림 주의)

* User-level Thread
프로그래머가 커널에 의존적이지 않게, 라이브러리를 통해 생성하는 쓰레드가 유저 레벨 쓰레드이다.
이렇게 생성된 쓰레드는, 커널에게는 보이지 않는다.
즉 커널은 프로세스 그 자체만 알지 , 내부의 유저 쓰레드는 모른다.
커널 스케쥴링의 기본 단위가 즉 프로세스 단위다.
커널이 전혀 관여하지 안고, 프로세스에서 관리한다.
즉, 프로세스가 자체적인 쓰레드 스케줄링을 가진다.
모드 변경이 필요없어 생성과 관리가 빠르다.
즉, 쓰레드간 CS 시, 커널 스케쥴러를 호출하지 않으므로, 오버헤드가 적다.
하지만, 프로세스 내 하나의 쓰레드가 커널에 의해 블록되면 해당 프로세스가 통째로 블록된다.
이를 해결하는 프로그래밍과 결과 예측이 매우 어렵다.

* Kernel-level Thread
프로그래머 요청에 따라 쓰레드를 생성하고 스케줄링하는 주체가 커널이면 커널 레벨 쓰레드라고 한다.
커널 스케쥴링의 기본 단위가 즉 프로세스 단위가 아닌, 쓰레드 단위다.
하나의 프로세스는 적어도 하나의 커널 쓰레드에게 관리된다.
단일 프로세스 = 1개의 쓰레드
하지만 유저 <-> 커널 모드 전환에서 오버헤드가 크다.
같은 프로세스 내 쓰레드 전환(유저 레벨)의 경우 CS 비용이 적지만,
다른 프로세스 간의 쓰레드 전환(커널 레벨)의 경우 이 비용이 크기 때문이다.
현대 대부분의 OS 는 이 방식을 채택

- 커널 레벨 쓰레드 장점 : 
안전성, 기능의 다양성 
단점 : 커널에서 기능을 제공하기 때문에 성능 저하 

- 유저레벨 쓰레드 장점 
전환 필요없기때문에 성능 좋음 
단점 : 프로세스 내에 쓰레드가 하나만 블로킹 되어도 나머지 쓰레드가 작동하기 어려움 


```

## . 다중 쓰레드 모델
```java
보통 운영체제는 유저레벨 쓰레드와 커널레벨 쓰레드 모두 제공한다.

다대일 (N-to-one) 모델
효율적이긴 하지만 한 스레드가 블락당할 경우 전체 프로세스가 봉쇄된다.
진정한 병렬성의 개념이 없다.


일대일 (One-to-one) 모델
다대일 보다 더 많은 병렬성을 제공한다.
많은 쓰레드가 생성됐을 시, CS 비용이 크다.


다대다 (N-to-M) 모델
위 두 모델의 문제점을 어느 정도 해결한 모델

```

