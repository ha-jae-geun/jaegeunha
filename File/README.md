# 파일
```java
Q. 디스크에 저장하는 데이터는 크게 무엇으로 구분되는가?
==> 파일 ( 파일이 모여서 DB가 된다.)

Q. 하나의 파일이란?
하나의 응용 목적을 위해 보조기억장치에 저장된 같은 종류의 데이터 레코드 집합

Q. 파일 구조란?
디스크에 저장할 데이터의 표현(representation)과 데이터를 접근하기 위한 연산(operation)의 집합

데이터 필드, 애트리뷰트, 데이터 항목 
	이름을 가진 논리적 데이터의 최소 단위
	특정 객체의 한 성질의 값
레코드 타입 (Record type)
	논리적으로 서로 연관된 데이터 필드들의 집합
	엔티티 타입

레코드 어커런스 (Record Occurrence)
	한 레코드 타입의 인스턴스
	레코드 타입의 각 필드에 따라 실제 값이 들어가 어떤 특정 객체를 나타내는 것
	일반적으로 레코드(Record)라고 함
```

```java
Q. 데이터의 집합을 왜 디스크 파일로 구성하는가?

주기억장치에 전부 적재하기에 데이터 크기가 너무 많다.

프로그램은 특정시간에 데이터 집합의 일부만 접근한다.
–> 데이터 전부를 주기억장치에 한꺼번에 저장시킬 필요가 없음

데이터를 특정 프로그램의 수행과 독립적으로 보관시켜 데이터의 독립성(independency)을 유지하기 위함.
여러 응용프로그램이 공용하기 쉬움
```

# 파일의 분류: 
## 기능 vs 프로그램 파일 접근 목적
```java
(1) 마스터 파일
어느 한 시점에서 조직체의 업무에 관한 정적인 면을 나타내는 데이터의 집합
(정적이다 : 한 번 생성시 변화가 거의 X)
예(제조 회사) : 급여 마스터 파일, 고객 마스터 파일, 인사 마스터 파일


- 비교적 영구적(Permanent)인 데이터 즉 역사적 데이터(Historical status data)를 포함 // 한 번 생성시 변화가 거의 X 보통 파일이라 하면 마스터 파일을 의미
- 사전 파일 (Dictionary file) : 마스터 파일의 특수한 형태
- 데이터에 대한 기술(Description) : 타입, 크기, 이름. 활용 등과 데이터에 대한 설명을 보관

(2) 트랜잭션 파일
- 마스터 파일의 변경 내용을 모아 둔 파일
- 마스터 파일과 반대로 자주 바뀐다
- 마스터 파일을 변경(Update)하기 위한 데이터 파일
	새로운 레코드 삽입 (Insert)
	현존 레코드 삭제 (Delete)
	현존 레코드 수정 (Modify, Replace)
- 트랜잭션(Transaction)이란?
	하나의 논리적인 작업 단위
	하나의 건수로 처리되어야 하는 분리될 수 없는 단일 작업

(3) 보고서 파일
- 사용자에게 정보 검색의 결과를 보여주기 위해 일정한 형식을 갖춘(Formatted) 데이터를 저장하고 있는 파일

(4) 작업 파일
- 어느 한 프로그램에서 생성된 출력 데이터를 다른 프로그램의 입력 데이터로 사용하기 위해 임시로 만드는 파일(Temporary file)
- 시스템이 자동으로 만드는 작업 파일
	예) 정렬을 위한 파일


(5) 프로그램 파일
- 데이터를 처리하기 위한 명렁어들을 저장하고 있는 파일

(6) 텍스트 파일
- 문자 숫자와 그래픽 데이터를 포함하고 있는 파일
```

## 파일의 분류 (2)
```java
- 프로그램의 파일 접근 목적에 따라
	(1) 입력 파일 (Input File)
	프로그램이 읽기(Read)만 하는 파일
	(2) 출력 파일 (Output File)
	프로그램이 기록(Write)하여 만든 파일
	(3) 입/출력 파일 (Input/Output File)
	프로그램의 실행 중 읽기도 하고 기록하기도 하는 파일
```

# 파일의 연산
```java
일괄처리(Batch) 형식
	마스터 파일을 효율적으로 접근하도록 트랜잭션들을 구성
	트랜잭션들을 그룹화하여 처리하는 성능이 주요 관심사 모왔다가 한 번에 처리 !
대화(Interactive 형식
	트랜잭션이 터미널에 도착하는 대로 구성하고 처리
	개개 트랜잭션의 처리 성능이 주요 관심사
	현재는 대부분이 대화식 !
```

## 파일에 대한 기본 연산
```java
파일 생성 : 데이터 정의

파일 기록 : 레코드 삽입, 삭제, 갱신

파일 판독 : 파일의 이름과 판독해야 할 블록을 명세

파일 삭제 : 파일 제거

파일의 개방과 폐쇄 : 버퍼의 할당과 반환
```
## (1) 생성 (Creation)
```java
데이터 수집(Collection)과 확인(Validation)

데이터 적재(Loading)

공간 할당
데이터가 한꺼번에 적재 혹은 한 번에 한 레코드씩 구성
새로운 파일에 대한 엔트리가 디렉토리에 만들어짐
```

## 파일 구조 선정 요소
```java
주기억 장치
	최대 비교 연산 횟수로 평가
	–> 빅오 시간복잡도
보조 저장 장치
	데이터 접근 시간이 메인 메모리에 비해 얼마나 느린가?
	약 pow(10,5)
	보조 저장 장치의 접근 회수 (Number of Dist I/O)가 프로그램 성능 평가 요소
	==> 파일 구조 선정의 중요한 요소 // 디스크 접근을 줄이자
```

## 파일 구조 선정 요소
```java
파일 접근 유형

가변성

활동성

사용빈도수

응답 시간

파일 크기
```
# [파일 압축](https://www.youtube.com/watch?v=v63h5e5wWwc&list=PLLcbGhhl4sQDOYzzB8eNB7m0IdVffIyLM&index=43)
1. 손실 압축: 데이터 압축 과정에서 원본 데이터 손실; 압축률이 좋음

2. 비손실 압축: 압축 이후에도 원본 데이터 유지
	* MP3

	1. RLE; 
		* 0과 1로 이루어진 모든 파일을 큰 숫자로 줄이는 것
		* 문서 파일의 압축에는 약함
	2. 허프만 부호화
		* 모든 글자 탐색 후 자주 나오는 글자에 낮은 숫자 부여(한자리 수)
	3. LZ77, LZ78; 뒤의 숫자는 연도
		* 모든 글자를 일단 한번 읽기 = 허프만
		* 단어에도 큰 의미 부여 <> 허프만의 글자 단위
		* WinRAR, 알집, tar, PNG, DOCX, PDF


## 파일 삭제
### HDD 삭제
1. 휴지통 삭제: invalid bit 만 0에서 1로 바꾼 것;
2. 와이퍼 툴을 사용; 파일 내용도 1111(쓰레기 값)으로 채워줌
3. 자력 현미경으로 복구 가능; 피터 구트만; 공간적 변화의 흔적; 즉 1의 값이 아니라 0.95, 1.05 등 의 값으로 바뀐다는 의견
	* 하지만 하드의 상태가 좋을 때 더 잘 복구 가능
4. 물리적인 조치' 디가우저 이용(천만원 이상)

### SSD
* FTL마다 삭제된 파일의 자리륵 확보하기 위해 공간을 정리해준느 쓰레기 수거/TRIM 동작 타이밍이 다르다.

## (1) 파일 접근 유형
* 파일 접근 유형과 파일 구조
* 연산의 유형과 접근 형식에 다라 파일 구조 결정

## (2) 가변성 (Volatility)
* 가변성
	* 전체 레코드 수에 대해 추가되거나 삭제되는 레코드 수
	* 가변성이 높고 동적인 파일은 빠르게 접근되고 갱신될 수 있도록 파일을 구성해야 함

## (3) 활동성 (Activity)
* 파일의 활동성
* 주어진 기간 동안에 파일의 총 레코드 수에 대해 접근한 레코드 수의 비율
* 활동성이 높으면 순차 파일구조가 좋을 수 있음
* 얼마나 많은 레코드들을 검색하느냐 –> 활동성
* 얼마나 많은 레코드들을 바꾸느냐 –> 가변성

## (4) 사용 빈도수 (Frequency of use)
* 파일의 사용 빈도수
* 가변성과 활동성에 밀접히 관련
* 파일 사용이 빈번할수록 파일에 대한 임의 접근 필요성은 더욱 높아질 것

## (5) 응답 시간 (Response Time)
* 응답 시간과 파일 구조
* 파일에 대한 접근 방법을 결정하는 데 중요한 요소가 됨
* 초 단위로 빠른 응답 시간을 필요로 하면 임의 접근 방법을 선택해야 됨
* 순차적으로 정렬된 키에 따라 레코드를 검색한다면 순차 접근 방법으로 조직하는 것이 유리

## (6) 파일 크기 (File Size)
* 파일 크기와 파일 구조
* 성장을 유연하게 수용할 수 있는 구조 필요
* 일반적으로 30% 추가해서 설계
* 파일 성장을 유연하게 수용할 수 없을 시 파일을 재조직(Reorganization해야 됨

# 파일
* 메모리에 모두 올려놓을 수 없으니 논리적으로 만들어 놓은 구조

# 완전 파일 삭제
* shift delete나 휴지통 비우기는 invalid bit를 바꾸기만 한 것
	* Forensic website; 
	* Wiper 툴을 이용하여 지워도 자력 현미경을 이용하면 공간적 변화에 의한 흔적이 남는다고 한다; 하지만 하드 상태에 따라 복구할 수 있는 것이 다루고, 법적 효력여부도 확실하지 않다.
	* 하드웨어적으로 지우는것이 확실; 디가우저

# 랜덤숫자
* 폰 노이만이 에니악 만들던 시절 컴퓨터에게 랜덤 숫자를 알려줘야 했음; 자연의 숫자를 녹음한 후 숫자료 변경 -> 현재 시간 이용; -> 평방 채중법 이용 
* 현재: rand() 함수로 난수 60개 패턴의 테이블과 현재 시간을 이용하기
	2. 노이즈(HDD, FA 등 노이즈 이용) 하여 값을 이용 
* 세계 최초로 양자난수; 2017년 SK텔레콤이 분당사옥에 있는 '양자암호통신 국가시험망'에서 5x5mm 크기의 '양자난수생성 칩'이 구현되는 모습을 처음 공개; 수달러 수준으로 저렴해진 가격과 손톱보다 작은 초소형 칩형태라는 점에서 세계가 주목하고 있다. 반도체 칩 형태의 양자난수생성기는 제품 개발 단계부터 탑재해 사용 가능하다. 반면 USB형태는 이미 상용화된 제품에도 연결만 하면 양자난수를 생성해줄 수 있어 활용가치가 높아지는 이점이 있다. 


# Object

# Binary
* bin, ser(serialization) 파일
* 2진법 (1100 0011)으로 되어있는 파일

# Serialiazation
* 목적: 저장(Object -> binary(하드디스크))
* 자바: FileOutputStream -> ObjectOutputStream

# Deserialiazation
* binary(하드디스크) -> Object; 하드디스크의 정보를 가져옴


